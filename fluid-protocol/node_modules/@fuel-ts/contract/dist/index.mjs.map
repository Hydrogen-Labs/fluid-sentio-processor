{"version":3,"sources":["../src/contract-factory.ts","../src/loader/loader-script.ts","../src/loader/predicate-script-loader-instructions.ts","../src/loader/utils.ts","../src/util.ts"],"sourcesContent":["import { Interface, WORD_SIZE } from '@fuel-ts/abi-coder';\nimport type { JsonAbi, InputValue } from '@fuel-ts/abi-coder';\nimport type {\n  Account,\n  CreateTransactionRequestLike,\n  Provider,\n  TransactionRequest,\n  TransactionResult,\n  TransactionType,\n} from '@fuel-ts/account';\nimport {\n  CreateTransactionRequest,\n  BlobTransactionRequest,\n  TransactionStatus,\n  calculateGasFee,\n} from '@fuel-ts/account';\nimport { randomBytes } from '@fuel-ts/crypto';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { hash } from '@fuel-ts/hasher';\nimport type { BytesLike } from '@fuel-ts/interfaces';\nimport { bn } from '@fuel-ts/math';\nimport { Contract } from '@fuel-ts/program';\nimport type { StorageSlot } from '@fuel-ts/transactions';\nimport { arrayify, isDefined, hexlify } from '@fuel-ts/utils';\n\nimport {\n  getLoaderInstructions,\n  getPredicateScriptLoaderInstructions,\n  getContractChunks,\n  getDataOffset,\n} from './loader';\nimport { getContractId, getContractStorageRoot, hexlifyWithPrefix } from './util';\n\n/** Amount of percentage override for chunk sizes in blob transactions */\nconst CHUNK_SIZE_MULTIPLIER = 0.95;\n\n/**\n * Options for deploying a contract.\n */\nexport type DeployContractOptions = {\n  salt?: BytesLike;\n  storageSlots?: StorageSlot[];\n  stateRoot?: BytesLike;\n  configurableConstants?: { [name: string]: unknown };\n  chunkSizeMultiplier?: number;\n} & CreateTransactionRequestLike;\n\nexport type DeployContractResult<TContract extends Contract = Contract> = {\n  contractId: string;\n  waitForTransactionId: () => Promise<string>;\n  waitForResult: () => Promise<{\n    contract: TContract;\n    transactionResult: TransactionResult<TransactionType.Create>;\n  }>;\n};\n\n/**\n * `ContractFactory` provides utilities for deploying and configuring contracts.\n */\nexport default class ContractFactory {\n  bytecode: BytesLike;\n  interface: Interface;\n  provider!: Provider | null;\n  account!: Account | null;\n\n  /**\n   * Create a ContractFactory instance.\n   *\n   * @param bytecode - The bytecode of the contract.\n   * @param abi - The contract's ABI (Application Binary Interface).\n   * @param accountOrProvider - An account or provider to be associated with the factory.\n   */\n  constructor(\n    bytecode: BytesLike,\n    abi: JsonAbi | Interface,\n    accountOrProvider: Account | Provider | null = null\n  ) {\n    // Force the bytecode to be a byte array\n    this.bytecode = arrayify(bytecode);\n\n    if (abi instanceof Interface) {\n      this.interface = abi;\n    } else {\n      this.interface = new Interface(abi);\n    }\n\n    /**\n     Instead of using `instanceof` to compare classes, we instead check\n      if `accountOrProvider` has a `provider` property inside. If yes,\n      than we assume it's a Wallet.\n\n      This approach is safer than using `instanceof` because it\n      there might be different versions and bundles of the library.\n\n      The same is done at:\n      - ./contract.ts\n\n      @see Contract\n      */\n    if (accountOrProvider && 'provider' in accountOrProvider) {\n      this.provider = accountOrProvider.provider;\n      this.account = accountOrProvider;\n    } else {\n      this.provider = accountOrProvider;\n      this.account = null;\n    }\n  }\n\n  /**\n   * Connect the factory to a provider.\n   *\n   * @param provider - The provider to be associated with the factory.\n   * @returns A new ContractFactory instance.\n   */\n  connect(provider: Provider) {\n    return new ContractFactory(this.bytecode, this.interface, provider);\n  }\n\n  /**\n   * Create a transaction request to deploy a contract with the specified options.\n   *\n   * @param deployOptions - Options for deploying the contract.\n   * @returns The CreateTransactionRequest object for deploying the contract.\n   */\n  createTransactionRequest(deployOptions?: DeployContractOptions & { bytecode?: BytesLike }) {\n    const storageSlots = deployOptions?.storageSlots\n      ?.map(({ key, value }) => ({\n        key: hexlifyWithPrefix(key),\n        value: hexlifyWithPrefix(value),\n      }))\n      .sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));\n\n    const options = {\n      salt: randomBytes(32),\n      ...deployOptions,\n      storageSlots: storageSlots || [],\n    };\n\n    if (!this.provider) {\n      throw new FuelError(\n        ErrorCode.MISSING_PROVIDER,\n        'Cannot create transaction request without provider'\n      );\n    }\n\n    const bytecode = deployOptions?.bytecode || this.bytecode;\n    const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);\n    const contractId = getContractId(bytecode, options.salt, stateRoot);\n    const transactionRequest = new CreateTransactionRequest({\n      bytecodeWitnessIndex: 0,\n      witnesses: [bytecode],\n      ...options,\n    });\n    transactionRequest.addContractCreatedOutput(contractId, stateRoot);\n\n    return {\n      contractId,\n      transactionRequest,\n    };\n  }\n\n  /**\n   * Takes a transaction request, estimates it and funds it.\n   *\n   * @param request - the request to fund.\n   * @param options - options for funding the request.\n   * @returns a funded transaction request.\n   */\n  private async fundTransactionRequest(\n    request: TransactionRequest,\n    options: DeployContractOptions = {}\n  ) {\n    const account = this.getAccount();\n    const { maxFee: setMaxFee } = options;\n\n    const txCost = await account.getTransactionCost(request);\n\n    if (isDefined(setMaxFee)) {\n      if (txCost.maxFee.gt(setMaxFee)) {\n        throw new FuelError(\n          ErrorCode.MAX_FEE_TOO_LOW,\n          `Max fee '${options.maxFee}' is lower than the required: '${txCost.maxFee}'.`\n        );\n      }\n    } else {\n      request.maxFee = txCost.maxFee;\n    }\n\n    await account.fund(request, txCost);\n\n    return request;\n  }\n\n  /**\n   * Deploy a contract of any length with the specified options.\n   *\n   * @param deployOptions - Options for deploying the contract.\n   * @returns A promise that resolves to the deployed contract instance.\n   */\n  async deploy<TContract extends Contract = Contract>(\n    deployOptions: DeployContractOptions = {}\n  ): Promise<DeployContractResult<TContract>> {\n    const account = this.getAccount();\n    const { consensusParameters } = account.provider.getChain();\n    const maxContractSize = consensusParameters.contractParameters.contractMaxSize.toNumber();\n\n    return this.bytecode.length > maxContractSize\n      ? this.deployAsBlobTx(deployOptions)\n      : this.deployAsCreateTx(deployOptions);\n  }\n\n  /**\n   * Deploy a contract with the specified options.\n   *\n   * @param deployOptions - Options for deploying the contract.\n   * @returns A promise that resolves to the deployed contract instance.\n   */\n  async deployAsCreateTx<TContract extends Contract = Contract>(\n    deployOptions: DeployContractOptions = {}\n  ): Promise<DeployContractResult<TContract>> {\n    const account = this.getAccount();\n    const { consensusParameters } = account.provider.getChain();\n    const maxContractSize = consensusParameters.contractParameters.contractMaxSize.toNumber();\n\n    if (this.bytecode.length > maxContractSize) {\n      throw new FuelError(\n        ErrorCode.CONTRACT_SIZE_EXCEEDS_LIMIT,\n        'Contract bytecode is too large. Please use `deployAsBlobTx` instead.'\n      );\n    }\n\n    const { contractId, transactionRequest } = await this.prepareDeploy(deployOptions);\n\n    const transactionResponse = await account.sendTransaction(transactionRequest);\n\n    const waitForResult = async () => {\n      const transactionResult = await transactionResponse.waitForResult<TransactionType.Create>();\n      const contract = new Contract(contractId, this.interface, account) as TContract;\n\n      return { contract, transactionResult };\n    };\n\n    return {\n      contractId,\n      waitForTransactionId: () => Promise.resolve(transactionResponse.id),\n      waitForResult,\n    };\n  }\n\n  /**\n   * Chunks and deploys a contract via a loader contract. Suitable for deploying contracts larger than the max contract size.\n   *\n   * @param deployOptions - Options for deploying the contract.\n   * @returns A promise that resolves to the deployed contract instance.\n   */\n  async deployAsBlobTx<TContract extends Contract = Contract>(\n    deployOptions: DeployContractOptions = {\n      chunkSizeMultiplier: CHUNK_SIZE_MULTIPLIER,\n    }\n  ): Promise<DeployContractResult<TContract>> {\n    const account = this.getAccount();\n    const { configurableConstants, chunkSizeMultiplier } = deployOptions;\n    if (configurableConstants) {\n      this.setConfigurableConstants(configurableConstants);\n    }\n\n    // Generate the chunks based on the maximum chunk size and create blob txs\n    const chunkSize = this.getMaxChunkSize(deployOptions, chunkSizeMultiplier);\n    const chunks = getContractChunks(arrayify(this.bytecode), chunkSize).map((c) => {\n      const transactionRequest = this.blobTransactionRequest({\n        ...deployOptions,\n        bytecode: c.bytecode,\n      });\n      return {\n        ...c,\n        transactionRequest,\n        blobId: transactionRequest.blobId,\n      };\n    });\n\n    // Generate the associated create tx for the loader contract\n    const blobIds = chunks.map(({ blobId }) => blobId);\n    const loaderBytecode = getLoaderInstructions(blobIds);\n    const { contractId, transactionRequest: createRequest } = this.createTransactionRequest({\n      bytecode: loaderBytecode,\n      ...deployOptions,\n    });\n\n    // BlobIDs only need to be uploaded once and we can check if they exist on chain\n    const uniqueBlobIds = [...new Set(blobIds)];\n    const uploadedBlobIds = await account.provider.getBlobs(uniqueBlobIds);\n    const blobIdsToUpload = uniqueBlobIds.filter((id) => !uploadedBlobIds.includes(id));\n\n    // Check the account can afford to deploy all chunks and loader\n    let totalCost = bn(0);\n    const chainInfo = account.provider.getChain();\n    const gasPrice = await account.provider.estimateGasPrice(10);\n    const priceFactor = chainInfo.consensusParameters.feeParameters.gasPriceFactor;\n\n    for (const { transactionRequest, blobId } of chunks) {\n      if (blobIdsToUpload.includes(blobId)) {\n        const minGas = transactionRequest.calculateMinGas(chainInfo);\n        const minFee = calculateGasFee({\n          gasPrice,\n          gas: minGas,\n          priceFactor,\n          tip: transactionRequest.tip,\n        }).add(1);\n\n        totalCost = totalCost.add(minFee);\n      }\n      const createMinGas = createRequest.calculateMinGas(chainInfo);\n      const createMinFee = calculateGasFee({\n        gasPrice,\n        gas: createMinGas,\n        priceFactor,\n        tip: createRequest.tip,\n      }).add(1);\n      totalCost = totalCost.add(createMinFee);\n    }\n    if (totalCost.gt(await account.getBalance())) {\n      throw new FuelError(ErrorCode.FUNDS_TOO_LOW, 'Insufficient balance to deploy contract.');\n    }\n\n    // Transaction id is unset until we have funded the create tx, which is dependent on the blob txs\n    let txIdResolver: (value: string | PromiseLike<string>) => void;\n    const txIdPromise = new Promise<string>((resolve) => {\n      txIdResolver = resolve;\n    });\n\n    const waitForResult = async () => {\n      // Upload the blob if it hasn't been uploaded yet. Duplicate blob IDs will fail gracefully.\n      const uploadedBlobs: string[] = [];\n      // Deploy the chunks as blob txs\n      for (const { blobId, transactionRequest } of chunks) {\n        if (!uploadedBlobs.includes(blobId) && blobIdsToUpload.includes(blobId)) {\n          const fundedBlobRequest = await this.fundTransactionRequest(\n            transactionRequest,\n            deployOptions\n          );\n\n          let result: TransactionResult<TransactionType.Blob>;\n\n          try {\n            const blobTx = await account.sendTransaction(fundedBlobRequest);\n            result = await blobTx.waitForResult();\n          } catch (err: unknown) {\n            // Core will throw for blobs that have already been uploaded, but the blobId\n            // is still valid so we can use this for the loader contract\n            if ((<Error>err).message.indexOf(`BlobId is already taken ${blobId}`) > -1) {\n              uploadedBlobs.push(blobId);\n              continue;\n            }\n\n            throw new FuelError(ErrorCode.TRANSACTION_FAILED, 'Failed to deploy contract chunk');\n          }\n\n          if (!result.status || result.status !== TransactionStatus.success) {\n            throw new FuelError(ErrorCode.TRANSACTION_FAILED, 'Failed to deploy contract chunk');\n          }\n\n          uploadedBlobs.push(blobId);\n        }\n      }\n\n      await this.fundTransactionRequest(createRequest, deployOptions);\n      txIdResolver(createRequest.getTransactionId(account.provider.getChainId()));\n      const transactionResponse = await account.sendTransaction(createRequest);\n      const transactionResult = await transactionResponse.waitForResult<TransactionType.Create>();\n      const contract = new Contract(contractId, this.interface, account) as TContract;\n\n      return { contract, transactionResult };\n    };\n\n    const waitForTransactionId = () => txIdPromise;\n\n    return { waitForResult, contractId, waitForTransactionId };\n  }\n\n  async deployAsBlobTxForScript(): Promise<{\n    waitForResult: () => Promise<{\n      loaderBytecode: string;\n      configurableOffsetDiff: number;\n    }>;\n    blobId: string;\n  }> {\n    const account = this.getAccount();\n\n    const dataSectionOffset = getDataOffset(arrayify(this.bytecode));\n    const byteCodeWithoutDataSection = this.bytecode.slice(0, dataSectionOffset);\n\n    // Generate the associated create tx for the loader contract\n    const blobId = hash(byteCodeWithoutDataSection);\n\n    const bloTransactionRequest = this.blobTransactionRequest({\n      bytecode: byteCodeWithoutDataSection,\n    });\n\n    const { loaderBytecode, blobOffset } = getPredicateScriptLoaderInstructions(\n      arrayify(this.bytecode),\n      arrayify(blobId)\n    );\n\n    const configurableOffsetDiff = byteCodeWithoutDataSection.length - (blobOffset || 0);\n\n    const blobExists = (await account.provider.getBlobs([blobId])).length > 0;\n    if (blobExists) {\n      return {\n        waitForResult: () =>\n          Promise.resolve({ loaderBytecode: hexlify(loaderBytecode), configurableOffsetDiff }),\n        blobId,\n      };\n    }\n\n    // Check the account can afford to deploy all chunks and loader\n    let totalCost = bn(0);\n    const chainInfo = account.provider.getChain();\n    const gasPrice = await account.provider.estimateGasPrice(10);\n    const priceFactor = chainInfo.consensusParameters.feeParameters.gasPriceFactor;\n\n    const minGas = bloTransactionRequest.calculateMinGas(chainInfo);\n    const minFee = calculateGasFee({\n      gasPrice,\n      gas: minGas,\n      priceFactor,\n      tip: bloTransactionRequest.tip,\n    }).add(1);\n\n    totalCost = totalCost.add(minFee);\n\n    if (totalCost.gt(await account.getBalance())) {\n      throw new FuelError(ErrorCode.FUNDS_TOO_LOW, 'Insufficient balance to deploy contract.');\n    }\n\n    // Transaction id is unset until we have funded the create tx, which is dependent on the blob txs\n    const waitForResult = async () => {\n      // Deploy the chunks as blob txs\n      const fundedBlobRequest = await this.fundTransactionRequest(bloTransactionRequest);\n\n      let result: TransactionResult<TransactionType.Blob>;\n\n      try {\n        const blobTx = await account.sendTransaction(fundedBlobRequest);\n        result = await blobTx.waitForResult();\n      } catch (err: unknown) {\n        throw new FuelError(ErrorCode.TRANSACTION_FAILED, 'Failed to deploy contract chunk');\n      }\n\n      if (!result.status || result.status !== TransactionStatus.success) {\n        throw new FuelError(ErrorCode.TRANSACTION_FAILED, 'Failed to deploy contract chunk');\n      }\n\n      return { loaderBytecode: hexlify(loaderBytecode), configurableOffsetDiff };\n    };\n\n    return {\n      waitForResult,\n      blobId,\n    };\n  }\n\n  /**\n   * Set configurable constants of the contract with the specified values.\n   *\n   * @param configurableConstants - An object containing configurable names and their values.\n   */\n  setConfigurableConstants(configurableConstants: { [name: string]: unknown }) {\n    try {\n      const hasConfigurable = Object.keys(this.interface.configurables).length;\n\n      if (!hasConfigurable) {\n        throw new FuelError(\n          ErrorCode.CONFIGURABLE_NOT_FOUND,\n          'Contract does not have configurables to be set'\n        );\n      }\n\n      Object.entries(configurableConstants).forEach(([key, value]) => {\n        if (!this.interface.configurables[key]) {\n          throw new FuelError(\n            ErrorCode.CONFIGURABLE_NOT_FOUND,\n            `Contract does not have a configurable named: '${key}'`\n          );\n        }\n\n        const { offset } = this.interface.configurables[key];\n\n        const encoded = this.interface.encodeConfigurable(key, value as InputValue);\n\n        const bytes = arrayify(this.bytecode);\n\n        bytes.set(encoded, offset);\n\n        this.bytecode = bytes;\n      });\n    } catch (err) {\n      throw new FuelError(\n        ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,\n        `Error setting configurable constants on contract: ${(<Error>err).message}.`\n      );\n    }\n  }\n\n  private getAccount(): Account {\n    if (!this.account) {\n      throw new FuelError(ErrorCode.ACCOUNT_REQUIRED, 'Account not assigned to contract.');\n    }\n    return this.account;\n  }\n\n  private async prepareDeploy(deployOptions: DeployContractOptions) {\n    const { configurableConstants } = deployOptions;\n\n    if (configurableConstants) {\n      this.setConfigurableConstants(configurableConstants);\n    }\n\n    const { contractId, transactionRequest } = this.createTransactionRequest(deployOptions);\n\n    await this.fundTransactionRequest(transactionRequest, deployOptions);\n\n    return {\n      contractId,\n      transactionRequest,\n    };\n  }\n\n  /**\n   * Create a blob transaction request, used for deploying contract chunks.\n   *\n   * @param options - options for creating a blob transaction request.\n   * @returns a populated BlobTransactionRequest.\n   */\n  private blobTransactionRequest(options: { bytecode: BytesLike } & DeployContractOptions) {\n    const { bytecode } = options;\n    return new BlobTransactionRequest({\n      blobId: hash(bytecode),\n      witnessIndex: 0,\n      witnesses: [bytecode],\n      ...options,\n    });\n  }\n\n  /**\n   * Get the maximum chunk size for deploying a contract by chunks.\n   */\n  private getMaxChunkSize(\n    deployOptions: DeployContractOptions,\n    chunkSizeMultiplier: number = CHUNK_SIZE_MULTIPLIER\n  ) {\n    if (chunkSizeMultiplier < 0 || chunkSizeMultiplier > 1) {\n      throw new FuelError(\n        ErrorCode.INVALID_CHUNK_SIZE_MULTIPLIER,\n        'Chunk size multiplier must be between 0 and 1'\n      );\n    }\n\n    const account = this.getAccount();\n    const { consensusParameters } = account.provider.getChain();\n    const contractSizeLimit = consensusParameters.contractParameters.contractMaxSize.toNumber();\n    const transactionSizeLimit = consensusParameters.txParameters.maxSize.toNumber();\n    const maxLimit = 64000;\n    const chainLimit =\n      transactionSizeLimit < contractSizeLimit ? transactionSizeLimit : contractSizeLimit;\n    const sizeLimit = chainLimit < maxLimit ? chainLimit : maxLimit;\n\n    // Get an estimate base tx length\n\n    const blobTx = this.blobTransactionRequest({\n      ...deployOptions,\n      bytecode: randomBytes(32),\n    }).addResources(\n      account.generateFakeResources([{ assetId: account.provider.getBaseAssetId(), amount: bn(1) }])\n    );\n    // Given above, calculate the maximum chunk size\n    const maxChunkSize = (sizeLimit - blobTx.byteLength() - WORD_SIZE) * chunkSizeMultiplier;\n\n    // Ensure chunksize is byte aligned\n    return Math.round(maxChunkSize / WORD_SIZE) * WORD_SIZE;\n  }\n}\n","import { BYTES_32 } from '@fuel-ts/abi-coder';\nimport { InstructionSet } from '@fuel-ts/program';\nimport { arrayify, concat } from '@fuel-ts/utils';\nimport * as asm from '@fuels/vm-asm';\n\nexport const getLoaderInstructions = (blobIds: string[]): Uint8Array => {\n  const { RegId, Instruction } = asm;\n\n  const numberOfInstructions = 12;\n  const numberOfBlobs = blobIds.length;\n  const blobIdSize = BYTES_32;\n\n  // Bytes for the Blob Ids\n  const blobIdBytes = concat(blobIds.map((b) => arrayify(b)));\n\n  // Reference: https://github.com/FuelLabs/fuels-rs/blob/master/packages/fuels-programs/src/contract/loader.rs\n  // There are 2 main steps:\n  // 1. Load the blob contents into memory\n  // 2. Jump to the beginning of the memory where the blobs were loaded\n  // After that the execution continues normally with the loaded contract reading our\n  // prepared fn selector and jumps to the selected contract method.\n  const instructionBytes = new InstructionSet(\n    // 1. load the blob contents into memory\n    // find the start of the hardcoded blob ids, which are located after the code ends\n    asm.move_(0x10, RegId.pc().to_u8()),\n    // 0x10 to hold the address of the current blob id\n    asm.addi(0x10, 0x10, numberOfInstructions * Instruction.size()),\n    // The contract is going to be loaded from the current value of SP onwards, save\n    // the location into 0x16 so we can jump into it later on\n    asm.move_(0x16, RegId.sp().to_u8()),\n    // loop counter\n    asm.movi(0x13, numberOfBlobs),\n    // LOOP starts here\n    // 0x11 to hold the size of the current blob\n    asm.bsiz(0x11, 0x10),\n    // push the blob contents onto the stack\n    asm.ldc(0x10, 0, 0x11, 1),\n    // move on to the next blob\n    asm.addi(0x10, 0x10, blobIdSize),\n    // decrement the loop counter\n    asm.subi(0x13, 0x13, 1),\n    // Jump backwards (3+1) instructions if the counter has not reached 0\n    asm.jnzb(0x13, RegId.zero().to_u8(), 3),\n    // Jump into the memory where the contract is loaded\n    // what follows is called _jmp_mem by the sway compiler\n    // subtract the address contained in IS because jmp will add it back\n    asm.sub(0x16, 0x16, RegId.is().to_u8()),\n    // jmp will multiply by 4 so we need to divide to cancel that out\n    asm.divi(0x16, 0x16, 4),\n    // jump to the start of the contract we loaded\n    asm.jmp(0x16)\n  ).toBytes();\n\n  return concat([instructionBytes, blobIdBytes]);\n};\n","import { concat } from '@fuel-ts/utils';\nimport * as asm from '@fuels/vm-asm';\n\nconst BLOB_ID_SIZE = 32;\nconst REG_ADDRESS_OF_DATA_AFTER_CODE = 0x10;\nconst REG_START_OF_LOADED_CODE = 0x11;\nconst REG_GENERAL_USE = 0x12;\nconst WORD_SIZE = 8; // size in bytes\n\nexport function getDataOffset(binary: Uint8Array): number {\n  // Extract 8 bytes starting from index 8 (similar to binary[8..16] in Rust)\n  const OFFSET_INDEX = 8;\n  const dataView = new DataView(binary.buffer, OFFSET_INDEX, 8);\n\n  // Read the value as a 64-bit big-endian unsigned integer\n  const dataOffset = dataView.getBigUint64(0, false); // false means big-endian\n\n  // Convert the BigInt to a regular number (safe as long as the offset is within Number.MAX_SAFE_INTEGER)\n  return Number(dataOffset);\n}\n\nexport function getPredicateScriptLoaderInstructions(\n  originalBinary: Uint8Array,\n  blobId: Uint8Array\n) {\n  // The final code is going to have this structure:\n  // 1. loader instructions\n  // 2. blob id\n  // 3. length_of_data_section\n  // 4. the data_section (updated with configurables as needed)\n\n  const { RegId, Instruction } = asm;\n\n  const REG_PC = RegId.pc().to_u8();\n  const REG_SP = RegId.sp().to_u8();\n  const REG_IS = RegId.is().to_u8();\n\n  const getInstructions = (numOfInstructions: number) => [\n    // 1. Load the blob content into memory\n    // Find the start of the hardcoded blob ID, which is located after the loader code ends.\n    asm.move_(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_PC),\n    // hold the address of the blob ID.\n    asm.addi(\n      REG_ADDRESS_OF_DATA_AFTER_CODE,\n      REG_ADDRESS_OF_DATA_AFTER_CODE,\n      numOfInstructions * Instruction.size()\n    ),\n    // The code is going to be loaded from the current value of SP onwards, save\n    // the location into REG_START_OF_LOADED_CODE so we can jump into it at the end.\n    asm.move_(REG_START_OF_LOADED_CODE, REG_SP),\n    // REG_GENERAL_USE to hold the size of the blob.\n    asm.bsiz(REG_GENERAL_USE, REG_ADDRESS_OF_DATA_AFTER_CODE),\n    // Push the blob contents onto the stack.\n    asm.ldc(REG_ADDRESS_OF_DATA_AFTER_CODE, 0, REG_GENERAL_USE, 1),\n    // Move on to the data section length\n    asm.addi(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_ADDRESS_OF_DATA_AFTER_CODE, BLOB_ID_SIZE),\n    // load the size of the data section into REG_GENERAL_USE\n    asm.lw(REG_GENERAL_USE, REG_ADDRESS_OF_DATA_AFTER_CODE, 0),\n    // after we have read the length of the data section, we move the pointer to the actual\n    // data by skipping WORD_SIZE bytes.\n    asm.addi(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_ADDRESS_OF_DATA_AFTER_CODE, WORD_SIZE),\n    // load the data section of the executable\n    asm.ldc(REG_ADDRESS_OF_DATA_AFTER_CODE, 0, REG_GENERAL_USE, 2),\n    // Jump into the memory where the contract is loaded.\n    // What follows is called _jmp_mem by the sway compiler.\n    // Subtract the address contained in IS because jmp will add it back.\n    asm.sub(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, REG_IS),\n    // jmp will multiply by 4, so we need to divide to cancel that out.\n    asm.divi(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, 4),\n    // Jump to the start of the contract we loaded.\n    asm.jmp(REG_START_OF_LOADED_CODE),\n  ];\n\n  const getInstructionsNoDataSection = (numOfInstructions: number) => [\n    // 1. Load the blob content into memory\n    // Find the start of the hardcoded blob ID, which is located after the loader code ends.\n    // 1. Load the blob content into memory\n    // Find the start of the hardcoded blob ID, which is located after the loader code ends.\n    asm.move_(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_PC),\n    // hold the address of the blob ID.\n    asm.addi(\n      REG_ADDRESS_OF_DATA_AFTER_CODE,\n      REG_ADDRESS_OF_DATA_AFTER_CODE,\n      numOfInstructions * Instruction.size()\n    ),\n    // The code is going to be loaded from the current value of SP onwards, save\n    // the location into REG_START_OF_LOADED_CODE so we can jump into it at the end.\n    asm.move_(REG_START_OF_LOADED_CODE, REG_SP),\n    // REG_GENERAL_USE to hold the size of the blob.\n    asm.bsiz(REG_GENERAL_USE, REG_ADDRESS_OF_DATA_AFTER_CODE),\n    // Push the blob contents onto the stack.\n    asm.ldc(REG_ADDRESS_OF_DATA_AFTER_CODE, 0, REG_GENERAL_USE, 1),\n    // Jump into the memory where the contract is loaded.\n    // What follows is called _jmp_mem by the sway compiler.\n    // Subtract the address contained in IS because jmp will add it back.\n    asm.sub(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, REG_IS),\n    // jmp will multiply by 4, so we need to divide to cancel that out.\n    asm.divi(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, 4),\n    // Jump to the start of the contract we loaded.\n    asm.jmp(REG_START_OF_LOADED_CODE),\n  ];\n\n  const offset = getDataOffset(originalBinary);\n\n  // if the binary length is smaller than the offset\n  if (originalBinary.length < offset) {\n    throw new Error(\n      `Data section offset is out of bounds, offset: ${offset}, binary length: ${originalBinary.length}`\n    );\n  }\n\n  // Extract the data section from the binary (slice from the offset onwards)\n  const dataSection = originalBinary.slice(offset);\n\n  // Check if the data section is non-empty\n  if (dataSection.length > 0) {\n    // Get the number of instructions (assuming it won't exceed u16::MAX)\n    const numOfInstructions = getInstructions(0).length;\n    if (numOfInstructions > 65535) {\n      throw new Error('Too many instructions, exceeding u16::MAX.');\n    }\n\n    // Convert instructions to bytes\n    const instructionBytes = new Uint8Array(\n      getInstructions(numOfInstructions).flatMap((instruction) =>\n        Array.from(instruction.to_bytes())\n      )\n    );\n\n    // Convert blobId to bytes\n    const blobBytes = new Uint8Array(blobId);\n\n    // Convert data section length to big-endian 8-byte array\n    const dataSectionLenBytes = new Uint8Array(8);\n    const dataView = new DataView(dataSectionLenBytes.buffer);\n    dataView.setBigUint64(0, BigInt(dataSection.length), false); // false for big-endian\n\n    // Combine the instruction bytes, blob bytes, data section length, and the data section\n    const loaderBytecode = new Uint8Array([\n      ...instructionBytes,\n      ...blobBytes,\n      ...dataSectionLenBytes,\n    ]);\n\n    return {\n      loaderBytecode: concat([loaderBytecode, dataSection]),\n      blobOffset: loaderBytecode.length,\n    };\n  }\n  // Handle case where there is no data section\n  const numOfInstructions = getInstructionsNoDataSection(0).length;\n  if (numOfInstructions > 65535) {\n    throw new Error('Too many instructions, exceeding u16::MAX.');\n  }\n\n  // Convert instructions to bytes\n  const instructionBytes = new Uint8Array(\n    getInstructionsNoDataSection(numOfInstructions).flatMap((instruction) =>\n      Array.from(instruction.to_bytes())\n    )\n  );\n\n  // Convert blobId to bytes\n  const blobBytes = new Uint8Array(blobId);\n\n  // Combine the instruction bytes and blob bytes\n  const loaderBytecode = new Uint8Array([...instructionBytes, ...blobBytes]);\n\n  return { loaderBytecode };\n}\n","import { WORD_SIZE } from '@fuel-ts/abi-coder';\nimport { concat } from '@fuel-ts/utils';\n\nexport const getContractChunks = (bytecode: Uint8Array, chunkSize: number) => {\n  const chunks = [];\n\n  for (let offset = 0, index = 0; offset < bytecode.length; offset += chunkSize, index++) {\n    let chunk = bytecode.slice(offset, offset + chunkSize);\n    let length = chunk.length;\n\n    // Align chunks by word size\n    if (length % WORD_SIZE !== 0) {\n      chunk = concat([chunk, new Uint8Array(chunkSize - chunk.length)]);\n      length = chunk.length;\n    }\n\n    chunks.push({ id: index, size: length, bytecode: chunk });\n  }\n\n  return chunks;\n};\n","import { sha256 } from '@fuel-ts/hasher';\nimport type { BytesLike } from '@fuel-ts/interfaces';\nimport { calcRoot, SparseMerkleTree } from '@fuel-ts/merkle';\nimport type { StorageSlot } from '@fuel-ts/transactions';\nimport { chunkAndPadBytes, hexlify, concat, arrayify } from '@fuel-ts/utils';\n\n/**\n * @hidden\n *\n * Get the Merkle root of a contract's bytecode.\n *\n * @param bytecode - The bytecode of the contract.\n * @returns The Merkle root of the contract's bytecode.\n */\nexport const getContractRoot = (bytecode: BytesLike): string => {\n  const chunkSize = 16 * 1024;\n  const bytes = arrayify(bytecode);\n  const chunks = chunkAndPadBytes(bytes, chunkSize);\n\n  return calcRoot(chunks.map((c) => hexlify(c)));\n};\n\n/**\n * @hidden\n *\n * Get the Merkle root of a contract's storage slots.\n *\n * @param storageSlots - An array of storage slots containing key-value pairs.\n * @returns The Merkle root of the contract's storage slots.\n */\nexport const getContractStorageRoot = (storageSlots: StorageSlot[]): string => {\n  const tree = new SparseMerkleTree();\n\n  storageSlots.forEach(({ key, value }) => tree.update(sha256(key), value));\n\n  return tree.root;\n};\n\n/**\n * @hidden\n *\n * Get the contract ID of a contract based on its bytecode, salt,\n * and state root.\n *\n * @param bytecode - The bytecode of the contract.\n * @param salt - The salt value used for contract creation.\n * @param stateRoot - The state root of the contract.\n * @returns The contract ID of the contract.\n */\nexport const getContractId = (\n  bytecode: BytesLike,\n  salt: BytesLike,\n  stateRoot: BytesLike\n): string => {\n  const root = getContractRoot(arrayify(bytecode));\n  const contractId = sha256(concat(['0x4655454C', salt, root, stateRoot]));\n  return contractId;\n};\n\n/**\n * @hidden\n *\n * Ensures that a string is hexlified.\n *\n * @param value - The value to be hexlified.\n *\n * @returns The input value hexlified with prefix.\n */\nexport const hexlifyWithPrefix = (value: string) =>\n  hexlify(value.startsWith('0x') ? value : `0x${value}`);\n"],"mappings":"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","names":["WORD_SIZE","arrayify","hexlify","concat","asm","numOfInstructions","instructionBytes","blobBytes","loaderBytecode","WORD_SIZE","concat","concat","arrayify","arrayify","hexlify","WORD_SIZE"]}