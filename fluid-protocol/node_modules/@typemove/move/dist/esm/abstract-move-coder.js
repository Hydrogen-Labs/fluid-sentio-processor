import { accountAddressString, moduleQname, SPLITTER, VECTOR_STR } from './utils.js';
import { matchType, parseMoveType } from './types.js';
export class AbstractMoveCoder {
    moduleMapping = new Map();
    typeMapping = new Map();
    funcMapping = new Map();
    // network: string
    adapter;
    constructor(adapter) {
        this.adapter = adapter;
    }
    contains(account, name) {
        return this.moduleMapping.has(moduleQname({ address: account, name }));
    }
    loadInternal(module, address) {
        const account = accountAddressString(module.address);
        const declareAccount = accountAddressString(address);
        this._loadInternal(module, account);
        if (account !== declareAccount) {
            this._loadInternal(module, declareAccount);
        }
    }
    _loadInternal(module, account) {
        if (this.contains(account, module.name)) {
            return;
        }
        this.moduleMapping.set(moduleQname({ address: account, name: module.name }), module);
        for (const struct of module.structs) {
            // TODO move to util
            const key = [account, module.name, struct.name].join(SPLITTER);
            this.typeMapping.set(key, struct);
        }
        for (const func of module.exposedFunctions) {
            // if (!func.isEntry) {
            //   continue
            // }
            const key = [account, module.name, func.name].join(SPLITTER);
            this.funcMapping.set(key, func);
        }
    }
    decodeBigInt(data) {
        if (Array.isArray(data)) {
            throw new Error('data is in byte array');
            // Only sui function need this, strange
            // const bytes = data as number[]
            // return bytesToBigInt(new Uint8Array(bytes.slice().reverse()))
        }
        return BigInt(data);
    }
    requestMap = new Map();
    async getMoveStruct(type) {
        const [account_, module, typeName] = type.split(SPLITTER);
        const account = accountAddressString(account_);
        type = [account, module, typeName].join(SPLITTER);
        let struct = this.typeMapping.get(type);
        if (struct) {
            return struct;
        }
        let resp = this.requestMap.get(account);
        if (!resp) {
            resp = this.adapter.fetchModules(account).then((modules) => {
                for (const m of modules) {
                    this.load(m, account);
                }
            });
            this.requestMap.set(account, resp);
        }
        await resp;
        struct = this.typeMapping.get(type);
        if (struct) {
            return struct;
        }
        throw new Error('Failed to load function ' + type + ' type are not imported anywhere');
    }
    async getMoveFunction(type) {
        const [account_, module, typeName] = type.split(SPLITTER);
        const account = accountAddressString(account_);
        type = [account, module, typeName].join(SPLITTER);
        let func = this.funcMapping.get(type);
        if (func) {
            return func;
        }
        let resp = this.requestMap.get(account);
        if (!resp) {
            resp = this.adapter
                .fetchModules(account)
                .then((modules) => {
                for (const m of modules) {
                    this.load(m, account);
                }
            })
                .catch((e) => {
                this.requestMap.delete(account);
            });
            this.requestMap.set(account, resp);
        }
        await resp;
        func = this.funcMapping.get(type);
        if (func) {
            return func;
        }
        throw new Error('Failed to load function ' + type + ' type are not imported anywhere');
    }
    async decode(data, type) {
        // process simple type
        if (type.reference) {
            return data;
        }
        switch (type.qname) {
            case 'signer': // TODO check this, aptos only
            case 'address':
            case 'Address':
            case '0x1::string::String':
            case 'bool':
            case 'Bool':
            case 'u8':
            case 'U8':
            case 'u16':
            case 'U16':
            case 'u32':
            case 'U32':
                return data;
            case 'u64':
            case 'U64':
            case 'u128':
            case 'U128':
            case 'u256':
            case 'U256':
                return this.decodeBigInt(data);
        }
        // process vector
        if (type.qname.toLowerCase() === VECTOR_STR) {
            // vector<u8> as hex string
            if (type.typeArgs[0].qname === 'u8' || type.typeArgs[0].qname === 'U8') {
                return data;
            }
            const res = [];
            for (const entry of data) {
                res.push(await this.decode(entry, type.typeArgs[0]));
            }
            return res;
        }
        // Process complex type
        const struct = await this.getMoveStruct(type.qname);
        const typeCtx = new Map();
        for (const [idx, typeArg] of type.typeArgs.entries()) {
            typeCtx.set('T' + idx, typeArg);
        }
        const typedData = {};
        for (const field of struct.fields) {
            let filedType = field.type;
            filedType = filedType.applyTypeArgs(typeCtx);
            const fieldValue = this.adapter.getData(data)[field.name];
            const value = await this.decode(fieldValue, filedType);
            typedData[field.name] = value;
        }
        return typedData;
    }
    async decodeArray(entries, types, strict = true) {
        const entriesDecoded = [];
        for (const [idx, arg] of entries.entries()) {
            // TODO consider apply payload.type_arguments, but this might be hard since we don't code gen for them
            const argType = types[idx];
            try {
                if (!strict && arg === undefined) {
                    entriesDecoded.push(arg);
                }
                else {
                    entriesDecoded.push(await this.decode(arg, argType));
                }
            }
            catch (e) {
                throw Error('Decoding error for ' + JSON.stringify(arg) + 'using type' + argType + e.toString());
            }
        }
        return entriesDecoded;
    }
    encode(data) {
        if (!data) {
            return undefined;
        }
        if (typeof data === 'bigint') {
            return data.toString();
        }
        if (Array.isArray(data)) {
            return this.encodeArray(data);
        }
        for (const [key, value] of Object.entries(data)) {
            if (!value) {
                continue;
            }
            if (typeof value === 'bigint') {
                data[key] = value.toString();
            }
        }
        return data;
    }
    encodeArray(entriesDecoded) {
        const entries = [];
        for (const [idx, arg] of entriesDecoded.entries()) {
            entries.push(this.encode(arg));
        }
        return entries;
    }
    async decodeCallResult(res, func) {
        const f = await this.getMoveFunction(func);
        return this.decodeArray(res, f.return);
    }
    async filterAndDecodeStruct(typeMatcher, structsWithTags) {
        if (!structsWithTags) {
            return [];
        }
        // const typeMatcherDescriptor = parseMoveType(typeMatcher)
        const results = [];
        for (const resource of structsWithTags) {
            const resourceType = this.adapter.getType(resource);
            const resourceTypeDescriptor = parseMoveType(resourceType);
            if (!matchType(typeMatcher, resourceTypeDescriptor)) {
                continue;
            }
            const result = await this.decodedStruct(resource);
            if (result) {
                results.push(result);
            }
            else {
                console.error('decoding error');
            }
        }
        return results;
    }
    async decodedStruct(typeStruct) {
        const typeDescriptor = parseMoveType(this.adapter.getType(typeStruct));
        const typeArguments = typeDescriptor.typeArgs.map((t) => t.getSignature());
        let dataTyped = undefined;
        try {
            dataTyped = await this.decode(typeStruct, typeDescriptor);
        }
        catch (e) {
            throw Error('Decoding error for struct' + JSON.stringify(typeStruct) + e.toString());
            // return undefined
        }
        return {
            ...typeStruct,
            data_decoded: dataTyped,
            type_arguments: typeArguments
        };
    }
    async decodedType(typeStruct, type) {
        if (typeStruct === null || typeStruct == undefined) {
            return typeStruct;
        }
        if (typeof typeStruct === 'object') {
            if ('type' in typeStruct) {
                const typeInStruct = parseMoveType(typeStruct.type.toString() || '');
                if (!matchType(type, typeInStruct)) {
                    return undefined;
                }
            }
        }
        return await this.decode(typeStruct, type);
    }
}
//# sourceMappingURL=abstract-move-coder.js.map