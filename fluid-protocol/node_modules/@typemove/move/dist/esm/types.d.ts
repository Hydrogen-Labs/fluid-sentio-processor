export type DecodedStruct<B, T> = B & {
    /**
     * decoded data using ABI, undefined if there is decoding error, usually because the ABI/data mismatch
     */
    data_decoded: T;
    type_arguments: string[];
};
export declare class TypeDescriptor<T = any> {
    qname: string;
    reference: boolean;
    mutable: boolean;
    typeArgs: TypeDescriptor[];
    constructor(symbol: string, typeParams?: TypeDescriptor[]);
    apply(...typeArgs: TypeDescriptor[]): TypeDescriptor;
    clone(): this;
    compareQname(t: TypeDescriptor): boolean;
    getSignature(): string;
    getNormalizedSignature(): string;
    applyTypeArgs(ctx: Map<string, TypeDescriptor>): TypeDescriptor;
    dependedTypes(): string[];
    isVector(): boolean;
    existAnyType(): boolean;
    name(): string;
    module(): string;
}
export declare function parseMoveType(type: string): TypeDescriptor;
export declare const ANY_TYPE: TypeDescriptor<any>;
export declare function vectorType<T>(t?: TypeDescriptor<T>): TypeDescriptor<T[]>;
export declare const BUILTIN_TYPES: {
    ADDRESS_TYPE: TypeDescriptor<string>;
    VECTOR_TYPE_ANY: TypeDescriptor<any[]>;
    VECTOR_TYPE: typeof vectorType;
    BOOL_TYPE: TypeDescriptor<number>;
    U8_TYPE: TypeDescriptor<number>;
    U16_TYPE: TypeDescriptor<number>;
    U32_TYPE: TypeDescriptor<number>;
    U64_TYPE: TypeDescriptor<number>;
    U128_TYPE: TypeDescriptor<number>;
    U256_TYPE: TypeDescriptor<number>;
};
/**
 *
 * @param matcher
 * @param type
 */
export declare function matchType(matcher: TypeDescriptor, type: TypeDescriptor): boolean;
//# sourceMappingURL=types.d.ts.map