"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRegister = exports.AccountModulesImportInfo = void 0;
const utils_js_1 = require("./utils.js");
class AccountModulesImportInfo {
    // account to module
    imports;
    account;
    moduleName;
    constructor(account, tsModuleName) {
        this.account = account;
        this.moduleName = tsModuleName;
        this.imports = new Map();
    }
    addImport(account, module) {
        if (account === this.account) {
            return;
        }
        let accountModules = this.imports.get(account);
        if (!accountModules) {
            accountModules = new Set();
            this.imports.set(account, accountModules);
        }
        accountModules.add(module);
    }
}
exports.AccountModulesImportInfo = AccountModulesImportInfo;
class AccountRegister {
    accountImports = new Map();
    pendingAccounts = new Set();
    register(module, tsModuleName) {
        const currentModuleFqn = (0, utils_js_1.moduleQname)(module);
        let accountModuleImports = this.accountImports.get(module.address);
        if (!accountModuleImports) {
            accountModuleImports = new AccountModulesImportInfo(module.address, tsModuleName);
            this.accountImports.set(module.address, accountModuleImports);
            // the account has already be processed, delete pending task
            this.pendingAccounts.delete(module.address);
        }
        this.registerStruct(module, accountModuleImports);
        this.registerFunctions(module, accountModuleImports);
        this.accountImports.set(currentModuleFqn, accountModuleImports);
        return accountModuleImports;
    }
    registerFunctions(module, accountModuleImports) {
        for (const func of module.exposedFunctions) {
            if (!func.isEntry) {
                continue;
            }
            for (const param of func.params) {
                for (const type of param.dependedTypes()) {
                    const [account, module] = (0, utils_js_1.moduleQnameForType)(type);
                    accountModuleImports.addImport(account, module);
                    if (!this.accountImports.has(account)) {
                        this.pendingAccounts.add(account);
                    }
                }
            }
        }
    }
    registerStruct(module, accountModuleImports) {
        for (const struct of module.structs) {
            for (const field of struct.fields) {
                for (const type of field.type.dependedTypes()) {
                    const [account, module] = (0, utils_js_1.moduleQnameForType)(type);
                    accountModuleImports.addImport(account, module);
                    if (!this.accountImports.has(account)) {
                        this.pendingAccounts.add(account);
                    }
                }
            }
        }
    }
}
exports.AccountRegister = AccountRegister;
//# sourceMappingURL=account.js.map