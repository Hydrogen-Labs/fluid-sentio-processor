"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.camel = exports.upperFirst = exports.structQname = exports.moduleQname = exports.moduleQnameForType = exports.normalizeToJSName = exports.accountAddressString = exports.isValidMoveAddress = exports.accountTypeString = exports.isFrameworkAccount = exports.VECTOR_STR = exports.SPLITTER = void 0;
const radash_1 = require("radash");
exports.SPLITTER = '::';
exports.VECTOR_STR = 'vector';
function isFrameworkAccount(account) {
    const n = parseInt(account, 16);
    if (Number.isNaN(n)) {
        return false;
    }
    return n >= 0 && n < 16;
}
exports.isFrameworkAccount = isFrameworkAccount;
// strip any lead 0
function accountTypeString(account) {
    const withoutPrefix = account.toLowerCase().replace(/^(0x)/, '');
    return '0x' + withoutPrefix.replace(/^0*/, '');
}
exports.accountTypeString = accountTypeString;
const MOVE_ADDRESS_LENGTH = 32;
function isHex(value) {
    return /^(0x|0X)?[a-fA-F0-9]+$/.test(value);
}
function getHexByteLength(value) {
    return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}
function isValidMoveAddress(value) {
    return isHex(value) && getHexByteLength(value) <= MOVE_ADDRESS_LENGTH;
}
exports.isValidMoveAddress = isValidMoveAddress;
// Get full address with 32 bytes
function accountAddressString(account) {
    if (!isValidMoveAddress(account)) {
        throw Error('Not valid move address');
    }
    const address = account.toLowerCase().replace(/^(0x)/, '');
    return `0x${address.padStart(MOVE_ADDRESS_LENGTH * 2, '0')}`;
}
exports.accountAddressString = accountAddressString;
const KEYWORDS = new Set([
    'default',
    'package',
    'namespace',
    'volatile',
    'object',
    'string',
    'number',
    'bigint',
    'any',
    'new',
    'delete'
]);
function normalizeToJSName(name) {
    if (KEYWORDS.has(name)) {
        return name + '_';
    }
    return name;
}
exports.normalizeToJSName = normalizeToJSName;
function moduleQnameForType(type) {
    const parts = type.split(exports.SPLITTER).slice(0, 2);
    return [parts[0], parts[1]];
}
exports.moduleQnameForType = moduleQnameForType;
function moduleQname(module) {
    return accountTypeString(module.address) + exports.SPLITTER + module.name;
}
exports.moduleQname = moduleQname;
function structQname(module, struct) {
    return [accountTypeString(module.address), module.name, struct.name].join(exports.SPLITTER);
}
exports.structQname = structQname;
function upperFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
exports.upperFirst = upperFirst;
function camel(str) {
    const base = (0, radash_1.camel)(str);
    return str.endsWith('_') ? base + '_' : base;
}
exports.camel = camel;
//# sourceMappingURL=utils.js.map