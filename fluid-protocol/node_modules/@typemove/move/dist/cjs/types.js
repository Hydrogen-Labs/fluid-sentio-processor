"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchType = exports.BUILTIN_TYPES = exports.vectorType = exports.ANY_TYPE = exports.parseMoveType = exports.TypeDescriptor = void 0;
const utils_js_1 = require("./utils.js");
class TypeDescriptor {
    qname;
    reference;
    mutable;
    typeArgs;
    constructor(symbol, typeParams) {
        this.qname = symbol;
        this.reference = false;
        this.mutable = false;
        this.typeArgs = typeParams || [];
    }
    apply(...typeArgs) {
        const newObj = this.clone();
        newObj.typeArgs = typeArgs;
        return newObj;
    }
    clone() {
        const newObj = new TypeDescriptor(this.qname, this.typeArgs);
        newObj.reference = this.reference;
        newObj.mutable = this.mutable;
        return newObj;
    }
    // compare qname without consider case for system type
    compareQname(t) {
        let t1 = this.qname;
        if (BUILTIN_TYPES_SET.has(this.qname.toLowerCase())) {
            t1 = this.qname.toLowerCase();
        }
        let t2 = t.qname;
        if (BUILTIN_TYPES_SET.has(t.qname.toLowerCase())) {
            t2 = t.qname;
        }
        return t1 === t2;
    }
    getSignature() {
        if (this.typeArgs.length > 0) {
            return this.qname + '<' + this.typeArgs.map((t) => t.getSignature()).join(', ') + '>';
        }
        return this.qname;
    }
    // Make U8, U16, etc => u8, u16
    getNormalizedSignature() {
        let qname = this.qname;
        switch (qname) {
            case 'U8':
            case 'U16':
            case 'U32':
            case 'U64':
            case 'U128':
            case 'U256':
            case 'Vector':
            case 'Bool':
            case 'Address':
                qname = qname.toLowerCase();
        }
        if (this.typeArgs.length > 0) {
            return qname + '<' + this.typeArgs.map((t) => t.getNormalizedSignature()).join(', ') + '>';
        }
        return qname;
    }
    // Replace T0, T1 with more concrete type
    applyTypeArgs(ctx) {
        const replace = ctx.get(this.qname);
        if (replace) {
            return replace;
        }
        if (ctx.size === 0 || this.typeArgs.length === 0) {
            return this;
        }
        const typeArgs = [];
        for (const arg of this.typeArgs) {
            const replace = ctx.get(arg.qname);
            if (replace) {
                typeArgs.push(replace);
            }
            else {
                typeArgs.push(arg.applyTypeArgs(ctx));
            }
        }
        return new TypeDescriptor(this.qname, typeArgs);
    }
    // all depended types including itself, not include system type
    dependedTypes() {
        if (this.qname.startsWith('&')) {
            console.error('Not expected &');
            return [];
        }
        if (this.isVector()) {
            return this.typeArgs[0].dependedTypes();
        }
        if (BUILTIN_TYPES_SET.has(this.qname.toLowerCase())) {
            return [];
        }
        switch (this.qname) {
            case 'signer':
            case '0x1::string::String':
                return [];
        }
        // Type parameters are not depended
        if (this.qname.indexOf(utils_js_1.SPLITTER) == -1) {
            if (this.qname.startsWith('T')) {
                return [];
            }
        }
        const types = new Set();
        for (const param of this.typeArgs) {
            param.dependedTypes().forEach((t) => types.add(t));
        }
        types.add(this.qname);
        return Array.from(types);
    }
    isVector() {
        return this.qname.toLowerCase() === utils_js_1.VECTOR_STR;
    }
    existAnyType() {
        if (this.qname === 'any') {
            return true;
        }
        for (const param of this.typeArgs) {
            if (param.existAnyType()) {
                return true;
            }
        }
        return false;
    }
    name() {
        const parts = this.qname.split(utils_js_1.SPLITTER);
        return parts[parts.length - 1];
    }
    module() {
        const parts = this.qname.split(utils_js_1.SPLITTER);
        return parts[parts.length - 2];
    }
}
exports.TypeDescriptor = TypeDescriptor;
function parseMoveType(type) {
    const stack = [new TypeDescriptor('')];
    let buffer = [];
    if (type === undefined) {
        console.log('');
    }
    // xxx:asdf<g1<a,<c,d>>, b, g2<a,b>, e>
    for (let i = 0; i < type.length; i++) {
        const ch = type[i];
        if (ch === ' ') {
            continue;
        }
        if (ch === '<') {
            // const symbol = type.slice(symbolStart, i)
            // symbolStart =
            const symbol = buffer.join('');
            buffer = [];
            stack[stack.length - 1].qname = symbol;
            adjustType(stack[stack.length - 1]);
            stack.push(new TypeDescriptor(''));
            continue;
        }
        if (ch === '>' || ch === ',') {
            const typeParam = stack.pop();
            if (!typeParam) {
                throw Error('Unexpected stack size');
            }
            if (buffer.length > 0) {
                typeParam.qname = buffer.join('');
                buffer = [];
            }
            adjustType(typeParam);
            stack[stack.length - 1].typeArgs.push(typeParam);
            if (ch === ',') {
                stack.push(new TypeDescriptor(''));
            }
            continue;
        }
        buffer.push(ch);
    }
    if (buffer.length > 0) {
        stack[stack.length - 1].qname = buffer.join('');
    }
    adjustType(stack[stack.length - 1]);
    const res = stack.pop();
    if (!res || stack.length > 0) {
        throw Error('Unexpected stack size');
    }
    return res;
}
exports.parseMoveType = parseMoveType;
function adjustType(type) {
    if (type.qname.startsWith('&')) {
        type.reference = true;
        type.qname = type.qname.slice(1);
    }
    if (type.qname.startsWith('mut')) {
        type.mutable = true;
        type.qname = type.qname.slice(3);
    }
    const parts = type.qname.split(utils_js_1.SPLITTER);
    if (parts.length > 1) {
        const [account, module, name] = parts;
        type.qname = [(0, utils_js_1.accountTypeString)(account), module, name].join(utils_js_1.SPLITTER);
    }
}
exports.ANY_TYPE = new TypeDescriptor('any');
function vectorType(t = exports.ANY_TYPE) {
    return exports.BUILTIN_TYPES.VECTOR_TYPE_ANY.apply(t);
}
exports.vectorType = vectorType;
exports.BUILTIN_TYPES = {
    ADDRESS_TYPE: new TypeDescriptor('address'),
    // export const Address = new TypeDescriptor<string>("Address")
    VECTOR_TYPE_ANY: new TypeDescriptor('vector'),
    VECTOR_TYPE: vectorType,
    BOOL_TYPE: new TypeDescriptor('bool'),
    U8_TYPE: new TypeDescriptor('u8'),
    // export const U8 = new TypeDescriptor<number>("U8")
    U16_TYPE: new TypeDescriptor('u16'),
    // export const U16 = new TypeDescriptor<number>("U16")
    U32_TYPE: new TypeDescriptor('u32'),
    // export const U32 = new TypeDescriptor<number>("U32")
    U64_TYPE: new TypeDescriptor('u64'),
    // export const U64 = new TypeDescriptor<number>("U64")
    U128_TYPE: new TypeDescriptor('u128'),
    // export const U128 = new TypeDescriptor<number>("U128")
    U256_TYPE: new TypeDescriptor('u256')
    // export const U256 = new TypeDescriptor<number>("U256")
};
const BUILTIN_TYPES_SET = new Set(Object.values(exports.BUILTIN_TYPES).flatMap((t) => {
    if (typeof t === 'object') {
        return [t.qname.toLowerCase()];
    }
    return [];
}));
/**
 *
 * @param matcher
 * @param type
 */
function matchType(matcher, type) {
    if (matcher.qname === 'any') {
        return true;
    }
    if (!matcher.compareQname(type)) {
        return false;
    }
    for (const [idx, matcherTarg] of matcher.typeArgs.entries()) {
        const targ = type.typeArgs[idx];
        if (!matchType(matcherTarg, targ)) {
            return false;
        }
    }
    return true;
}
exports.matchType = matchType;
//# sourceMappingURL=types.js.map