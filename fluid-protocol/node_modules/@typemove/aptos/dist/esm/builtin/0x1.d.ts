import { TypeDescriptor } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/aptos";
import { Aptos, Account as AptosAccount, MoveAddressType, PendingTransactionResponse, InputGenerateTransactionOptions, MoveStructId } from "@aptos-labs/ts-sdk";
export declare namespace acl {
    interface ACL {
        list: MoveAddressType[];
    }
    namespace ACL {
        const TYPE_QNAME = "0x1::acl::ACL";
        function type(): TypeDescriptor<ACL>;
    }
    interface ACLInstance extends TypedEventInstance<ACL> {
        data_decoded: ACL;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace any_ {
    interface Any {
        type_name: string;
        data: string;
    }
    namespace Any {
        const TYPE_QNAME = "0x1::any::Any";
        function type(): TypeDescriptor<Any>;
    }
    interface AnyInstance extends TypedEventInstance<Any> {
        data_decoded: Any;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace bcs {
    namespace entry { }
    namespace view { }
}
export declare namespace dkg {
    interface DKGSessionMetadata {
        dealer_epoch: bigint;
        randomness_config: randomness_config.RandomnessConfig;
        dealer_validator_set: validator_consensus_info.ValidatorConsensusInfo[];
        target_validator_set: validator_consensus_info.ValidatorConsensusInfo[];
    }
    namespace DKGSessionMetadata {
        const TYPE_QNAME = "0x1::dkg::DKGSessionMetadata";
        function type(): TypeDescriptor<DKGSessionMetadata>;
    }
    interface DKGSessionMetadataInstance extends TypedEventInstance<DKGSessionMetadata> {
        data_decoded: DKGSessionMetadata;
        type_arguments: [];
    }
    interface DKGSessionState {
        metadata: dkg.DKGSessionMetadata;
        start_time_us: bigint;
        transcript: string;
    }
    namespace DKGSessionState {
        const TYPE_QNAME = "0x1::dkg::DKGSessionState";
        function type(): TypeDescriptor<DKGSessionState>;
    }
    interface DKGSessionStateInstance extends TypedEventInstance<DKGSessionState> {
        data_decoded: DKGSessionState;
        type_arguments: [];
    }
    interface DKGStartEvent {
        session_metadata: dkg.DKGSessionMetadata;
        start_time_us: bigint;
    }
    namespace DKGStartEvent {
        const TYPE_QNAME = "0x1::dkg::DKGStartEvent";
        function type(): TypeDescriptor<DKGStartEvent>;
    }
    interface DKGStartEventInstance extends TypedEventInstance<DKGStartEvent> {
        data_decoded: DKGStartEvent;
        type_arguments: [];
    }
    interface DKGState {
        last_completed: option.Option<dkg.DKGSessionState>;
        in_progress: option.Option<dkg.DKGSessionState>;
    }
    namespace DKGState {
        const TYPE_QNAME = "0x1::dkg::DKGState";
        function type(): TypeDescriptor<DKGState>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace code {
    interface AllowedDep {
        account: MoveAddressType;
        module_name: string;
    }
    namespace AllowedDep {
        const TYPE_QNAME = "0x1::code::AllowedDep";
        function type(): TypeDescriptor<AllowedDep>;
    }
    interface ModuleMetadata {
        name: string;
        source: string;
        source_map: string;
        extension: option.Option<copyable_any.Any>;
    }
    namespace ModuleMetadata {
        const TYPE_QNAME = "0x1::code::ModuleMetadata";
        function type(): TypeDescriptor<ModuleMetadata>;
    }
    interface ModuleMetadataInstance extends TypedEventInstance<ModuleMetadata> {
        data_decoded: ModuleMetadata;
        type_arguments: [];
    }
    interface PackageDep {
        account: MoveAddressType;
        package_name: string;
    }
    namespace PackageDep {
        const TYPE_QNAME = "0x1::code::PackageDep";
        function type(): TypeDescriptor<PackageDep>;
    }
    interface PackageDepInstance extends TypedEventInstance<PackageDep> {
        data_decoded: PackageDep;
        type_arguments: [];
    }
    interface PackageMetadata {
        name: string;
        upgrade_policy: code.UpgradePolicy;
        upgrade_number: bigint;
        source_digest: string;
        manifest: string;
        modules: code.ModuleMetadata[];
        deps: code.PackageDep[];
        extension: option.Option<copyable_any.Any>;
    }
    namespace PackageMetadata {
        const TYPE_QNAME = "0x1::code::PackageMetadata";
        function type(): TypeDescriptor<PackageMetadata>;
    }
    interface PackageMetadataInstance extends TypedEventInstance<PackageMetadata> {
        data_decoded: PackageMetadata;
        type_arguments: [];
    }
    interface PackageRegistry {
        packages: code.PackageMetadata[];
    }
    namespace PackageRegistry {
        const TYPE_QNAME = "0x1::code::PackageRegistry";
        function type(): TypeDescriptor<PackageRegistry>;
    }
    interface PackageRegistryInstance extends TypedEventInstance<PackageRegistry> {
        data_decoded: PackageRegistry;
        type_arguments: [];
    }
    interface PublishPackage {
        code_address: MoveAddressType;
        is_upgrade: Boolean;
    }
    namespace PublishPackage {
        const TYPE_QNAME = "0x1::code::PublishPackage";
        function type(): TypeDescriptor<PublishPackage>;
    }
    interface PublishPackageInstance extends TypedEventInstance<PublishPackage> {
        data_decoded: PublishPackage;
        type_arguments: [];
    }
    interface UpgradePolicy {
        policy: number;
    }
    namespace UpgradePolicy {
        const TYPE_QNAME = "0x1::code::UpgradePolicy";
        function type(): TypeDescriptor<UpgradePolicy>;
    }
    interface UpgradePolicyInstance extends TypedEventInstance<UpgradePolicy> {
        data_decoded: UpgradePolicy;
        type_arguments: [];
    }
    namespace entry {
        function publishPackageTxn(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace coin {
    interface AggregatableCoin<T0> {
        value: aggregator.Aggregator;
    }
    namespace AggregatableCoin {
        const TYPE_QNAME = "0x1::coin::AggregatableCoin";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<AggregatableCoin<T0>>;
    }
    interface BurnCapability<T0> {
        dummy_field: Boolean;
    }
    namespace BurnCapability {
        const TYPE_QNAME = "0x1::coin::BurnCapability";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<BurnCapability<T0>>;
    }
    interface BurnRefReceipt {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace BurnRefReceipt {
        const TYPE_QNAME = "0x1::coin::BurnRefReceipt";
        function type(): TypeDescriptor<BurnRefReceipt>;
    }
    interface Coin<T0> {
        value: bigint;
    }
    namespace Coin {
        const TYPE_QNAME = "0x1::coin::Coin";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Coin<T0>>;
    }
    interface CoinConversionMap {
        coin_to_fungible_asset_map: table.Table<type_info.TypeInfo, object_.Object<fungible_asset.Metadata>>;
    }
    namespace CoinConversionMap {
        const TYPE_QNAME = "0x1::coin::CoinConversionMap";
        function type(): TypeDescriptor<CoinConversionMap>;
    }
    interface CoinDeposit {
        coin_type: string;
        account: MoveAddressType;
        amount: bigint;
    }
    namespace CoinDeposit {
        const TYPE_QNAME = "0x1::coin::CoinDeposit";
        function type(): TypeDescriptor<CoinDeposit>;
    }
    interface CoinDepositInstance extends TypedEventInstance<CoinDeposit> {
        data_decoded: CoinDeposit;
        type_arguments: [];
    }
    interface CoinEventHandleDeletion {
        event_handle_creation_address: MoveAddressType;
        deleted_deposit_event_handle_creation_number: bigint;
        deleted_withdraw_event_handle_creation_number: bigint;
    }
    namespace CoinEventHandleDeletion {
        const TYPE_QNAME = "0x1::coin::CoinEventHandleDeletion";
        function type(): TypeDescriptor<CoinEventHandleDeletion>;
    }
    interface CoinEventHandleDeletionInstance extends TypedEventInstance<CoinEventHandleDeletion> {
        data_decoded: CoinEventHandleDeletion;
        type_arguments: [];
    }
    interface CoinInfo<T0> {
        name: string;
        symbol: string;
        decimals: number;
        supply: option.Option<optional_aggregator.OptionalAggregator>;
    }
    namespace CoinInfo {
        const TYPE_QNAME = "0x1::coin::CoinInfo";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinInfo<T0>>;
    }
    interface CoinStore<T0> {
        coin: coin.Coin<T0>;
        frozen: Boolean;
        deposit_events: event.EventHandle<coin.DepositEvent>;
        withdraw_events: event.EventHandle<coin.WithdrawEvent>;
    }
    namespace CoinStore {
        const TYPE_QNAME = "0x1::coin::CoinStore";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinStore<T0>>;
    }
    interface CoinWithdraw {
        coin_type: string;
        account: MoveAddressType;
        amount: bigint;
    }
    namespace CoinWithdraw {
        const TYPE_QNAME = "0x1::coin::CoinWithdraw";
        function type(): TypeDescriptor<CoinWithdraw>;
    }
    interface CoinWithdrawInstance extends TypedEventInstance<CoinWithdraw> {
        data_decoded: CoinWithdraw;
        type_arguments: [];
    }
    interface Deposit<T0> {
        account: MoveAddressType;
        amount: bigint;
    }
    namespace Deposit {
        const TYPE_QNAME = "0x1::coin::Deposit";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Deposit<T0>>;
    }
    interface DepositInstance extends TypedEventInstance<Deposit<any>> {
        data_decoded: Deposit<any>;
        type_arguments: [string];
    }
    interface DepositEvent {
        amount: bigint;
    }
    namespace DepositEvent {
        const TYPE_QNAME = "0x1::coin::DepositEvent";
        function type(): TypeDescriptor<DepositEvent>;
    }
    interface DepositEventInstance extends TypedEventInstance<DepositEvent> {
        data_decoded: DepositEvent;
        type_arguments: [];
    }
    interface FreezeCapability<T0> {
        dummy_field: Boolean;
    }
    namespace FreezeCapability {
        const TYPE_QNAME = "0x1::coin::FreezeCapability";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<FreezeCapability<T0>>;
    }
    interface MigrationFlag {
        dummy_field: Boolean;
    }
    namespace MigrationFlag {
        const TYPE_QNAME = "0x1::coin::MigrationFlag";
        function type(): TypeDescriptor<MigrationFlag>;
    }
    interface MintCapability<T0> {
        dummy_field: Boolean;
    }
    namespace MintCapability {
        const TYPE_QNAME = "0x1::coin::MintCapability";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<MintCapability<T0>>;
    }
    interface MintRefReceipt {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace MintRefReceipt {
        const TYPE_QNAME = "0x1::coin::MintRefReceipt";
        function type(): TypeDescriptor<MintRefReceipt>;
    }
    interface PairCreation {
        coin_type: type_info.TypeInfo;
        fungible_asset_metadata_address: MoveAddressType;
    }
    namespace PairCreation {
        const TYPE_QNAME = "0x1::coin::PairCreation";
        function type(): TypeDescriptor<PairCreation>;
    }
    interface PairCreationInstance extends TypedEventInstance<PairCreation> {
        data_decoded: PairCreation;
        type_arguments: [];
    }
    interface PairedCoinType {
        type: type_info.TypeInfo;
    }
    namespace PairedCoinType {
        const TYPE_QNAME = "0x1::coin::PairedCoinType";
        function type(): TypeDescriptor<PairedCoinType>;
    }
    interface PairedFungibleAssetRefs {
        mint_ref_opt: option.Option<fungible_asset.MintRef>;
        transfer_ref_opt: option.Option<fungible_asset.TransferRef>;
        burn_ref_opt: option.Option<fungible_asset.BurnRef>;
    }
    namespace PairedFungibleAssetRefs {
        const TYPE_QNAME = "0x1::coin::PairedFungibleAssetRefs";
        function type(): TypeDescriptor<PairedFungibleAssetRefs>;
    }
    interface SupplyConfig {
        allow_upgrades: Boolean;
    }
    namespace SupplyConfig {
        const TYPE_QNAME = "0x1::coin::SupplyConfig";
        function type(): TypeDescriptor<SupplyConfig>;
    }
    interface TransferRefReceipt {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace TransferRefReceipt {
        const TYPE_QNAME = "0x1::coin::TransferRefReceipt";
        function type(): TypeDescriptor<TransferRefReceipt>;
    }
    interface Withdraw<T0> {
        account: MoveAddressType;
        amount: bigint;
    }
    namespace Withdraw {
        const TYPE_QNAME = "0x1::coin::Withdraw";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Withdraw<T0>>;
    }
    interface WithdrawInstance extends TypedEventInstance<Withdraw<any>> {
        data_decoded: Withdraw<any>;
        type_arguments: [string];
    }
    interface WithdrawEvent {
        amount: bigint;
    }
    namespace WithdrawEvent {
        const TYPE_QNAME = "0x1::coin::WithdrawEvent";
        function type(): TypeDescriptor<WithdrawEvent>;
    }
    interface WithdrawEventInstance extends TypedEventInstance<WithdrawEvent> {
        data_decoded: WithdrawEvent;
        type_arguments: [];
    }
    namespace entry {
        function createCoinConversionMap(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createPairing<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function freezeCoinStore<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function migrateToFungibleStore<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unfreezeCoinStore<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function upgradeSupply<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function balance<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function coinSupply<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function decimals<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[number]>;
        function isAccountRegistered<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function isBalanceAtLeast<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[Boolean]>;
        function isCoinInitialized<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[Boolean]>;
        function isCoinStoreFrozen<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function name<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[string]>;
        function pairedBurnRefExists<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[Boolean]>;
        function pairedCoin(client: Aptos, request: {
            functionArguments: [object_.Object<fungible_asset.Metadata>];
        }, version?: bigint): Promise<[option.Option<type_info.TypeInfo>]>;
        function pairedMetadata<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[option.Option<object_.Object<fungible_asset.Metadata>>]>;
        function pairedMintRefExists<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[Boolean]>;
        function pairedTransferRefExists<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[Boolean]>;
        function supply<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function symbol<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
        }, version?: bigint): Promise<[string]>;
    }
}
export declare namespace guid {
    interface GUID {
        id: guid.ID;
    }
    namespace GUID {
        const TYPE_QNAME = "0x1::guid::GUID";
        function type(): TypeDescriptor<GUID>;
    }
    interface GUIDInstance extends TypedEventInstance<GUID> {
        data_decoded: GUID;
        type_arguments: [];
    }
    interface ID {
        creation_num: bigint;
        addr: MoveAddressType;
    }
    namespace ID {
        const TYPE_QNAME = "0x1::guid::ID";
        function type(): TypeDescriptor<ID>;
    }
    interface IDInstance extends TypedEventInstance<ID> {
        data_decoded: ID;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace hash {
    namespace entry { }
    namespace view { }
}
export declare namespace jwks {
    interface AllProvidersJWKs {
        entries: jwks.ProviderJWKs[];
    }
    namespace AllProvidersJWKs {
        const TYPE_QNAME = "0x1::jwks::AllProvidersJWKs";
        function type(): TypeDescriptor<AllProvidersJWKs>;
    }
    interface AllProvidersJWKsInstance extends TypedEventInstance<AllProvidersJWKs> {
        data_decoded: AllProvidersJWKs;
        type_arguments: [];
    }
    interface JWK {
        variant: copyable_any.Any;
    }
    namespace JWK {
        const TYPE_QNAME = "0x1::jwks::JWK";
        function type(): TypeDescriptor<JWK>;
    }
    interface JWKInstance extends TypedEventInstance<JWK> {
        data_decoded: JWK;
        type_arguments: [];
    }
    interface OIDCProvider {
        name: string;
        config_url: string;
    }
    namespace OIDCProvider {
        const TYPE_QNAME = "0x1::jwks::OIDCProvider";
        function type(): TypeDescriptor<OIDCProvider>;
    }
    interface OIDCProviderInstance extends TypedEventInstance<OIDCProvider> {
        data_decoded: OIDCProvider;
        type_arguments: [];
    }
    interface ObservedJWKs {
        jwks: jwks.AllProvidersJWKs;
    }
    namespace ObservedJWKs {
        const TYPE_QNAME = "0x1::jwks::ObservedJWKs";
        function type(): TypeDescriptor<ObservedJWKs>;
    }
    interface ObservedJWKsInstance extends TypedEventInstance<ObservedJWKs> {
        data_decoded: ObservedJWKs;
        type_arguments: [];
    }
    interface ObservedJWKsUpdated {
        epoch: bigint;
        jwks: jwks.AllProvidersJWKs;
    }
    namespace ObservedJWKsUpdated {
        const TYPE_QNAME = "0x1::jwks::ObservedJWKsUpdated";
        function type(): TypeDescriptor<ObservedJWKsUpdated>;
    }
    interface ObservedJWKsUpdatedInstance extends TypedEventInstance<ObservedJWKsUpdated> {
        data_decoded: ObservedJWKsUpdated;
        type_arguments: [];
    }
    interface Patch {
        variant: copyable_any.Any;
    }
    namespace Patch {
        const TYPE_QNAME = "0x1::jwks::Patch";
        function type(): TypeDescriptor<Patch>;
    }
    interface PatchInstance extends TypedEventInstance<Patch> {
        data_decoded: Patch;
        type_arguments: [];
    }
    interface PatchRemoveAll {
        dummy_field: Boolean;
    }
    namespace PatchRemoveAll {
        const TYPE_QNAME = "0x1::jwks::PatchRemoveAll";
        function type(): TypeDescriptor<PatchRemoveAll>;
    }
    interface PatchRemoveAllInstance extends TypedEventInstance<PatchRemoveAll> {
        data_decoded: PatchRemoveAll;
        type_arguments: [];
    }
    interface PatchRemoveIssuer {
        issuer: string;
    }
    namespace PatchRemoveIssuer {
        const TYPE_QNAME = "0x1::jwks::PatchRemoveIssuer";
        function type(): TypeDescriptor<PatchRemoveIssuer>;
    }
    interface PatchRemoveIssuerInstance extends TypedEventInstance<PatchRemoveIssuer> {
        data_decoded: PatchRemoveIssuer;
        type_arguments: [];
    }
    interface PatchRemoveJWK {
        issuer: string;
        jwk_id: string;
    }
    namespace PatchRemoveJWK {
        const TYPE_QNAME = "0x1::jwks::PatchRemoveJWK";
        function type(): TypeDescriptor<PatchRemoveJWK>;
    }
    interface PatchRemoveJWKInstance extends TypedEventInstance<PatchRemoveJWK> {
        data_decoded: PatchRemoveJWK;
        type_arguments: [];
    }
    interface PatchUpsertJWK {
        issuer: string;
        jwk: jwks.JWK;
    }
    namespace PatchUpsertJWK {
        const TYPE_QNAME = "0x1::jwks::PatchUpsertJWK";
        function type(): TypeDescriptor<PatchUpsertJWK>;
    }
    interface PatchUpsertJWKInstance extends TypedEventInstance<PatchUpsertJWK> {
        data_decoded: PatchUpsertJWK;
        type_arguments: [];
    }
    interface PatchedJWKs {
        jwks: jwks.AllProvidersJWKs;
    }
    namespace PatchedJWKs {
        const TYPE_QNAME = "0x1::jwks::PatchedJWKs";
        function type(): TypeDescriptor<PatchedJWKs>;
    }
    interface Patches {
        patches: jwks.Patch[];
    }
    namespace Patches {
        const TYPE_QNAME = "0x1::jwks::Patches";
        function type(): TypeDescriptor<Patches>;
    }
    interface ProviderJWKs {
        issuer: string;
        version: bigint;
        jwks: jwks.JWK[];
    }
    namespace ProviderJWKs {
        const TYPE_QNAME = "0x1::jwks::ProviderJWKs";
        function type(): TypeDescriptor<ProviderJWKs>;
    }
    interface ProviderJWKsInstance extends TypedEventInstance<ProviderJWKs> {
        data_decoded: ProviderJWKs;
        type_arguments: [];
    }
    interface RSA_JWK {
        kid: string;
        kty: string;
        alg: string;
        e: string;
        n: string;
    }
    namespace RSA_JWK {
        const TYPE_QNAME = "0x1::jwks::RSA_JWK";
        function type(): TypeDescriptor<RSA_JWK>;
    }
    interface RSA_JWKInstance extends TypedEventInstance<RSA_JWK> {
        data_decoded: RSA_JWK;
        type_arguments: [];
    }
    interface SupportedOIDCProviders {
        providers: jwks.OIDCProvider[];
    }
    namespace SupportedOIDCProviders {
        const TYPE_QNAME = "0x1::jwks::SupportedOIDCProviders";
        function type(): TypeDescriptor<SupportedOIDCProviders>;
    }
    interface SupportedOIDCProvidersInstance extends TypedEventInstance<SupportedOIDCProviders> {
        data_decoded: SupportedOIDCProviders;
        type_arguments: [];
    }
    interface UnsupportedJWK {
        id: string;
        payload: string;
    }
    namespace UnsupportedJWK {
        const TYPE_QNAME = "0x1::jwks::UnsupportedJWK";
        function type(): TypeDescriptor<UnsupportedJWK>;
    }
    interface UnsupportedJWKInstance extends TypedEventInstance<UnsupportedJWK> {
        data_decoded: UnsupportedJWK;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace util {
    namespace entry { }
    namespace view { }
}
export declare namespace block {
    interface BlockResource {
        height: bigint;
        epoch_interval: bigint;
        new_block_events: event.EventHandle<block.NewBlockEvent>;
        update_epoch_interval_events: event.EventHandle<block.UpdateEpochIntervalEvent>;
    }
    namespace BlockResource {
        const TYPE_QNAME = "0x1::block::BlockResource";
        function type(): TypeDescriptor<BlockResource>;
    }
    interface CommitHistory {
        max_capacity: number;
        next_idx: number;
        table: table_with_length.TableWithLength<number, block.NewBlockEvent>;
    }
    namespace CommitHistory {
        const TYPE_QNAME = "0x1::block::CommitHistory";
        function type(): TypeDescriptor<CommitHistory>;
    }
    interface NewBlock {
        hash: MoveAddressType;
        epoch: bigint;
        round: bigint;
        height: bigint;
        previous_block_votes_bitvec: string;
        proposer: MoveAddressType;
        failed_proposer_indices: bigint[];
        time_microseconds: bigint;
    }
    namespace NewBlock {
        const TYPE_QNAME = "0x1::block::NewBlock";
        function type(): TypeDescriptor<NewBlock>;
    }
    interface NewBlockInstance extends TypedEventInstance<NewBlock> {
        data_decoded: NewBlock;
        type_arguments: [];
    }
    interface NewBlockEvent {
        hash: MoveAddressType;
        epoch: bigint;
        round: bigint;
        height: bigint;
        previous_block_votes_bitvec: string;
        proposer: MoveAddressType;
        failed_proposer_indices: bigint[];
        time_microseconds: bigint;
    }
    namespace NewBlockEvent {
        const TYPE_QNAME = "0x1::block::NewBlockEvent";
        function type(): TypeDescriptor<NewBlockEvent>;
    }
    interface NewBlockEventInstance extends TypedEventInstance<NewBlockEvent> {
        data_decoded: NewBlockEvent;
        type_arguments: [];
    }
    interface UpdateEpochInterval {
        old_epoch_interval: bigint;
        new_epoch_interval: bigint;
    }
    namespace UpdateEpochInterval {
        const TYPE_QNAME = "0x1::block::UpdateEpochInterval";
        function type(): TypeDescriptor<UpdateEpochInterval>;
    }
    interface UpdateEpochIntervalInstance extends TypedEventInstance<UpdateEpochInterval> {
        data_decoded: UpdateEpochInterval;
        type_arguments: [];
    }
    interface UpdateEpochIntervalEvent {
        old_epoch_interval: bigint;
        new_epoch_interval: bigint;
    }
    namespace UpdateEpochIntervalEvent {
        const TYPE_QNAME = "0x1::block::UpdateEpochIntervalEvent";
        function type(): TypeDescriptor<UpdateEpochIntervalEvent>;
    }
    interface UpdateEpochIntervalEventInstance extends TypedEventInstance<UpdateEpochIntervalEvent> {
        data_decoded: UpdateEpochIntervalEvent;
        type_arguments: [];
    }
    namespace entry { }
    namespace view {
        function getCurrentBlockHeight(client: Aptos, version?: bigint): Promise<[bigint]>;
        function getEpochIntervalSecs(client: Aptos, version?: bigint): Promise<[bigint]>;
    }
}
export declare namespace debug {
    namespace entry { }
    namespace view { }
}
export declare namespace error {
    namespace entry { }
    namespace view { }
}
export declare namespace event {
    interface EventHandle<T0> {
        counter: bigint;
        guid: guid.GUID;
    }
    namespace EventHandle {
        const TYPE_QNAME = "0x1::event::EventHandle";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<EventHandle<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace stake {
    interface AddStake {
        pool_address: MoveAddressType;
        amount_added: bigint;
    }
    namespace AddStake {
        const TYPE_QNAME = "0x1::stake::AddStake";
        function type(): TypeDescriptor<AddStake>;
    }
    interface AddStakeInstance extends TypedEventInstance<AddStake> {
        data_decoded: AddStake;
        type_arguments: [];
    }
    interface AddStakeEvent {
        pool_address: MoveAddressType;
        amount_added: bigint;
    }
    namespace AddStakeEvent {
        const TYPE_QNAME = "0x1::stake::AddStakeEvent";
        function type(): TypeDescriptor<AddStakeEvent>;
    }
    interface AddStakeEventInstance extends TypedEventInstance<AddStakeEvent> {
        data_decoded: AddStakeEvent;
        type_arguments: [];
    }
    interface AllowedValidators {
        accounts: MoveAddressType[];
    }
    namespace AllowedValidators {
        const TYPE_QNAME = "0x1::stake::AllowedValidators";
        function type(): TypeDescriptor<AllowedValidators>;
    }
    interface AptosCoinCapabilities {
        mint_cap: coin.MintCapability<aptos_coin.AptosCoin>;
    }
    namespace AptosCoinCapabilities {
        const TYPE_QNAME = "0x1::stake::AptosCoinCapabilities";
        function type(): TypeDescriptor<AptosCoinCapabilities>;
    }
    interface DistributeRewards {
        pool_address: MoveAddressType;
        rewards_amount: bigint;
    }
    namespace DistributeRewards {
        const TYPE_QNAME = "0x1::stake::DistributeRewards";
        function type(): TypeDescriptor<DistributeRewards>;
    }
    interface DistributeRewardsInstance extends TypedEventInstance<DistributeRewards> {
        data_decoded: DistributeRewards;
        type_arguments: [];
    }
    interface DistributeRewardsEvent {
        pool_address: MoveAddressType;
        rewards_amount: bigint;
    }
    namespace DistributeRewardsEvent {
        const TYPE_QNAME = "0x1::stake::DistributeRewardsEvent";
        function type(): TypeDescriptor<DistributeRewardsEvent>;
    }
    interface DistributeRewardsEventInstance extends TypedEventInstance<DistributeRewardsEvent> {
        data_decoded: DistributeRewardsEvent;
        type_arguments: [];
    }
    interface IncreaseLockup {
        pool_address: MoveAddressType;
        old_locked_until_secs: bigint;
        new_locked_until_secs: bigint;
    }
    namespace IncreaseLockup {
        const TYPE_QNAME = "0x1::stake::IncreaseLockup";
        function type(): TypeDescriptor<IncreaseLockup>;
    }
    interface IncreaseLockupInstance extends TypedEventInstance<IncreaseLockup> {
        data_decoded: IncreaseLockup;
        type_arguments: [];
    }
    interface IncreaseLockupEvent {
        pool_address: MoveAddressType;
        old_locked_until_secs: bigint;
        new_locked_until_secs: bigint;
    }
    namespace IncreaseLockupEvent {
        const TYPE_QNAME = "0x1::stake::IncreaseLockupEvent";
        function type(): TypeDescriptor<IncreaseLockupEvent>;
    }
    interface IncreaseLockupEventInstance extends TypedEventInstance<IncreaseLockupEvent> {
        data_decoded: IncreaseLockupEvent;
        type_arguments: [];
    }
    interface IndividualValidatorPerformance {
        successful_proposals: bigint;
        failed_proposals: bigint;
    }
    namespace IndividualValidatorPerformance {
        const TYPE_QNAME = "0x1::stake::IndividualValidatorPerformance";
        function type(): TypeDescriptor<IndividualValidatorPerformance>;
    }
    interface IndividualValidatorPerformanceInstance extends TypedEventInstance<IndividualValidatorPerformance> {
        data_decoded: IndividualValidatorPerformance;
        type_arguments: [];
    }
    interface JoinValidatorSet {
        pool_address: MoveAddressType;
    }
    namespace JoinValidatorSet {
        const TYPE_QNAME = "0x1::stake::JoinValidatorSet";
        function type(): TypeDescriptor<JoinValidatorSet>;
    }
    interface JoinValidatorSetInstance extends TypedEventInstance<JoinValidatorSet> {
        data_decoded: JoinValidatorSet;
        type_arguments: [];
    }
    interface JoinValidatorSetEvent {
        pool_address: MoveAddressType;
    }
    namespace JoinValidatorSetEvent {
        const TYPE_QNAME = "0x1::stake::JoinValidatorSetEvent";
        function type(): TypeDescriptor<JoinValidatorSetEvent>;
    }
    interface JoinValidatorSetEventInstance extends TypedEventInstance<JoinValidatorSetEvent> {
        data_decoded: JoinValidatorSetEvent;
        type_arguments: [];
    }
    interface LeaveValidatorSet {
        pool_address: MoveAddressType;
    }
    namespace LeaveValidatorSet {
        const TYPE_QNAME = "0x1::stake::LeaveValidatorSet";
        function type(): TypeDescriptor<LeaveValidatorSet>;
    }
    interface LeaveValidatorSetInstance extends TypedEventInstance<LeaveValidatorSet> {
        data_decoded: LeaveValidatorSet;
        type_arguments: [];
    }
    interface LeaveValidatorSetEvent {
        pool_address: MoveAddressType;
    }
    namespace LeaveValidatorSetEvent {
        const TYPE_QNAME = "0x1::stake::LeaveValidatorSetEvent";
        function type(): TypeDescriptor<LeaveValidatorSetEvent>;
    }
    interface LeaveValidatorSetEventInstance extends TypedEventInstance<LeaveValidatorSetEvent> {
        data_decoded: LeaveValidatorSetEvent;
        type_arguments: [];
    }
    interface OwnerCapability {
        pool_address: MoveAddressType;
    }
    namespace OwnerCapability {
        const TYPE_QNAME = "0x1::stake::OwnerCapability";
        function type(): TypeDescriptor<OwnerCapability>;
    }
    interface ReactivateStake {
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace ReactivateStake {
        const TYPE_QNAME = "0x1::stake::ReactivateStake";
        function type(): TypeDescriptor<ReactivateStake>;
    }
    interface ReactivateStakeInstance extends TypedEventInstance<ReactivateStake> {
        data_decoded: ReactivateStake;
        type_arguments: [];
    }
    interface ReactivateStakeEvent {
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace ReactivateStakeEvent {
        const TYPE_QNAME = "0x1::stake::ReactivateStakeEvent";
        function type(): TypeDescriptor<ReactivateStakeEvent>;
    }
    interface ReactivateStakeEventInstance extends TypedEventInstance<ReactivateStakeEvent> {
        data_decoded: ReactivateStakeEvent;
        type_arguments: [];
    }
    interface RegisterValidatorCandidate {
        pool_address: MoveAddressType;
    }
    namespace RegisterValidatorCandidate {
        const TYPE_QNAME = "0x1::stake::RegisterValidatorCandidate";
        function type(): TypeDescriptor<RegisterValidatorCandidate>;
    }
    interface RegisterValidatorCandidateInstance extends TypedEventInstance<RegisterValidatorCandidate> {
        data_decoded: RegisterValidatorCandidate;
        type_arguments: [];
    }
    interface RegisterValidatorCandidateEvent {
        pool_address: MoveAddressType;
    }
    namespace RegisterValidatorCandidateEvent {
        const TYPE_QNAME = "0x1::stake::RegisterValidatorCandidateEvent";
        function type(): TypeDescriptor<RegisterValidatorCandidateEvent>;
    }
    interface RegisterValidatorCandidateEventInstance extends TypedEventInstance<RegisterValidatorCandidateEvent> {
        data_decoded: RegisterValidatorCandidateEvent;
        type_arguments: [];
    }
    interface RotateConsensusKey {
        pool_address: MoveAddressType;
        old_consensus_pubkey: string;
        new_consensus_pubkey: string;
    }
    namespace RotateConsensusKey {
        const TYPE_QNAME = "0x1::stake::RotateConsensusKey";
        function type(): TypeDescriptor<RotateConsensusKey>;
    }
    interface RotateConsensusKeyInstance extends TypedEventInstance<RotateConsensusKey> {
        data_decoded: RotateConsensusKey;
        type_arguments: [];
    }
    interface RotateConsensusKeyEvent {
        pool_address: MoveAddressType;
        old_consensus_pubkey: string;
        new_consensus_pubkey: string;
    }
    namespace RotateConsensusKeyEvent {
        const TYPE_QNAME = "0x1::stake::RotateConsensusKeyEvent";
        function type(): TypeDescriptor<RotateConsensusKeyEvent>;
    }
    interface RotateConsensusKeyEventInstance extends TypedEventInstance<RotateConsensusKeyEvent> {
        data_decoded: RotateConsensusKeyEvent;
        type_arguments: [];
    }
    interface SetOperator {
        pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
    }
    namespace SetOperator {
        const TYPE_QNAME = "0x1::stake::SetOperator";
        function type(): TypeDescriptor<SetOperator>;
    }
    interface SetOperatorInstance extends TypedEventInstance<SetOperator> {
        data_decoded: SetOperator;
        type_arguments: [];
    }
    interface SetOperatorEvent {
        pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
    }
    namespace SetOperatorEvent {
        const TYPE_QNAME = "0x1::stake::SetOperatorEvent";
        function type(): TypeDescriptor<SetOperatorEvent>;
    }
    interface SetOperatorEventInstance extends TypedEventInstance<SetOperatorEvent> {
        data_decoded: SetOperatorEvent;
        type_arguments: [];
    }
    interface StakePool {
        active: coin.Coin<aptos_coin.AptosCoin>;
        inactive: coin.Coin<aptos_coin.AptosCoin>;
        pending_active: coin.Coin<aptos_coin.AptosCoin>;
        pending_inactive: coin.Coin<aptos_coin.AptosCoin>;
        locked_until_secs: bigint;
        operator_address: MoveAddressType;
        delegated_voter: MoveAddressType;
        initialize_validator_events: event.EventHandle<stake.RegisterValidatorCandidateEvent>;
        set_operator_events: event.EventHandle<stake.SetOperatorEvent>;
        add_stake_events: event.EventHandle<stake.AddStakeEvent>;
        reactivate_stake_events: event.EventHandle<stake.ReactivateStakeEvent>;
        rotate_consensus_key_events: event.EventHandle<stake.RotateConsensusKeyEvent>;
        update_network_and_fullnode_addresses_events: event.EventHandle<stake.UpdateNetworkAndFullnodeAddressesEvent>;
        increase_lockup_events: event.EventHandle<stake.IncreaseLockupEvent>;
        join_validator_set_events: event.EventHandle<stake.JoinValidatorSetEvent>;
        distribute_rewards_events: event.EventHandle<stake.DistributeRewardsEvent>;
        unlock_stake_events: event.EventHandle<stake.UnlockStakeEvent>;
        withdraw_stake_events: event.EventHandle<stake.WithdrawStakeEvent>;
        leave_validator_set_events: event.EventHandle<stake.LeaveValidatorSetEvent>;
    }
    namespace StakePool {
        const TYPE_QNAME = "0x1::stake::StakePool";
        function type(): TypeDescriptor<StakePool>;
    }
    interface UnlockStake {
        pool_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStake {
        const TYPE_QNAME = "0x1::stake::UnlockStake";
        function type(): TypeDescriptor<UnlockStake>;
    }
    interface UnlockStakeInstance extends TypedEventInstance<UnlockStake> {
        data_decoded: UnlockStake;
        type_arguments: [];
    }
    interface UnlockStakeEvent {
        pool_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStakeEvent {
        const TYPE_QNAME = "0x1::stake::UnlockStakeEvent";
        function type(): TypeDescriptor<UnlockStakeEvent>;
    }
    interface UnlockStakeEventInstance extends TypedEventInstance<UnlockStakeEvent> {
        data_decoded: UnlockStakeEvent;
        type_arguments: [];
    }
    interface UpdateNetworkAndFullnodeAddresses {
        pool_address: MoveAddressType;
        old_network_addresses: string;
        new_network_addresses: string;
        old_fullnode_addresses: string;
        new_fullnode_addresses: string;
    }
    namespace UpdateNetworkAndFullnodeAddresses {
        const TYPE_QNAME = "0x1::stake::UpdateNetworkAndFullnodeAddresses";
        function type(): TypeDescriptor<UpdateNetworkAndFullnodeAddresses>;
    }
    interface UpdateNetworkAndFullnodeAddressesInstance extends TypedEventInstance<UpdateNetworkAndFullnodeAddresses> {
        data_decoded: UpdateNetworkAndFullnodeAddresses;
        type_arguments: [];
    }
    interface UpdateNetworkAndFullnodeAddressesEvent {
        pool_address: MoveAddressType;
        old_network_addresses: string;
        new_network_addresses: string;
        old_fullnode_addresses: string;
        new_fullnode_addresses: string;
    }
    namespace UpdateNetworkAndFullnodeAddressesEvent {
        const TYPE_QNAME = "0x1::stake::UpdateNetworkAndFullnodeAddressesEvent";
        function type(): TypeDescriptor<UpdateNetworkAndFullnodeAddressesEvent>;
    }
    interface UpdateNetworkAndFullnodeAddressesEventInstance extends TypedEventInstance<UpdateNetworkAndFullnodeAddressesEvent> {
        data_decoded: UpdateNetworkAndFullnodeAddressesEvent;
        type_arguments: [];
    }
    interface ValidatorConfig {
        consensus_pubkey: string;
        network_addresses: string;
        fullnode_addresses: string;
        validator_index: bigint;
    }
    namespace ValidatorConfig {
        const TYPE_QNAME = "0x1::stake::ValidatorConfig";
        function type(): TypeDescriptor<ValidatorConfig>;
    }
    interface ValidatorConfigInstance extends TypedEventInstance<ValidatorConfig> {
        data_decoded: ValidatorConfig;
        type_arguments: [];
    }
    interface ValidatorFees {
        fees_table: table.Table<MoveAddressType, coin.Coin<aptos_coin.AptosCoin>>;
    }
    namespace ValidatorFees {
        const TYPE_QNAME = "0x1::stake::ValidatorFees";
        function type(): TypeDescriptor<ValidatorFees>;
    }
    interface ValidatorInfo {
        addr: MoveAddressType;
        voting_power: bigint;
        config: stake.ValidatorConfig;
    }
    namespace ValidatorInfo {
        const TYPE_QNAME = "0x1::stake::ValidatorInfo";
        function type(): TypeDescriptor<ValidatorInfo>;
    }
    interface ValidatorInfoInstance extends TypedEventInstance<ValidatorInfo> {
        data_decoded: ValidatorInfo;
        type_arguments: [];
    }
    interface ValidatorPerformance {
        validators: stake.IndividualValidatorPerformance[];
    }
    namespace ValidatorPerformance {
        const TYPE_QNAME = "0x1::stake::ValidatorPerformance";
        function type(): TypeDescriptor<ValidatorPerformance>;
    }
    interface ValidatorSet {
        consensus_scheme: number;
        active_validators: stake.ValidatorInfo[];
        pending_inactive: stake.ValidatorInfo[];
        pending_active: stake.ValidatorInfo[];
        total_voting_power: bigint;
        total_joining_power: bigint;
    }
    namespace ValidatorSet {
        const TYPE_QNAME = "0x1::stake::ValidatorSet";
        function type(): TypeDescriptor<ValidatorSet>;
    }
    interface ValidatorSetInstance extends TypedEventInstance<ValidatorSet> {
        data_decoded: ValidatorSet;
        type_arguments: [];
    }
    interface WithdrawStake {
        pool_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStake {
        const TYPE_QNAME = "0x1::stake::WithdrawStake";
        function type(): TypeDescriptor<WithdrawStake>;
    }
    interface WithdrawStakeInstance extends TypedEventInstance<WithdrawStake> {
        data_decoded: WithdrawStake;
        type_arguments: [];
    }
    interface WithdrawStakeEvent {
        pool_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStakeEvent {
        const TYPE_QNAME = "0x1::stake::WithdrawStakeEvent";
        function type(): TypeDescriptor<WithdrawStakeEvent>;
    }
    interface WithdrawStakeEventInstance extends TypedEventInstance<WithdrawStakeEvent> {
        data_decoded: WithdrawStakeEvent;
        type_arguments: [];
    }
    namespace entry {
        function addStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function increaseLockup(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function initializeStakeOwner(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint, MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function initializeValidator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function joinValidatorSet(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function leaveValidatorSet(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function reactivateStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateConsensusKey(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setDelegatedVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlock(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateNetworkAndFullnodeAddresses(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function withdraw(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function getCurrentEpochProposalCounts(client: Aptos, request: {
            functionArguments: [bigint];
        }, version?: bigint): Promise<[bigint, bigint]>;
        function getCurrentEpochVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getDelegatedVoter(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getLockupSecs(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getOperator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getRemainingLockupSecs(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getStake(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint, bigint, bigint, bigint]>;
        function getValidatorConfig(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[string, string, string]>;
        function getValidatorIndex(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getValidatorState(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function stakePoolExists(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
    }
}
export declare namespace table {
    interface Box<T0> {
        val: T0;
    }
    namespace Box {
        const TYPE_QNAME = "0x1::table::Box";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Box<T0>>;
    }
    interface BoxInstance extends TypedEventInstance<Box<any>> {
        data_decoded: Box<any>;
        type_arguments: [string];
    }
    interface Table<T0, T1> {
        handle: MoveAddressType;
    }
    namespace Table {
        const TYPE_QNAME = "0x1::table::Table";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Table<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace math64 {
    namespace entry { }
    namespace view { }
}
export declare namespace object_ {
    interface ConstructorRef {
        self: MoveAddressType;
        can_delete: Boolean;
    }
    namespace ConstructorRef {
        const TYPE_QNAME = "0x1::object::ConstructorRef";
        function type(): TypeDescriptor<ConstructorRef>;
    }
    interface DeleteRef {
        self: MoveAddressType;
    }
    namespace DeleteRef {
        const TYPE_QNAME = "0x1::object::DeleteRef";
        function type(): TypeDescriptor<DeleteRef>;
    }
    interface DeleteRefInstance extends TypedEventInstance<DeleteRef> {
        data_decoded: DeleteRef;
        type_arguments: [];
    }
    interface DeriveRef {
        self: MoveAddressType;
    }
    namespace DeriveRef {
        const TYPE_QNAME = "0x1::object::DeriveRef";
        function type(): TypeDescriptor<DeriveRef>;
    }
    interface DeriveRefInstance extends TypedEventInstance<DeriveRef> {
        data_decoded: DeriveRef;
        type_arguments: [];
    }
    interface ExtendRef {
        self: MoveAddressType;
    }
    namespace ExtendRef {
        const TYPE_QNAME = "0x1::object::ExtendRef";
        function type(): TypeDescriptor<ExtendRef>;
    }
    interface ExtendRefInstance extends TypedEventInstance<ExtendRef> {
        data_decoded: ExtendRef;
        type_arguments: [];
    }
    interface LinearTransferRef {
        self: MoveAddressType;
        owner: MoveAddressType;
    }
    namespace LinearTransferRef {
        const TYPE_QNAME = "0x1::object::LinearTransferRef";
        function type(): TypeDescriptor<LinearTransferRef>;
    }
    interface Object<T0> {
        inner: MoveAddressType;
    }
    namespace Object {
        const TYPE_QNAME = "0x1::object::Object";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Object<T0>>;
    }
    interface ObjectInstance extends TypedEventInstance<Object<any>> {
        data_decoded: Object<any>;
        type_arguments: [string];
    }
    interface ObjectCore {
        guid_creation_num: bigint;
        owner: MoveAddressType;
        allow_ungated_transfer: Boolean;
        transfer_events: event.EventHandle<object_.TransferEvent>;
    }
    namespace ObjectCore {
        const TYPE_QNAME = "0x1::object::ObjectCore";
        function type(): TypeDescriptor<ObjectCore>;
    }
    interface ObjectGroup {
        dummy_field: Boolean;
    }
    namespace ObjectGroup {
        const TYPE_QNAME = "0x1::object::ObjectGroup";
        function type(): TypeDescriptor<ObjectGroup>;
    }
    interface TombStone {
        original_owner: MoveAddressType;
    }
    namespace TombStone {
        const TYPE_QNAME = "0x1::object::TombStone";
        function type(): TypeDescriptor<TombStone>;
    }
    interface Transfer {
        object: MoveAddressType;
        from: MoveAddressType;
        to: MoveAddressType;
    }
    namespace Transfer {
        const TYPE_QNAME = "0x1::object::Transfer";
        function type(): TypeDescriptor<Transfer>;
    }
    interface TransferInstance extends TypedEventInstance<Transfer> {
        data_decoded: Transfer;
        type_arguments: [];
    }
    interface TransferEvent {
        object: MoveAddressType;
        from: MoveAddressType;
        to: MoveAddressType;
    }
    namespace TransferEvent {
        const TYPE_QNAME = "0x1::object::TransferEvent";
        function type(): TypeDescriptor<TransferEvent>;
    }
    interface TransferEventInstance extends TypedEventInstance<TransferEvent> {
        data_decoded: TransferEvent;
        type_arguments: [];
    }
    interface TransferRef {
        self: MoveAddressType;
    }
    namespace TransferRef {
        const TYPE_QNAME = "0x1::object::TransferRef";
        function type(): TypeDescriptor<TransferRef>;
    }
    interface TransferRefInstance extends TypedEventInstance<TransferRef> {
        data_decoded: TransferRef;
        type_arguments: [];
    }
    interface Untransferable {
        dummy_field: Boolean;
    }
    namespace Untransferable {
        const TYPE_QNAME = "0x1::object::Untransferable";
        function type(): TypeDescriptor<Untransferable>;
    }
    namespace entry {
        function burn<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferCall(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferToObject<T0 = any, T1 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId, MoveStructId];
            functionArguments: [object_.Object<T0>, object_.Object<T1>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unburn<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function isBurnt<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
        function isUntransferable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
    }
}
export declare namespace option {
    interface Option<T0> {
        vec: T0[] | string;
    }
    namespace Option {
        const TYPE_QNAME = "0x1::option::Option";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Option<T0>>;
    }
    interface OptionInstance extends TypedEventInstance<Option<any>> {
        data_decoded: Option<any>;
        type_arguments: [string];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace signer {
    namespace entry { }
    namespace view { }
}
export declare namespace string_ {
    interface String {
        bytes: string;
    }
    namespace String {
        const TYPE_QNAME = "0x1::string::String";
        function type(): TypeDescriptor<String>;
    }
    interface StringInstance extends TypedEventInstance<String> {
        data_decoded: String;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace vector {
    namespace entry { }
    namespace view { }
}
export declare namespace voting {
    interface CreateProposal {
        proposal_id: bigint;
        early_resolution_vote_threshold: option.Option<bigint>;
        execution_hash: string;
        expiration_secs: bigint;
        metadata: simple_map.SimpleMap<string, string>;
        min_vote_threshold: bigint;
    }
    namespace CreateProposal {
        const TYPE_QNAME = "0x1::voting::CreateProposal";
        function type(): TypeDescriptor<CreateProposal>;
    }
    interface CreateProposalInstance extends TypedEventInstance<CreateProposal> {
        data_decoded: CreateProposal;
        type_arguments: [];
    }
    interface CreateProposalEvent {
        proposal_id: bigint;
        early_resolution_vote_threshold: option.Option<bigint>;
        execution_hash: string;
        expiration_secs: bigint;
        metadata: simple_map.SimpleMap<string, string>;
        min_vote_threshold: bigint;
    }
    namespace CreateProposalEvent {
        const TYPE_QNAME = "0x1::voting::CreateProposalEvent";
        function type(): TypeDescriptor<CreateProposalEvent>;
    }
    interface CreateProposalEventInstance extends TypedEventInstance<CreateProposalEvent> {
        data_decoded: CreateProposalEvent;
        type_arguments: [];
    }
    interface Proposal<T0> {
        proposer: MoveAddressType;
        execution_content: option.Option<T0>;
        metadata: simple_map.SimpleMap<string, string>;
        creation_time_secs: bigint;
        execution_hash: string;
        min_vote_threshold: bigint;
        expiration_secs: bigint;
        early_resolution_vote_threshold: option.Option<bigint>;
        yes_votes: bigint;
        no_votes: bigint;
        is_resolved: Boolean;
        resolution_time_secs: bigint;
    }
    namespace Proposal {
        const TYPE_QNAME = "0x1::voting::Proposal";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Proposal<T0>>;
    }
    interface RegisterForum {
        hosting_account: MoveAddressType;
        proposal_type_info: type_info.TypeInfo;
    }
    namespace RegisterForum {
        const TYPE_QNAME = "0x1::voting::RegisterForum";
        function type(): TypeDescriptor<RegisterForum>;
    }
    interface RegisterForumInstance extends TypedEventInstance<RegisterForum> {
        data_decoded: RegisterForum;
        type_arguments: [];
    }
    interface RegisterForumEvent {
        hosting_account: MoveAddressType;
        proposal_type_info: type_info.TypeInfo;
    }
    namespace RegisterForumEvent {
        const TYPE_QNAME = "0x1::voting::RegisterForumEvent";
        function type(): TypeDescriptor<RegisterForumEvent>;
    }
    interface RegisterForumEventInstance extends TypedEventInstance<RegisterForumEvent> {
        data_decoded: RegisterForumEvent;
        type_arguments: [];
    }
    interface ResolveProposal {
        proposal_id: bigint;
        yes_votes: bigint;
        no_votes: bigint;
        resolved_early: Boolean;
    }
    namespace ResolveProposal {
        const TYPE_QNAME = "0x1::voting::ResolveProposal";
        function type(): TypeDescriptor<ResolveProposal>;
    }
    interface ResolveProposalInstance extends TypedEventInstance<ResolveProposal> {
        data_decoded: ResolveProposal;
        type_arguments: [];
    }
    interface Vote {
        proposal_id: bigint;
        num_votes: bigint;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::voting::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    interface VoteInstance extends TypedEventInstance<Vote> {
        data_decoded: Vote;
        type_arguments: [];
    }
    interface VoteEvent {
        proposal_id: bigint;
        num_votes: bigint;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::voting::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    interface VoteEventInstance extends TypedEventInstance<VoteEvent> {
        data_decoded: VoteEvent;
        type_arguments: [];
    }
    interface VotingEvents {
        create_proposal_events: event.EventHandle<voting.CreateProposalEvent>;
        register_forum_events: event.EventHandle<voting.RegisterForumEvent>;
        resolve_proposal_events: event.EventHandle<voting.ResolveProposal>;
        vote_events: event.EventHandle<voting.VoteEvent>;
    }
    namespace VotingEvents {
        const TYPE_QNAME = "0x1::voting::VotingEvents";
        function type(): TypeDescriptor<VotingEvents>;
    }
    interface VotingForum<T0> {
        proposals: table.Table<bigint, voting.Proposal<T0>>;
        events: voting.VotingEvents;
        next_proposal_id: bigint;
    }
    namespace VotingForum {
        const TYPE_QNAME = "0x1::voting::VotingForum";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<VotingForum<T0>>;
    }
    namespace entry { }
    namespace view {
        function getEarlyResolutionVoteThreshold<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function getExecutionHash<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[string]>;
        function getMinVoteThreshold<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getProposalCreationSecs<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getProposalExpirationSecs<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getProposalMetadata<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[simple_map.SimpleMap<string, string>]>;
        function getProposalMetadataValue<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint, string];
        }, version?: bigint): Promise<[string]>;
        function getProposalState<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getProposer<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getResolutionTimeSecs<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getVotes<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint, bigint]>;
        function isMultiStepProposalInExecution<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[Boolean]>;
        function isResolved<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[Boolean]>;
        function isVotingClosed<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[Boolean]>;
        function nextProposalId<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
    }
}
export declare namespace account {
    interface Account {
        authentication_key: string;
        sequence_number: bigint;
        guid_creation_num: bigint;
        coin_register_events: event.EventHandle<account.CoinRegisterEvent>;
        key_rotation_events: event.EventHandle<account.KeyRotationEvent>;
        rotation_capability_offer: account.CapabilityOffer<account.RotationCapability>;
        signer_capability_offer: account.CapabilityOffer<account.SignerCapability>;
    }
    namespace Account {
        const TYPE_QNAME = "0x1::account::Account";
        function type(): TypeDescriptor<Account>;
    }
    interface CapabilityOffer<T0> {
        for: option.Option<MoveAddressType>;
    }
    namespace CapabilityOffer {
        const TYPE_QNAME = "0x1::account::CapabilityOffer";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CapabilityOffer<T0>>;
    }
    interface CoinRegisterEvent {
        type_info: type_info.TypeInfo;
    }
    namespace CoinRegisterEvent {
        const TYPE_QNAME = "0x1::account::CoinRegisterEvent";
        function type(): TypeDescriptor<CoinRegisterEvent>;
    }
    interface CoinRegisterEventInstance extends TypedEventInstance<CoinRegisterEvent> {
        data_decoded: CoinRegisterEvent;
        type_arguments: [];
    }
    interface KeyRotation {
        account: MoveAddressType;
        old_authentication_key: string;
        new_authentication_key: string;
    }
    namespace KeyRotation {
        const TYPE_QNAME = "0x1::account::KeyRotation";
        function type(): TypeDescriptor<KeyRotation>;
    }
    interface KeyRotationInstance extends TypedEventInstance<KeyRotation> {
        data_decoded: KeyRotation;
        type_arguments: [];
    }
    interface KeyRotationEvent {
        old_authentication_key: string;
        new_authentication_key: string;
    }
    namespace KeyRotationEvent {
        const TYPE_QNAME = "0x1::account::KeyRotationEvent";
        function type(): TypeDescriptor<KeyRotationEvent>;
    }
    interface KeyRotationEventInstance extends TypedEventInstance<KeyRotationEvent> {
        data_decoded: KeyRotationEvent;
        type_arguments: [];
    }
    interface OriginatingAddress {
        address_map: table.Table<MoveAddressType, MoveAddressType>;
    }
    namespace OriginatingAddress {
        const TYPE_QNAME = "0x1::account::OriginatingAddress";
        function type(): TypeDescriptor<OriginatingAddress>;
    }
    interface RotationCapability {
        account: MoveAddressType;
    }
    namespace RotationCapability {
        const TYPE_QNAME = "0x1::account::RotationCapability";
        function type(): TypeDescriptor<RotationCapability>;
    }
    interface RotationCapabilityInstance extends TypedEventInstance<RotationCapability> {
        data_decoded: RotationCapability;
        type_arguments: [];
    }
    interface RotationCapabilityOfferProofChallenge {
        sequence_number: bigint;
        recipient_address: MoveAddressType;
    }
    namespace RotationCapabilityOfferProofChallenge {
        const TYPE_QNAME = "0x1::account::RotationCapabilityOfferProofChallenge";
        function type(): TypeDescriptor<RotationCapabilityOfferProofChallenge>;
    }
    interface RotationCapabilityOfferProofChallengeV2 {
        chain_id: number;
        sequence_number: bigint;
        source_address: MoveAddressType;
        recipient_address: MoveAddressType;
    }
    namespace RotationCapabilityOfferProofChallengeV2 {
        const TYPE_QNAME = "0x1::account::RotationCapabilityOfferProofChallengeV2";
        function type(): TypeDescriptor<RotationCapabilityOfferProofChallengeV2>;
    }
    interface RotationProofChallenge {
        sequence_number: bigint;
        originator: MoveAddressType;
        current_auth_key: MoveAddressType;
        new_public_key: string;
    }
    namespace RotationProofChallenge {
        const TYPE_QNAME = "0x1::account::RotationProofChallenge";
        function type(): TypeDescriptor<RotationProofChallenge>;
    }
    interface SignerCapability {
        account: MoveAddressType;
    }
    namespace SignerCapability {
        const TYPE_QNAME = "0x1::account::SignerCapability";
        function type(): TypeDescriptor<SignerCapability>;
    }
    interface SignerCapabilityInstance extends TypedEventInstance<SignerCapability> {
        data_decoded: SignerCapability;
        type_arguments: [];
    }
    interface SignerCapabilityOfferProofChallenge {
        sequence_number: bigint;
        recipient_address: MoveAddressType;
    }
    namespace SignerCapabilityOfferProofChallenge {
        const TYPE_QNAME = "0x1::account::SignerCapabilityOfferProofChallenge";
        function type(): TypeDescriptor<SignerCapabilityOfferProofChallenge>;
    }
    interface SignerCapabilityOfferProofChallengeV2 {
        sequence_number: bigint;
        source_address: MoveAddressType;
        recipient_address: MoveAddressType;
    }
    namespace SignerCapabilityOfferProofChallengeV2 {
        const TYPE_QNAME = "0x1::account::SignerCapabilityOfferProofChallengeV2";
        function type(): TypeDescriptor<SignerCapabilityOfferProofChallengeV2>;
    }
    namespace entry {
        function offerRotationCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, number, string, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function offerSignerCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, number, string, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokeAnyRotationCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokeAnySignerCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokeRotationCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function revokeSignerCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateAuthenticationKey(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [number, string, number, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateAuthenticationKeyCall(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rotateAuthenticationKeyWithRotationCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, number, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function existsAt(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function getAuthenticationKey(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[string]>;
        function getGuidNextCreationNum(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getRotationCapabilityOfferFor(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getSequenceNumber(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getSignerCapabilityOfferFor(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function isRotationCapabilityOffered(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function isSignerCapabilityOffered(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
    }
}
export declare namespace ed25519 {
    interface Signature {
        bytes: string;
    }
    namespace Signature {
        const TYPE_QNAME = "0x1::ed25519::Signature";
        function type(): TypeDescriptor<Signature>;
    }
    interface SignatureInstance extends TypedEventInstance<Signature> {
        data_decoded: Signature;
        type_arguments: [];
    }
    interface SignedMessage<T0> {
        type_info: type_info.TypeInfo;
        inner: T0;
    }
    namespace SignedMessage {
        const TYPE_QNAME = "0x1::ed25519::SignedMessage";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<SignedMessage<T0>>;
    }
    interface UnvalidatedPublicKey {
        bytes: string;
    }
    namespace UnvalidatedPublicKey {
        const TYPE_QNAME = "0x1::ed25519::UnvalidatedPublicKey";
        function type(): TypeDescriptor<UnvalidatedPublicKey>;
    }
    interface UnvalidatedPublicKeyInstance extends TypedEventInstance<UnvalidatedPublicKey> {
        data_decoded: UnvalidatedPublicKey;
        type_arguments: [];
    }
    interface ValidatedPublicKey {
        bytes: string;
    }
    namespace ValidatedPublicKey {
        const TYPE_QNAME = "0x1::ed25519::ValidatedPublicKey";
        function type(): TypeDescriptor<ValidatedPublicKey>;
    }
    interface ValidatedPublicKeyInstance extends TypedEventInstance<ValidatedPublicKey> {
        data_decoded: ValidatedPublicKey;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace genesis {
    interface AccountMap {
        account_address: MoveAddressType;
        balance: bigint;
    }
    namespace AccountMap {
        const TYPE_QNAME = "0x1::genesis::AccountMap";
        function type(): TypeDescriptor<AccountMap>;
    }
    interface EmployeeAccountMap {
        accounts: MoveAddressType[];
        validator: genesis.ValidatorConfigurationWithCommission;
        vesting_schedule_numerator: bigint[];
        vesting_schedule_denominator: bigint;
        beneficiary_resetter: MoveAddressType;
    }
    namespace EmployeeAccountMap {
        const TYPE_QNAME = "0x1::genesis::EmployeeAccountMap";
        function type(): TypeDescriptor<EmployeeAccountMap>;
    }
    interface ValidatorConfiguration {
        owner_address: MoveAddressType;
        operator_address: MoveAddressType;
        voter_address: MoveAddressType;
        stake_amount: bigint;
        consensus_pubkey: string;
        proof_of_possession: string;
        network_addresses: string;
        full_node_network_addresses: string;
    }
    namespace ValidatorConfiguration {
        const TYPE_QNAME = "0x1::genesis::ValidatorConfiguration";
        function type(): TypeDescriptor<ValidatorConfiguration>;
    }
    interface ValidatorConfigurationWithCommission {
        validator_config: genesis.ValidatorConfiguration;
        commission_percentage: bigint;
        join_during_genesis: Boolean;
    }
    namespace ValidatorConfigurationWithCommission {
        const TYPE_QNAME = "0x1::genesis::ValidatorConfigurationWithCommission";
        function type(): TypeDescriptor<ValidatorConfigurationWithCommission>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace math128 {
    namespace entry { }
    namespace view { }
}
export declare namespace version {
    interface SetVersionCapability {
        dummy_field: Boolean;
    }
    namespace SetVersionCapability {
        const TYPE_QNAME = "0x1::version::SetVersionCapability";
        function type(): TypeDescriptor<SetVersionCapability>;
    }
    interface Version {
        major: bigint;
    }
    namespace Version {
        const TYPE_QNAME = "0x1::version::Version";
        function type(): TypeDescriptor<Version>;
    }
    interface VersionInstance extends TypedEventInstance<Version> {
        data_decoded: Version;
        type_arguments: [];
    }
    namespace entry {
        function setForNextEpoch(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setVersion(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace vesting {
    interface AdminStore {
        vesting_contracts: MoveAddressType[];
        nonce: bigint;
        create_events: event.EventHandle<vesting.CreateVestingContractEvent>;
    }
    namespace AdminStore {
        const TYPE_QNAME = "0x1::vesting::AdminStore";
        function type(): TypeDescriptor<AdminStore>;
    }
    interface AdminWithdraw {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace AdminWithdraw {
        const TYPE_QNAME = "0x1::vesting::AdminWithdraw";
        function type(): TypeDescriptor<AdminWithdraw>;
    }
    interface AdminWithdrawInstance extends TypedEventInstance<AdminWithdraw> {
        data_decoded: AdminWithdraw;
        type_arguments: [];
    }
    interface AdminWithdrawEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace AdminWithdrawEvent {
        const TYPE_QNAME = "0x1::vesting::AdminWithdrawEvent";
        function type(): TypeDescriptor<AdminWithdrawEvent>;
    }
    interface AdminWithdrawEventInstance extends TypedEventInstance<AdminWithdrawEvent> {
        data_decoded: AdminWithdrawEvent;
        type_arguments: [];
    }
    interface CreateVestingContract {
        operator: MoveAddressType;
        voter: MoveAddressType;
        grant_amount: bigint;
        withdrawal_address: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace CreateVestingContract {
        const TYPE_QNAME = "0x1::vesting::CreateVestingContract";
        function type(): TypeDescriptor<CreateVestingContract>;
    }
    interface CreateVestingContractInstance extends TypedEventInstance<CreateVestingContract> {
        data_decoded: CreateVestingContract;
        type_arguments: [];
    }
    interface CreateVestingContractEvent {
        operator: MoveAddressType;
        voter: MoveAddressType;
        grant_amount: bigint;
        withdrawal_address: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace CreateVestingContractEvent {
        const TYPE_QNAME = "0x1::vesting::CreateVestingContractEvent";
        function type(): TypeDescriptor<CreateVestingContractEvent>;
    }
    interface CreateVestingContractEventInstance extends TypedEventInstance<CreateVestingContractEvent> {
        data_decoded: CreateVestingContractEvent;
        type_arguments: [];
    }
    interface Distribute {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace Distribute {
        const TYPE_QNAME = "0x1::vesting::Distribute";
        function type(): TypeDescriptor<Distribute>;
    }
    interface DistributeInstance extends TypedEventInstance<Distribute> {
        data_decoded: Distribute;
        type_arguments: [];
    }
    interface DistributeEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace DistributeEvent {
        const TYPE_QNAME = "0x1::vesting::DistributeEvent";
        function type(): TypeDescriptor<DistributeEvent>;
    }
    interface DistributeEventInstance extends TypedEventInstance<DistributeEvent> {
        data_decoded: DistributeEvent;
        type_arguments: [];
    }
    interface ResetLockup {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        new_lockup_expiration_secs: bigint;
    }
    namespace ResetLockup {
        const TYPE_QNAME = "0x1::vesting::ResetLockup";
        function type(): TypeDescriptor<ResetLockup>;
    }
    interface ResetLockupInstance extends TypedEventInstance<ResetLockup> {
        data_decoded: ResetLockup;
        type_arguments: [];
    }
    interface ResetLockupEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        new_lockup_expiration_secs: bigint;
    }
    namespace ResetLockupEvent {
        const TYPE_QNAME = "0x1::vesting::ResetLockupEvent";
        function type(): TypeDescriptor<ResetLockupEvent>;
    }
    interface ResetLockupEventInstance extends TypedEventInstance<ResetLockupEvent> {
        data_decoded: ResetLockupEvent;
        type_arguments: [];
    }
    interface SetBeneficiary {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        shareholder: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiary {
        const TYPE_QNAME = "0x1::vesting::SetBeneficiary";
        function type(): TypeDescriptor<SetBeneficiary>;
    }
    interface SetBeneficiaryInstance extends TypedEventInstance<SetBeneficiary> {
        data_decoded: SetBeneficiary;
        type_arguments: [];
    }
    interface SetBeneficiaryEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        shareholder: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiaryEvent {
        const TYPE_QNAME = "0x1::vesting::SetBeneficiaryEvent";
        function type(): TypeDescriptor<SetBeneficiaryEvent>;
    }
    interface SetBeneficiaryEventInstance extends TypedEventInstance<SetBeneficiaryEvent> {
        data_decoded: SetBeneficiaryEvent;
        type_arguments: [];
    }
    interface StakingInfo {
        pool_address: MoveAddressType;
        operator: MoveAddressType;
        voter: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace StakingInfo {
        const TYPE_QNAME = "0x1::vesting::StakingInfo";
        function type(): TypeDescriptor<StakingInfo>;
    }
    interface Terminate {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
    }
    namespace Terminate {
        const TYPE_QNAME = "0x1::vesting::Terminate";
        function type(): TypeDescriptor<Terminate>;
    }
    interface TerminateInstance extends TypedEventInstance<Terminate> {
        data_decoded: Terminate;
        type_arguments: [];
    }
    interface TerminateEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
    }
    namespace TerminateEvent {
        const TYPE_QNAME = "0x1::vesting::TerminateEvent";
        function type(): TypeDescriptor<TerminateEvent>;
    }
    interface TerminateEventInstance extends TypedEventInstance<TerminateEvent> {
        data_decoded: TerminateEvent;
        type_arguments: [];
    }
    interface UnlockRewards {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace UnlockRewards {
        const TYPE_QNAME = "0x1::vesting::UnlockRewards";
        function type(): TypeDescriptor<UnlockRewards>;
    }
    interface UnlockRewardsInstance extends TypedEventInstance<UnlockRewards> {
        data_decoded: UnlockRewards;
        type_arguments: [];
    }
    interface UnlockRewardsEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace UnlockRewardsEvent {
        const TYPE_QNAME = "0x1::vesting::UnlockRewardsEvent";
        function type(): TypeDescriptor<UnlockRewardsEvent>;
    }
    interface UnlockRewardsEventInstance extends TypedEventInstance<UnlockRewardsEvent> {
        data_decoded: UnlockRewardsEvent;
        type_arguments: [];
    }
    interface UpdateOperator {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace UpdateOperator {
        const TYPE_QNAME = "0x1::vesting::UpdateOperator";
        function type(): TypeDescriptor<UpdateOperator>;
    }
    interface UpdateOperatorInstance extends TypedEventInstance<UpdateOperator> {
        data_decoded: UpdateOperator;
        type_arguments: [];
    }
    interface UpdateOperatorEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace UpdateOperatorEvent {
        const TYPE_QNAME = "0x1::vesting::UpdateOperatorEvent";
        function type(): TypeDescriptor<UpdateOperatorEvent>;
    }
    interface UpdateOperatorEventInstance extends TypedEventInstance<UpdateOperatorEvent> {
        data_decoded: UpdateOperatorEvent;
        type_arguments: [];
    }
    interface UpdateVoter {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoter {
        const TYPE_QNAME = "0x1::vesting::UpdateVoter";
        function type(): TypeDescriptor<UpdateVoter>;
    }
    interface UpdateVoterInstance extends TypedEventInstance<UpdateVoter> {
        data_decoded: UpdateVoter;
        type_arguments: [];
    }
    interface UpdateVoterEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoterEvent {
        const TYPE_QNAME = "0x1::vesting::UpdateVoterEvent";
        function type(): TypeDescriptor<UpdateVoterEvent>;
    }
    interface UpdateVoterEventInstance extends TypedEventInstance<UpdateVoterEvent> {
        data_decoded: UpdateVoterEvent;
        type_arguments: [];
    }
    interface Vest {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        period_vested: bigint;
        amount: bigint;
    }
    namespace Vest {
        const TYPE_QNAME = "0x1::vesting::Vest";
        function type(): TypeDescriptor<Vest>;
    }
    interface VestInstance extends TypedEventInstance<Vest> {
        data_decoded: Vest;
        type_arguments: [];
    }
    interface VestEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        period_vested: bigint;
        amount: bigint;
    }
    namespace VestEvent {
        const TYPE_QNAME = "0x1::vesting::VestEvent";
        function type(): TypeDescriptor<VestEvent>;
    }
    interface VestEventInstance extends TypedEventInstance<VestEvent> {
        data_decoded: VestEvent;
        type_arguments: [];
    }
    interface VestingAccountManagement {
        roles: simple_map.SimpleMap<string, MoveAddressType>;
    }
    namespace VestingAccountManagement {
        const TYPE_QNAME = "0x1::vesting::VestingAccountManagement";
        function type(): TypeDescriptor<VestingAccountManagement>;
    }
    interface VestingContract {
        state: bigint;
        admin: MoveAddressType;
        grant_pool: pool_u64.Pool;
        beneficiaries: simple_map.SimpleMap<MoveAddressType, MoveAddressType>;
        vesting_schedule: vesting.VestingSchedule;
        withdrawal_address: MoveAddressType;
        staking: vesting.StakingInfo;
        remaining_grant: bigint;
        signer_cap: account.SignerCapability;
        update_operator_events: event.EventHandle<vesting.UpdateOperatorEvent>;
        update_voter_events: event.EventHandle<vesting.UpdateVoterEvent>;
        reset_lockup_events: event.EventHandle<vesting.ResetLockupEvent>;
        set_beneficiary_events: event.EventHandle<vesting.SetBeneficiaryEvent>;
        unlock_rewards_events: event.EventHandle<vesting.UnlockRewardsEvent>;
        vest_events: event.EventHandle<vesting.VestEvent>;
        distribute_events: event.EventHandle<vesting.DistributeEvent>;
        terminate_events: event.EventHandle<vesting.TerminateEvent>;
        admin_withdraw_events: event.EventHandle<vesting.AdminWithdrawEvent>;
    }
    namespace VestingContract {
        const TYPE_QNAME = "0x1::vesting::VestingContract";
        function type(): TypeDescriptor<VestingContract>;
    }
    interface VestingSchedule {
        schedule: fixed_point32.FixedPoint32[];
        start_timestamp_secs: bigint;
        period_duration: bigint;
        last_vested_period: bigint;
    }
    namespace VestingSchedule {
        const TYPE_QNAME = "0x1::vesting::VestingSchedule";
        function type(): TypeDescriptor<VestingSchedule>;
    }
    interface VestingScheduleInstance extends TypedEventInstance<VestingSchedule> {
        data_decoded: VestingSchedule;
        type_arguments: [];
    }
    namespace entry {
        function adminWithdraw(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function distribute(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function distributeMany(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function resetBeneficiary(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function resetLockup(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiary(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiaryForOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiaryResetter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setManagementRole(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function terminateVestingContract(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlockRewards(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlockRewardsMany(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateCommissionPercentage(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateOperatorWithSameCommission(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function vest(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function vestMany(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function accumulatedRewards(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function beneficiary(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function operator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function operatorCommissionPercentage(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function periodDurationSecs(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function remainingGrant(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function shareholder(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function shareholders(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType[]]>;
        function stakePoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function totalAccumulatedRewards(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function vestingContracts(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType[]]>;
        function vestingSchedule(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[vesting.VestingSchedule]>;
        function vestingStartSecs(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function voter(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
    }
}
export declare namespace bls12381 {
    interface AggrOrMultiSignature {
        bytes: string;
    }
    namespace AggrOrMultiSignature {
        const TYPE_QNAME = "0x1::bls12381::AggrOrMultiSignature";
        function type(): TypeDescriptor<AggrOrMultiSignature>;
    }
    interface AggrOrMultiSignatureInstance extends TypedEventInstance<AggrOrMultiSignature> {
        data_decoded: AggrOrMultiSignature;
        type_arguments: [];
    }
    interface AggrPublicKeysWithPoP {
        bytes: string;
    }
    namespace AggrPublicKeysWithPoP {
        const TYPE_QNAME = "0x1::bls12381::AggrPublicKeysWithPoP";
        function type(): TypeDescriptor<AggrPublicKeysWithPoP>;
    }
    interface AggrPublicKeysWithPoPInstance extends TypedEventInstance<AggrPublicKeysWithPoP> {
        data_decoded: AggrPublicKeysWithPoP;
        type_arguments: [];
    }
    interface ProofOfPossession {
        bytes: string;
    }
    namespace ProofOfPossession {
        const TYPE_QNAME = "0x1::bls12381::ProofOfPossession";
        function type(): TypeDescriptor<ProofOfPossession>;
    }
    interface ProofOfPossessionInstance extends TypedEventInstance<ProofOfPossession> {
        data_decoded: ProofOfPossession;
        type_arguments: [];
    }
    interface PublicKey {
        bytes: string;
    }
    namespace PublicKey {
        const TYPE_QNAME = "0x1::bls12381::PublicKey";
        function type(): TypeDescriptor<PublicKey>;
    }
    interface PublicKeyInstance extends TypedEventInstance<PublicKey> {
        data_decoded: PublicKey;
        type_arguments: [];
    }
    interface PublicKeyWithPoP {
        bytes: string;
    }
    namespace PublicKeyWithPoP {
        const TYPE_QNAME = "0x1::bls12381::PublicKeyWithPoP";
        function type(): TypeDescriptor<PublicKeyWithPoP>;
    }
    interface PublicKeyWithPoPInstance extends TypedEventInstance<PublicKeyWithPoP> {
        data_decoded: PublicKeyWithPoP;
        type_arguments: [];
    }
    interface Signature {
        bytes: string;
    }
    namespace Signature {
        const TYPE_QNAME = "0x1::bls12381::Signature";
        function type(): TypeDescriptor<Signature>;
    }
    interface SignatureInstance extends TypedEventInstance<Signature> {
        data_decoded: Signature;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace chain_id {
    interface ChainId {
        id: number;
    }
    namespace ChainId {
        const TYPE_QNAME = "0x1::chain_id::ChainId";
        function type(): TypeDescriptor<ChainId>;
    }
    namespace entry { }
    namespace view {
        function get(client: Aptos, version?: bigint): Promise<[number]>;
    }
}
export declare namespace features {
    interface Features {
        features: string;
    }
    namespace Features {
        const TYPE_QNAME = "0x1::features::Features";
        function type(): TypeDescriptor<Features>;
    }
    interface PendingFeatures {
        features: string;
    }
    namespace PendingFeatures {
        const TYPE_QNAME = "0x1::features::PendingFeatures";
        function type(): TypeDescriptor<PendingFeatures>;
    }
    namespace entry { }
    namespace view {
        function isEnabled(client: Aptos, request: {
            functionArguments: [bigint];
        }, version?: bigint): Promise<[Boolean]>;
    }
}
export declare namespace from_bcs {
    namespace entry { }
    namespace view { }
}
export declare namespace pool_u64 {
    interface Pool {
        shareholders_limit: bigint;
        total_coins: bigint;
        total_shares: bigint;
        shares: simple_map.SimpleMap<MoveAddressType, bigint>;
        shareholders: MoveAddressType[];
        scaling_factor: bigint;
    }
    namespace Pool {
        const TYPE_QNAME = "0x1::pool_u64::Pool";
        function type(): TypeDescriptor<Pool>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace secp256k1 {
    interface ECDSARawPublicKey {
        bytes: string;
    }
    namespace ECDSARawPublicKey {
        const TYPE_QNAME = "0x1::secp256k1::ECDSARawPublicKey";
        function type(): TypeDescriptor<ECDSARawPublicKey>;
    }
    interface ECDSARawPublicKeyInstance extends TypedEventInstance<ECDSARawPublicKey> {
        data_decoded: ECDSARawPublicKey;
        type_arguments: [];
    }
    interface ECDSASignature {
        bytes: string;
    }
    namespace ECDSASignature {
        const TYPE_QNAME = "0x1::secp256k1::ECDSASignature";
        function type(): TypeDescriptor<ECDSASignature>;
    }
    interface ECDSASignatureInstance extends TypedEventInstance<ECDSASignature> {
        data_decoded: ECDSASignature;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace timestamp {
    interface CurrentTimeMicroseconds {
        microseconds: bigint;
    }
    namespace CurrentTimeMicroseconds {
        const TYPE_QNAME = "0x1::timestamp::CurrentTimeMicroseconds";
        function type(): TypeDescriptor<CurrentTimeMicroseconds>;
    }
    namespace entry { }
    namespace view {
        function nowMicroseconds(client: Aptos, version?: bigint): Promise<[bigint]>;
        function nowSeconds(client: Aptos, version?: bigint): Promise<[bigint]>;
    }
}
export declare namespace type_info {
    interface TypeInfo {
        account_address: MoveAddressType;
        module_name: string;
        struct_name: string;
    }
    namespace TypeInfo {
        const TYPE_QNAME = "0x1::type_info::TypeInfo";
        function type(): TypeDescriptor<TypeInfo>;
    }
    interface TypeInfoInstance extends TypedEventInstance<TypeInfo> {
        data_decoded: TypeInfo;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace aggregator {
    interface Aggregator {
        handle: MoveAddressType;
        key: MoveAddressType;
        limit: bigint;
    }
    namespace Aggregator {
        const TYPE_QNAME = "0x1::aggregator::Aggregator";
        function type(): TypeDescriptor<Aggregator>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace aptos_coin {
    interface AptosCoin {
        dummy_field: Boolean;
    }
    namespace AptosCoin {
        const TYPE_QNAME = "0x1::aptos_coin::AptosCoin";
        function type(): TypeDescriptor<AptosCoin>;
    }
    interface DelegatedMintCapability {
        to: MoveAddressType;
    }
    namespace DelegatedMintCapability {
        const TYPE_QNAME = "0x1::aptos_coin::DelegatedMintCapability";
        function type(): TypeDescriptor<DelegatedMintCapability>;
    }
    interface Delegations {
        inner: aptos_coin.DelegatedMintCapability[];
    }
    namespace Delegations {
        const TYPE_QNAME = "0x1::aptos_coin::Delegations";
        function type(): TypeDescriptor<Delegations>;
    }
    interface MintCapStore {
        mint_cap: coin.MintCapability<aptos_coin.AptosCoin>;
    }
    namespace MintCapStore {
        const TYPE_QNAME = "0x1::aptos_coin::MintCapStore";
        function type(): TypeDescriptor<MintCapStore>;
    }
    namespace entry {
        function claimMintCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function delegateMintCapability(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function mint(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace aptos_hash {
    namespace entry { }
    namespace view { }
}
export declare namespace big_vector {
    interface BigVector<T0> {
        buckets: table_with_length.TableWithLength<bigint, T0[] | string>;
        end_index: bigint;
        bucket_size: bigint;
    }
    namespace BigVector {
        const TYPE_QNAME = "0x1::big_vector::BigVector";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<BigVector<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace bit_vector {
    interface BitVector {
        length: bigint;
        bit_field: Boolean[];
    }
    namespace BitVector {
        const TYPE_QNAME = "0x1::bit_vector::BitVector";
        function type(): TypeDescriptor<BitVector>;
    }
    interface BitVectorInstance extends TypedEventInstance<BitVector> {
        data_decoded: BitVector;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace capability {
    interface Cap<T0> {
        root: MoveAddressType;
    }
    namespace Cap {
        const TYPE_QNAME = "0x1::capability::Cap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Cap<T0>>;
    }
    interface CapDelegateState<T0> {
        root: MoveAddressType;
    }
    namespace CapDelegateState {
        const TYPE_QNAME = "0x1::capability::CapDelegateState";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CapDelegateState<T0>>;
    }
    interface CapState<T0> {
        delegates: MoveAddressType[];
    }
    namespace CapState {
        const TYPE_QNAME = "0x1::capability::CapState";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CapState<T0>>;
    }
    interface LinearCap<T0> {
        root: MoveAddressType;
    }
    namespace LinearCap {
        const TYPE_QNAME = "0x1::capability::LinearCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<LinearCap<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace comparator {
    interface Result {
        inner: number;
    }
    namespace Result {
        const TYPE_QNAME = "0x1::comparator::Result";
        function type(): TypeDescriptor<Result>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace math_fixed {
    namespace entry { }
    namespace view { }
}
export declare namespace randomness {
    interface PerBlockRandomness {
        epoch: bigint;
        round: bigint;
        seed: option.Option<string>;
    }
    namespace PerBlockRandomness {
        const TYPE_QNAME = "0x1::randomness::PerBlockRandomness";
        function type(): TypeDescriptor<PerBlockRandomness>;
    }
    interface RandomnessGeneratedEvent {
        dummy_field: Boolean;
    }
    namespace RandomnessGeneratedEvent {
        const TYPE_QNAME = "0x1::randomness::RandomnessGeneratedEvent";
        function type(): TypeDescriptor<RandomnessGeneratedEvent>;
    }
    interface RandomnessGeneratedEventInstance extends TypedEventInstance<RandomnessGeneratedEvent> {
        data_decoded: RandomnessGeneratedEvent;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace simple_map {
    interface Element<T0, T1> {
        key: T0;
        value: T1;
    }
    namespace Element {
        const TYPE_QNAME = "0x1::simple_map::Element";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Element<T0, T1>>;
    }
    interface ElementInstance extends TypedEventInstance<Element<any, any>> {
        data_decoded: Element<any, any>;
        type_arguments: [string, string];
    }
    interface SimpleMap<T0, T1> {
        data: simple_map.Element<T0, T1>[];
    }
    namespace SimpleMap {
        const TYPE_QNAME = "0x1::simple_map::SimpleMap";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<SimpleMap<T0, T1>>;
    }
    interface SimpleMapInstance extends TypedEventInstance<SimpleMap<any, any>> {
        data_decoded: SimpleMap<any, any>;
        type_arguments: [string, string];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace smart_table {
    interface Entry<T0, T1> {
        hash: bigint;
        key: T0;
        value: T1;
    }
    namespace Entry {
        const TYPE_QNAME = "0x1::smart_table::Entry";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Entry<T0, T1>>;
    }
    interface EntryInstance extends TypedEventInstance<Entry<any, any>> {
        data_decoded: Entry<any, any>;
        type_arguments: [string, string];
    }
    interface SmartTable<T0, T1> {
        buckets: table_with_length.TableWithLength<bigint, smart_table.Entry<T0, T1>[]>;
        num_buckets: bigint;
        level: number;
        size: bigint;
        split_load_threshold: number;
        target_bucket_size: bigint;
    }
    namespace SmartTable {
        const TYPE_QNAME = "0x1::smart_table::SmartTable";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<SmartTable<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace storage_gas {
    interface GasCurve {
        min_gas: bigint;
        max_gas: bigint;
        points: storage_gas.Point[];
    }
    namespace GasCurve {
        const TYPE_QNAME = "0x1::storage_gas::GasCurve";
        function type(): TypeDescriptor<GasCurve>;
    }
    interface GasCurveInstance extends TypedEventInstance<GasCurve> {
        data_decoded: GasCurve;
        type_arguments: [];
    }
    interface Point {
        x: bigint;
        y: bigint;
    }
    namespace Point {
        const TYPE_QNAME = "0x1::storage_gas::Point";
        function type(): TypeDescriptor<Point>;
    }
    interface PointInstance extends TypedEventInstance<Point> {
        data_decoded: Point;
        type_arguments: [];
    }
    interface StorageGas {
        per_item_read: bigint;
        per_item_create: bigint;
        per_item_write: bigint;
        per_byte_read: bigint;
        per_byte_create: bigint;
        per_byte_write: bigint;
    }
    namespace StorageGas {
        const TYPE_QNAME = "0x1::storage_gas::StorageGas";
        function type(): TypeDescriptor<StorageGas>;
    }
    interface StorageGasConfig {
        item_config: storage_gas.UsageGasConfig;
        byte_config: storage_gas.UsageGasConfig;
    }
    namespace StorageGasConfig {
        const TYPE_QNAME = "0x1::storage_gas::StorageGasConfig";
        function type(): TypeDescriptor<StorageGasConfig>;
    }
    interface UsageGasConfig {
        target_usage: bigint;
        read_curve: storage_gas.GasCurve;
        create_curve: storage_gas.GasCurve;
        write_curve: storage_gas.GasCurve;
    }
    namespace UsageGasConfig {
        const TYPE_QNAME = "0x1::storage_gas::UsageGasConfig";
        function type(): TypeDescriptor<UsageGasConfig>;
    }
    interface UsageGasConfigInstance extends TypedEventInstance<UsageGasConfig> {
        data_decoded: UsageGasConfig;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace chain_status {
    interface GenesisEndMarker {
        dummy_field: Boolean;
    }
    namespace GenesisEndMarker {
        const TYPE_QNAME = "0x1::chain_status::GenesisEndMarker";
        function type(): TypeDescriptor<GenesisEndMarker>;
    }
    namespace entry { }
    namespace view {
        function isGenesis(client: Aptos, version?: bigint): Promise<[Boolean]>;
        function isOperating(client: Aptos, version?: bigint): Promise<[Boolean]>;
    }
}
export declare namespace copyable_any {
    interface Any {
        type_name: string;
        data: string;
    }
    namespace Any {
        const TYPE_QNAME = "0x1::copyable_any::Any";
        function type(): TypeDescriptor<Any>;
    }
    interface AnyInstance extends TypedEventInstance<Any> {
        data_decoded: Any;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace gas_schedule {
    interface GasEntry {
        key: string;
        val: bigint;
    }
    namespace GasEntry {
        const TYPE_QNAME = "0x1::gas_schedule::GasEntry";
        function type(): TypeDescriptor<GasEntry>;
    }
    interface GasEntryInstance extends TypedEventInstance<GasEntry> {
        data_decoded: GasEntry;
        type_arguments: [];
    }
    interface GasSchedule {
        entries: gas_schedule.GasEntry[];
    }
    namespace GasSchedule {
        const TYPE_QNAME = "0x1::gas_schedule::GasSchedule";
        function type(): TypeDescriptor<GasSchedule>;
    }
    interface GasScheduleV2 {
        feature_version: bigint;
        entries: gas_schedule.GasEntry[];
    }
    namespace GasScheduleV2 {
        const TYPE_QNAME = "0x1::gas_schedule::GasScheduleV2";
        function type(): TypeDescriptor<GasScheduleV2>;
    }
    interface GasScheduleV2Instance extends TypedEventInstance<GasScheduleV2> {
        data_decoded: GasScheduleV2;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace managed_coin {
    interface Capabilities<T0> {
        burn_cap: coin.BurnCapability<T0>;
        freeze_cap: coin.FreezeCapability<T0>;
        mint_cap: coin.MintCapability<T0>;
    }
    namespace Capabilities {
        const TYPE_QNAME = "0x1::managed_coin::Capabilities";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Capabilities<T0>>;
    }
    namespace entry {
        function burn<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function initialize<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [string, string, number, Boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function mint<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function register<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace math_fixed64 {
    namespace entry { }
    namespace view { }
}
export declare namespace ristretto255 {
    interface CompressedRistretto {
        data: string;
    }
    namespace CompressedRistretto {
        const TYPE_QNAME = "0x1::ristretto255::CompressedRistretto";
        function type(): TypeDescriptor<CompressedRistretto>;
    }
    interface CompressedRistrettoInstance extends TypedEventInstance<CompressedRistretto> {
        data_decoded: CompressedRistretto;
        type_arguments: [];
    }
    interface RistrettoPoint {
        handle: bigint;
    }
    namespace RistrettoPoint {
        const TYPE_QNAME = "0x1::ristretto255::RistrettoPoint";
        function type(): TypeDescriptor<RistrettoPoint>;
    }
    interface Scalar {
        data: string;
    }
    namespace Scalar {
        const TYPE_QNAME = "0x1::ristretto255::Scalar";
        function type(): TypeDescriptor<Scalar>;
    }
    interface ScalarInstance extends TypedEventInstance<Scalar> {
        data_decoded: Scalar;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace smart_vector {
    interface SmartVector<T0> {
        inline_vec: T0[] | string;
        big_vec: option.Option<big_vector.BigVector<T0>>;
        inline_capacity: option.Option<bigint>;
        bucket_size: option.Option<bigint>;
    }
    namespace SmartVector {
        const TYPE_QNAME = "0x1::smart_vector::SmartVector";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<SmartVector<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace string_utils {
    interface Cons<T0, T1> {
        car: T0;
        cdr: T1;
    }
    namespace Cons {
        const TYPE_QNAME = "0x1::string_utils::Cons";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Cons<T0, T1>>;
    }
    interface ConsInstance extends TypedEventInstance<Cons<any, any>> {
        data_decoded: Cons<any, any>;
        type_arguments: [string, string];
    }
    interface FakeCons<T0, T1> {
        car: T0;
        cdr: T1;
    }
    namespace FakeCons {
        const TYPE_QNAME = "0x1::string_utils::FakeCons";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<FakeCons<T0, T1>>;
    }
    interface FakeConsInstance extends TypedEventInstance<FakeCons<any, any>> {
        data_decoded: FakeCons<any, any>;
        type_arguments: [string, string];
    }
    interface NIL {
        dummy_field: Boolean;
    }
    namespace NIL {
        const TYPE_QNAME = "0x1::string_utils::NIL";
        function type(): TypeDescriptor<NIL>;
    }
    interface NILInstance extends TypedEventInstance<NIL> {
        data_decoded: NIL;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace aggregator_v2 {
    interface Aggregator<T0> {
        value: T0;
        max_value: T0;
    }
    namespace Aggregator {
        const TYPE_QNAME = "0x1::aggregator_v2::Aggregator";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Aggregator<T0>>;
    }
    interface AggregatorInstance extends TypedEventInstance<Aggregator<any>> {
        data_decoded: Aggregator<any>;
        type_arguments: [string];
    }
    interface AggregatorSnapshot<T0> {
        value: T0;
    }
    namespace AggregatorSnapshot {
        const TYPE_QNAME = "0x1::aggregator_v2::AggregatorSnapshot";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<AggregatorSnapshot<T0>>;
    }
    interface AggregatorSnapshotInstance extends TypedEventInstance<AggregatorSnapshot<any>> {
        data_decoded: AggregatorSnapshot<any>;
        type_arguments: [string];
    }
    interface DerivedStringSnapshot {
        value: string;
        padding: string;
    }
    namespace DerivedStringSnapshot {
        const TYPE_QNAME = "0x1::aggregator_v2::DerivedStringSnapshot";
        function type(): TypeDescriptor<DerivedStringSnapshot>;
    }
    interface DerivedStringSnapshotInstance extends TypedEventInstance<DerivedStringSnapshot> {
        data_decoded: DerivedStringSnapshot;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace aptos_account {
    interface DirectCoinTransferConfigUpdated {
        account: MoveAddressType;
        new_allow_direct_transfers: Boolean;
    }
    namespace DirectCoinTransferConfigUpdated {
        const TYPE_QNAME = "0x1::aptos_account::DirectCoinTransferConfigUpdated";
        function type(): TypeDescriptor<DirectCoinTransferConfigUpdated>;
    }
    interface DirectCoinTransferConfigUpdatedInstance extends TypedEventInstance<DirectCoinTransferConfigUpdated> {
        data_decoded: DirectCoinTransferConfigUpdated;
        type_arguments: [];
    }
    interface DirectCoinTransferConfigUpdatedEvent {
        new_allow_direct_transfers: Boolean;
    }
    namespace DirectCoinTransferConfigUpdatedEvent {
        const TYPE_QNAME = "0x1::aptos_account::DirectCoinTransferConfigUpdatedEvent";
        function type(): TypeDescriptor<DirectCoinTransferConfigUpdatedEvent>;
    }
    interface DirectCoinTransferConfigUpdatedEventInstance extends TypedEventInstance<DirectCoinTransferConfigUpdatedEvent> {
        data_decoded: DirectCoinTransferConfigUpdatedEvent;
        type_arguments: [];
    }
    interface DirectTransferConfig {
        allow_arbitrary_coin_transfers: Boolean;
        update_coin_transfer_events: event.EventHandle<aptos_account.DirectCoinTransferConfigUpdatedEvent>;
    }
    namespace DirectTransferConfig {
        const TYPE_QNAME = "0x1::aptos_account::DirectTransferConfig";
        function type(): TypeDescriptor<DirectTransferConfig>;
    }
    namespace entry {
        function batchTransfer(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchTransferCoins<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType[], bigint[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createAccount(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setAllowDirectCoinTransfers(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [Boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transfer(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferCoins<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function canReceiveDirectCoinTransfers(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
    }
}
export declare namespace bn254_algebra {
    interface FormatFq12LscLsb {
        dummy_field: Boolean;
    }
    namespace FormatFq12LscLsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFq12LscLsb";
        function type(): TypeDescriptor<FormatFq12LscLsb>;
    }
    interface FormatFqLsb {
        dummy_field: Boolean;
    }
    namespace FormatFqLsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFqLsb";
        function type(): TypeDescriptor<FormatFqLsb>;
    }
    interface FormatFqMsb {
        dummy_field: Boolean;
    }
    namespace FormatFqMsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFqMsb";
        function type(): TypeDescriptor<FormatFqMsb>;
    }
    interface FormatFrLsb {
        dummy_field: Boolean;
    }
    namespace FormatFrLsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFrLsb";
        function type(): TypeDescriptor<FormatFrLsb>;
    }
    interface FormatFrMsb {
        dummy_field: Boolean;
    }
    namespace FormatFrMsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFrMsb";
        function type(): TypeDescriptor<FormatFrMsb>;
    }
    interface FormatG1Compr {
        dummy_field: Boolean;
    }
    namespace FormatG1Compr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG1Compr";
        function type(): TypeDescriptor<FormatG1Compr>;
    }
    interface FormatG1Uncompr {
        dummy_field: Boolean;
    }
    namespace FormatG1Uncompr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG1Uncompr";
        function type(): TypeDescriptor<FormatG1Uncompr>;
    }
    interface FormatG2Compr {
        dummy_field: Boolean;
    }
    namespace FormatG2Compr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG2Compr";
        function type(): TypeDescriptor<FormatG2Compr>;
    }
    interface FormatG2Uncompr {
        dummy_field: Boolean;
    }
    namespace FormatG2Uncompr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG2Uncompr";
        function type(): TypeDescriptor<FormatG2Uncompr>;
    }
    interface FormatGt {
        dummy_field: Boolean;
    }
    namespace FormatGt {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatGt";
        function type(): TypeDescriptor<FormatGt>;
    }
    interface Fq {
        dummy_field: Boolean;
    }
    namespace Fq {
        const TYPE_QNAME = "0x1::bn254_algebra::Fq";
        function type(): TypeDescriptor<Fq>;
    }
    interface Fq12 {
        dummy_field: Boolean;
    }
    namespace Fq12 {
        const TYPE_QNAME = "0x1::bn254_algebra::Fq12";
        function type(): TypeDescriptor<Fq12>;
    }
    interface Fr {
        dummy_field: Boolean;
    }
    namespace Fr {
        const TYPE_QNAME = "0x1::bn254_algebra::Fr";
        function type(): TypeDescriptor<Fr>;
    }
    interface G1 {
        dummy_field: Boolean;
    }
    namespace G1 {
        const TYPE_QNAME = "0x1::bn254_algebra::G1";
        function type(): TypeDescriptor<G1>;
    }
    interface G2 {
        dummy_field: Boolean;
    }
    namespace G2 {
        const TYPE_QNAME = "0x1::bn254_algebra::G2";
        function type(): TypeDescriptor<G2>;
    }
    interface Gt {
        dummy_field: Boolean;
    }
    namespace Gt {
        const TYPE_QNAME = "0x1::bn254_algebra::Gt";
        function type(): TypeDescriptor<Gt>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace config_buffer {
    interface PendingConfigs {
        configs: simple_map.SimpleMap<string, any_.Any>;
    }
    namespace PendingConfigs {
        const TYPE_QNAME = "0x1::config_buffer::PendingConfigs";
        function type(): TypeDescriptor<PendingConfigs>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace create_signer {
    namespace entry { }
    namespace view { }
}
export declare namespace fixed_point32 {
    interface FixedPoint32 {
        value: bigint;
    }
    namespace FixedPoint32 {
        const TYPE_QNAME = "0x1::fixed_point32::FixedPoint32";
        function type(): TypeDescriptor<FixedPoint32>;
    }
    interface FixedPoint32Instance extends TypedEventInstance<FixedPoint32> {
        data_decoded: FixedPoint32;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace fixed_point64 {
    interface FixedPoint64 {
        value: bigint;
    }
    namespace FixedPoint64 {
        const TYPE_QNAME = "0x1::fixed_point64::FixedPoint64";
        function type(): TypeDescriptor<FixedPoint64>;
    }
    interface FixedPoint64Instance extends TypedEventInstance<FixedPoint64> {
        data_decoded: FixedPoint64;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace function_info {
    interface FunctionInfo {
        module_address: MoveAddressType;
        module_name: string;
        function_name: string;
    }
    namespace FunctionInfo {
        const TYPE_QNAME = "0x1::function_info::FunctionInfo";
        function type(): TypeDescriptor<FunctionInfo>;
    }
    interface FunctionInfoInstance extends TypedEventInstance<FunctionInfo> {
        data_decoded: FunctionInfo;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace multi_ed25519 {
    interface Signature {
        bytes: string;
    }
    namespace Signature {
        const TYPE_QNAME = "0x1::multi_ed25519::Signature";
        function type(): TypeDescriptor<Signature>;
    }
    interface SignatureInstance extends TypedEventInstance<Signature> {
        data_decoded: Signature;
        type_arguments: [];
    }
    interface UnvalidatedPublicKey {
        bytes: string;
    }
    namespace UnvalidatedPublicKey {
        const TYPE_QNAME = "0x1::multi_ed25519::UnvalidatedPublicKey";
        function type(): TypeDescriptor<UnvalidatedPublicKey>;
    }
    interface UnvalidatedPublicKeyInstance extends TypedEventInstance<UnvalidatedPublicKey> {
        data_decoded: UnvalidatedPublicKey;
        type_arguments: [];
    }
    interface ValidatedPublicKey {
        bytes: string;
    }
    namespace ValidatedPublicKey {
        const TYPE_QNAME = "0x1::multi_ed25519::ValidatedPublicKey";
        function type(): TypeDescriptor<ValidatedPublicKey>;
    }
    interface ValidatedPublicKeyInstance extends TypedEventInstance<ValidatedPublicKey> {
        data_decoded: ValidatedPublicKey;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace staking_proxy {
    namespace entry {
        function setOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setStakePoolOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setStakePoolVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setStakingContractOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setStakingContractVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setVestingContractOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setVestingContractVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace state_storage {
    interface GasParameter {
        usage: state_storage.Usage;
    }
    namespace GasParameter {
        const TYPE_QNAME = "0x1::state_storage::GasParameter";
        function type(): TypeDescriptor<GasParameter>;
    }
    interface StateStorageUsage {
        epoch: bigint;
        usage: state_storage.Usage;
    }
    namespace StateStorageUsage {
        const TYPE_QNAME = "0x1::state_storage::StateStorageUsage";
        function type(): TypeDescriptor<StateStorageUsage>;
    }
    interface Usage {
        items: bigint;
        bytes: bigint;
    }
    namespace Usage {
        const TYPE_QNAME = "0x1::state_storage::Usage";
        function type(): TypeDescriptor<Usage>;
    }
    interface UsageInstance extends TypedEventInstance<Usage> {
        data_decoded: Usage;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace crypto_algebra {
    interface Element<T0> {
        handle: bigint;
    }
    namespace Element {
        const TYPE_QNAME = "0x1::crypto_algebra::Element";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Element<T0>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace fungible_asset {
    interface BurnRef {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace BurnRef {
        const TYPE_QNAME = "0x1::fungible_asset::BurnRef";
        function type(): TypeDescriptor<BurnRef>;
    }
    interface BurnRefInstance extends TypedEventInstance<BurnRef> {
        data_decoded: BurnRef;
        type_arguments: [];
    }
    interface ConcurrentFungibleBalance {
        balance: aggregator_v2.Aggregator<bigint>;
    }
    namespace ConcurrentFungibleBalance {
        const TYPE_QNAME = "0x1::fungible_asset::ConcurrentFungibleBalance";
        function type(): TypeDescriptor<ConcurrentFungibleBalance>;
    }
    interface ConcurrentSupply {
        current: aggregator_v2.Aggregator<bigint>;
    }
    namespace ConcurrentSupply {
        const TYPE_QNAME = "0x1::fungible_asset::ConcurrentSupply";
        function type(): TypeDescriptor<ConcurrentSupply>;
    }
    interface Deposit {
        store: MoveAddressType;
        amount: bigint;
    }
    namespace Deposit {
        const TYPE_QNAME = "0x1::fungible_asset::Deposit";
        function type(): TypeDescriptor<Deposit>;
    }
    interface DepositInstance extends TypedEventInstance<Deposit> {
        data_decoded: Deposit;
        type_arguments: [];
    }
    interface DepositEvent {
        amount: bigint;
    }
    namespace DepositEvent {
        const TYPE_QNAME = "0x1::fungible_asset::DepositEvent";
        function type(): TypeDescriptor<DepositEvent>;
    }
    interface DepositEventInstance extends TypedEventInstance<DepositEvent> {
        data_decoded: DepositEvent;
        type_arguments: [];
    }
    interface DeriveSupply {
        dispatch_function: option.Option<function_info.FunctionInfo>;
    }
    namespace DeriveSupply {
        const TYPE_QNAME = "0x1::fungible_asset::DeriveSupply";
        function type(): TypeDescriptor<DeriveSupply>;
    }
    interface DispatchFunctionStore {
        withdraw_function: option.Option<function_info.FunctionInfo>;
        deposit_function: option.Option<function_info.FunctionInfo>;
        derived_balance_function: option.Option<function_info.FunctionInfo>;
    }
    namespace DispatchFunctionStore {
        const TYPE_QNAME = "0x1::fungible_asset::DispatchFunctionStore";
        function type(): TypeDescriptor<DispatchFunctionStore>;
    }
    interface Frozen {
        store: MoveAddressType;
        frozen: Boolean;
    }
    namespace Frozen {
        const TYPE_QNAME = "0x1::fungible_asset::Frozen";
        function type(): TypeDescriptor<Frozen>;
    }
    interface FrozenInstance extends TypedEventInstance<Frozen> {
        data_decoded: Frozen;
        type_arguments: [];
    }
    interface FrozenEvent {
        frozen: Boolean;
    }
    namespace FrozenEvent {
        const TYPE_QNAME = "0x1::fungible_asset::FrozenEvent";
        function type(): TypeDescriptor<FrozenEvent>;
    }
    interface FrozenEventInstance extends TypedEventInstance<FrozenEvent> {
        data_decoded: FrozenEvent;
        type_arguments: [];
    }
    interface FungibleAsset {
        metadata: object_.Object<fungible_asset.Metadata>;
        amount: bigint;
    }
    namespace FungibleAsset {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleAsset";
        function type(): TypeDescriptor<FungibleAsset>;
    }
    interface FungibleAssetEvents {
        deposit_events: event.EventHandle<fungible_asset.DepositEvent>;
        withdraw_events: event.EventHandle<fungible_asset.WithdrawEvent>;
        frozen_events: event.EventHandle<fungible_asset.FrozenEvent>;
    }
    namespace FungibleAssetEvents {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleAssetEvents";
        function type(): TypeDescriptor<FungibleAssetEvents>;
    }
    interface FungibleStore {
        metadata: object_.Object<fungible_asset.Metadata>;
        balance: bigint;
        frozen: Boolean;
    }
    namespace FungibleStore {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleStore";
        function type(): TypeDescriptor<FungibleStore>;
    }
    interface Metadata {
        name: string;
        symbol: string;
        decimals: number;
        icon_uri: string;
        project_uri: string;
    }
    namespace Metadata {
        const TYPE_QNAME = "0x1::fungible_asset::Metadata";
        function type(): TypeDescriptor<Metadata>;
    }
    interface MintRef {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace MintRef {
        const TYPE_QNAME = "0x1::fungible_asset::MintRef";
        function type(): TypeDescriptor<MintRef>;
    }
    interface MintRefInstance extends TypedEventInstance<MintRef> {
        data_decoded: MintRef;
        type_arguments: [];
    }
    interface MutateMetadataRef {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace MutateMetadataRef {
        const TYPE_QNAME = "0x1::fungible_asset::MutateMetadataRef";
        function type(): TypeDescriptor<MutateMetadataRef>;
    }
    interface MutateMetadataRefInstance extends TypedEventInstance<MutateMetadataRef> {
        data_decoded: MutateMetadataRef;
        type_arguments: [];
    }
    interface Supply {
        current: bigint;
        maximum: option.Option<bigint>;
    }
    namespace Supply {
        const TYPE_QNAME = "0x1::fungible_asset::Supply";
        function type(): TypeDescriptor<Supply>;
    }
    interface TransferRef {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace TransferRef {
        const TYPE_QNAME = "0x1::fungible_asset::TransferRef";
        function type(): TypeDescriptor<TransferRef>;
    }
    interface TransferRefInstance extends TypedEventInstance<TransferRef> {
        data_decoded: TransferRef;
        type_arguments: [];
    }
    interface Untransferable {
        dummy_field: Boolean;
    }
    namespace Untransferable {
        const TYPE_QNAME = "0x1::fungible_asset::Untransferable";
        function type(): TypeDescriptor<Untransferable>;
    }
    interface Withdraw {
        store: MoveAddressType;
        amount: bigint;
    }
    namespace Withdraw {
        const TYPE_QNAME = "0x1::fungible_asset::Withdraw";
        function type(): TypeDescriptor<Withdraw>;
    }
    interface WithdrawInstance extends TypedEventInstance<Withdraw> {
        data_decoded: Withdraw;
        type_arguments: [];
    }
    interface WithdrawEvent {
        amount: bigint;
    }
    namespace WithdrawEvent {
        const TYPE_QNAME = "0x1::fungible_asset::WithdrawEvent";
        function type(): TypeDescriptor<WithdrawEvent>;
    }
    interface WithdrawEventInstance extends TypedEventInstance<WithdrawEvent> {
        data_decoded: WithdrawEvent;
        type_arguments: [];
    }
    namespace entry {
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>, object_.Object<T0>, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function upgradeStoreToConcurrent<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function balance<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[bigint]>;
        function decimals<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[number]>;
        function iconUri<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function isBalanceAtLeast<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>, bigint];
        }, version?: bigint): Promise<[Boolean]>;
        function isFrozen<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
        function isStoreDispatchable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
        function isUntransferable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
        function maximum<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function metadata<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[fungible_asset.Metadata]>;
        function name<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function projectUri<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function storeExists(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function storeMetadata<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[object_.Object<fungible_asset.Metadata>]>;
        function supply<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
        function symbol<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[string]>;
    }
}
export declare namespace staking_config {
    interface StakingConfig {
        minimum_stake: bigint;
        maximum_stake: bigint;
        recurring_lockup_duration_secs: bigint;
        allow_validator_set_change: Boolean;
        rewards_rate: bigint;
        rewards_rate_denominator: bigint;
        voting_power_increase_limit: bigint;
    }
    namespace StakingConfig {
        const TYPE_QNAME = "0x1::staking_config::StakingConfig";
        function type(): TypeDescriptor<StakingConfig>;
    }
    interface StakingRewardsConfig {
        rewards_rate: fixed_point64.FixedPoint64;
        min_rewards_rate: fixed_point64.FixedPoint64;
        rewards_rate_period_in_secs: bigint;
        last_rewards_rate_period_start_in_secs: bigint;
        rewards_rate_decrease_rate: fixed_point64.FixedPoint64;
    }
    namespace StakingRewardsConfig {
        const TYPE_QNAME = "0x1::staking_config::StakingRewardsConfig";
        function type(): TypeDescriptor<StakingRewardsConfig>;
    }
    namespace entry { }
    namespace view {
        function rewardRate(client: Aptos, version?: bigint): Promise<[bigint, bigint]>;
    }
}
export declare namespace delegation_pool {
    interface AddStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_added: bigint;
        add_stake_fee: bigint;
    }
    namespace AddStake {
        const TYPE_QNAME = "0x1::delegation_pool::AddStake";
        function type(): TypeDescriptor<AddStake>;
    }
    interface AddStakeInstance extends TypedEventInstance<AddStake> {
        data_decoded: AddStake;
        type_arguments: [];
    }
    interface AddStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_added: bigint;
        add_stake_fee: bigint;
    }
    namespace AddStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::AddStakeEvent";
        function type(): TypeDescriptor<AddStakeEvent>;
    }
    interface AddStakeEventInstance extends TypedEventInstance<AddStakeEvent> {
        data_decoded: AddStakeEvent;
        type_arguments: [];
    }
    interface AllowlistDelegator {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
    }
    namespace AllowlistDelegator {
        const TYPE_QNAME = "0x1::delegation_pool::AllowlistDelegator";
        function type(): TypeDescriptor<AllowlistDelegator>;
    }
    interface AllowlistDelegatorInstance extends TypedEventInstance<AllowlistDelegator> {
        data_decoded: AllowlistDelegator;
        type_arguments: [];
    }
    interface BeneficiaryForOperator {
        beneficiary_for_operator: MoveAddressType;
    }
    namespace BeneficiaryForOperator {
        const TYPE_QNAME = "0x1::delegation_pool::BeneficiaryForOperator";
        function type(): TypeDescriptor<BeneficiaryForOperator>;
    }
    interface CommissionPercentageChange {
        pool_address: MoveAddressType;
        owner: MoveAddressType;
        commission_percentage_next_lockup_cycle: bigint;
    }
    namespace CommissionPercentageChange {
        const TYPE_QNAME = "0x1::delegation_pool::CommissionPercentageChange";
        function type(): TypeDescriptor<CommissionPercentageChange>;
    }
    interface CommissionPercentageChangeInstance extends TypedEventInstance<CommissionPercentageChange> {
        data_decoded: CommissionPercentageChange;
        type_arguments: [];
    }
    interface CreateProposal {
        proposal_id: bigint;
        voter: MoveAddressType;
        delegation_pool: MoveAddressType;
    }
    namespace CreateProposal {
        const TYPE_QNAME = "0x1::delegation_pool::CreateProposal";
        function type(): TypeDescriptor<CreateProposal>;
    }
    interface CreateProposalInstance extends TypedEventInstance<CreateProposal> {
        data_decoded: CreateProposal;
        type_arguments: [];
    }
    interface CreateProposalEvent {
        proposal_id: bigint;
        voter: MoveAddressType;
        delegation_pool: MoveAddressType;
    }
    namespace CreateProposalEvent {
        const TYPE_QNAME = "0x1::delegation_pool::CreateProposalEvent";
        function type(): TypeDescriptor<CreateProposalEvent>;
    }
    interface CreateProposalEventInstance extends TypedEventInstance<CreateProposalEvent> {
        data_decoded: CreateProposalEvent;
        type_arguments: [];
    }
    interface DelegateVotingPower {
        pool_address: MoveAddressType;
        delegator: MoveAddressType;
        voter: MoveAddressType;
    }
    namespace DelegateVotingPower {
        const TYPE_QNAME = "0x1::delegation_pool::DelegateVotingPower";
        function type(): TypeDescriptor<DelegateVotingPower>;
    }
    interface DelegateVotingPowerInstance extends TypedEventInstance<DelegateVotingPower> {
        data_decoded: DelegateVotingPower;
        type_arguments: [];
    }
    interface DelegateVotingPowerEvent {
        pool_address: MoveAddressType;
        delegator: MoveAddressType;
        voter: MoveAddressType;
    }
    namespace DelegateVotingPowerEvent {
        const TYPE_QNAME = "0x1::delegation_pool::DelegateVotingPowerEvent";
        function type(): TypeDescriptor<DelegateVotingPowerEvent>;
    }
    interface DelegateVotingPowerEventInstance extends TypedEventInstance<DelegateVotingPowerEvent> {
        data_decoded: DelegateVotingPowerEvent;
        type_arguments: [];
    }
    interface DelegatedVotes {
        active_shares: bigint;
        pending_inactive_shares: bigint;
        active_shares_next_lockup: bigint;
        last_locked_until_secs: bigint;
    }
    namespace DelegatedVotes {
        const TYPE_QNAME = "0x1::delegation_pool::DelegatedVotes";
        function type(): TypeDescriptor<DelegatedVotes>;
    }
    interface DelegatedVotesInstance extends TypedEventInstance<DelegatedVotes> {
        data_decoded: DelegatedVotes;
        type_arguments: [];
    }
    interface DelegationPool {
        active_shares: pool_u64_unbound.Pool;
        observed_lockup_cycle: delegation_pool.ObservedLockupCycle;
        inactive_shares: table.Table<delegation_pool.ObservedLockupCycle, pool_u64_unbound.Pool>;
        pending_withdrawals: table.Table<MoveAddressType, delegation_pool.ObservedLockupCycle>;
        stake_pool_signer_cap: account.SignerCapability;
        total_coins_inactive: bigint;
        operator_commission_percentage: bigint;
        add_stake_events: event.EventHandle<delegation_pool.AddStakeEvent>;
        reactivate_stake_events: event.EventHandle<delegation_pool.ReactivateStakeEvent>;
        unlock_stake_events: event.EventHandle<delegation_pool.UnlockStakeEvent>;
        withdraw_stake_events: event.EventHandle<delegation_pool.WithdrawStakeEvent>;
        distribute_commission_events: event.EventHandle<delegation_pool.DistributeCommissionEvent>;
    }
    namespace DelegationPool {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPool";
        function type(): TypeDescriptor<DelegationPool>;
    }
    interface DelegationPoolAllowlisting {
        allowlist: smart_table.SmartTable<MoveAddressType, Boolean>;
    }
    namespace DelegationPoolAllowlisting {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPoolAllowlisting";
        function type(): TypeDescriptor<DelegationPoolAllowlisting>;
    }
    interface DelegationPoolOwnership {
        pool_address: MoveAddressType;
    }
    namespace DelegationPoolOwnership {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPoolOwnership";
        function type(): TypeDescriptor<DelegationPoolOwnership>;
    }
    interface DisableDelegatorsAllowlisting {
        pool_address: MoveAddressType;
    }
    namespace DisableDelegatorsAllowlisting {
        const TYPE_QNAME = "0x1::delegation_pool::DisableDelegatorsAllowlisting";
        function type(): TypeDescriptor<DisableDelegatorsAllowlisting>;
    }
    interface DisableDelegatorsAllowlistingInstance extends TypedEventInstance<DisableDelegatorsAllowlisting> {
        data_decoded: DisableDelegatorsAllowlisting;
        type_arguments: [];
    }
    interface DistributeCommission {
        pool_address: MoveAddressType;
        operator: MoveAddressType;
        beneficiary: MoveAddressType;
        commission_active: bigint;
        commission_pending_inactive: bigint;
    }
    namespace DistributeCommission {
        const TYPE_QNAME = "0x1::delegation_pool::DistributeCommission";
        function type(): TypeDescriptor<DistributeCommission>;
    }
    interface DistributeCommissionInstance extends TypedEventInstance<DistributeCommission> {
        data_decoded: DistributeCommission;
        type_arguments: [];
    }
    interface DistributeCommissionEvent {
        pool_address: MoveAddressType;
        operator: MoveAddressType;
        commission_active: bigint;
        commission_pending_inactive: bigint;
    }
    namespace DistributeCommissionEvent {
        const TYPE_QNAME = "0x1::delegation_pool::DistributeCommissionEvent";
        function type(): TypeDescriptor<DistributeCommissionEvent>;
    }
    interface DistributeCommissionEventInstance extends TypedEventInstance<DistributeCommissionEvent> {
        data_decoded: DistributeCommissionEvent;
        type_arguments: [];
    }
    interface EnableDelegatorsAllowlisting {
        pool_address: MoveAddressType;
    }
    namespace EnableDelegatorsAllowlisting {
        const TYPE_QNAME = "0x1::delegation_pool::EnableDelegatorsAllowlisting";
        function type(): TypeDescriptor<EnableDelegatorsAllowlisting>;
    }
    interface EnableDelegatorsAllowlistingInstance extends TypedEventInstance<EnableDelegatorsAllowlisting> {
        data_decoded: EnableDelegatorsAllowlisting;
        type_arguments: [];
    }
    interface EvictDelegator {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
    }
    namespace EvictDelegator {
        const TYPE_QNAME = "0x1::delegation_pool::EvictDelegator";
        function type(): TypeDescriptor<EvictDelegator>;
    }
    interface EvictDelegatorInstance extends TypedEventInstance<EvictDelegator> {
        data_decoded: EvictDelegator;
        type_arguments: [];
    }
    interface GovernanceRecords {
        votes: smart_table.SmartTable<delegation_pool.VotingRecordKey, bigint>;
        votes_per_proposal: smart_table.SmartTable<bigint, bigint>;
        vote_delegation: smart_table.SmartTable<MoveAddressType, delegation_pool.VoteDelegation>;
        delegated_votes: smart_table.SmartTable<MoveAddressType, delegation_pool.DelegatedVotes>;
        vote_events: event.EventHandle<delegation_pool.VoteEvent>;
        create_proposal_events: event.EventHandle<delegation_pool.CreateProposalEvent>;
        delegate_voting_power_events: event.EventHandle<delegation_pool.DelegateVotingPowerEvent>;
    }
    namespace GovernanceRecords {
        const TYPE_QNAME = "0x1::delegation_pool::GovernanceRecords";
        function type(): TypeDescriptor<GovernanceRecords>;
    }
    interface NextCommissionPercentage {
        commission_percentage_next_lockup_cycle: bigint;
        effective_after_secs: bigint;
    }
    namespace NextCommissionPercentage {
        const TYPE_QNAME = "0x1::delegation_pool::NextCommissionPercentage";
        function type(): TypeDescriptor<NextCommissionPercentage>;
    }
    interface ObservedLockupCycle {
        index: bigint;
    }
    namespace ObservedLockupCycle {
        const TYPE_QNAME = "0x1::delegation_pool::ObservedLockupCycle";
        function type(): TypeDescriptor<ObservedLockupCycle>;
    }
    interface ObservedLockupCycleInstance extends TypedEventInstance<ObservedLockupCycle> {
        data_decoded: ObservedLockupCycle;
        type_arguments: [];
    }
    interface ReactivateStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_reactivated: bigint;
    }
    namespace ReactivateStake {
        const TYPE_QNAME = "0x1::delegation_pool::ReactivateStake";
        function type(): TypeDescriptor<ReactivateStake>;
    }
    interface ReactivateStakeInstance extends TypedEventInstance<ReactivateStake> {
        data_decoded: ReactivateStake;
        type_arguments: [];
    }
    interface ReactivateStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_reactivated: bigint;
    }
    namespace ReactivateStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::ReactivateStakeEvent";
        function type(): TypeDescriptor<ReactivateStakeEvent>;
    }
    interface ReactivateStakeEventInstance extends TypedEventInstance<ReactivateStakeEvent> {
        data_decoded: ReactivateStakeEvent;
        type_arguments: [];
    }
    interface RemoveDelegatorFromAllowlist {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
    }
    namespace RemoveDelegatorFromAllowlist {
        const TYPE_QNAME = "0x1::delegation_pool::RemoveDelegatorFromAllowlist";
        function type(): TypeDescriptor<RemoveDelegatorFromAllowlist>;
    }
    interface RemoveDelegatorFromAllowlistInstance extends TypedEventInstance<RemoveDelegatorFromAllowlist> {
        data_decoded: RemoveDelegatorFromAllowlist;
        type_arguments: [];
    }
    interface SetBeneficiaryForOperator {
        operator: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiaryForOperator {
        const TYPE_QNAME = "0x1::delegation_pool::SetBeneficiaryForOperator";
        function type(): TypeDescriptor<SetBeneficiaryForOperator>;
    }
    interface SetBeneficiaryForOperatorInstance extends TypedEventInstance<SetBeneficiaryForOperator> {
        data_decoded: SetBeneficiaryForOperator;
        type_arguments: [];
    }
    interface UnlockStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStake {
        const TYPE_QNAME = "0x1::delegation_pool::UnlockStake";
        function type(): TypeDescriptor<UnlockStake>;
    }
    interface UnlockStakeInstance extends TypedEventInstance<UnlockStake> {
        data_decoded: UnlockStake;
        type_arguments: [];
    }
    interface UnlockStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::UnlockStakeEvent";
        function type(): TypeDescriptor<UnlockStakeEvent>;
    }
    interface UnlockStakeEventInstance extends TypedEventInstance<UnlockStakeEvent> {
        data_decoded: UnlockStakeEvent;
        type_arguments: [];
    }
    interface Vote {
        voter: MoveAddressType;
        proposal_id: bigint;
        delegation_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: Boolean;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::delegation_pool::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    interface VoteInstance extends TypedEventInstance<Vote> {
        data_decoded: Vote;
        type_arguments: [];
    }
    interface VoteDelegation {
        voter: MoveAddressType;
        pending_voter: MoveAddressType;
        last_locked_until_secs: bigint;
    }
    namespace VoteDelegation {
        const TYPE_QNAME = "0x1::delegation_pool::VoteDelegation";
        function type(): TypeDescriptor<VoteDelegation>;
    }
    interface VoteDelegationInstance extends TypedEventInstance<VoteDelegation> {
        data_decoded: VoteDelegation;
        type_arguments: [];
    }
    interface VoteEvent {
        voter: MoveAddressType;
        proposal_id: bigint;
        delegation_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: Boolean;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::delegation_pool::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    interface VoteEventInstance extends TypedEventInstance<VoteEvent> {
        data_decoded: VoteEvent;
        type_arguments: [];
    }
    interface VotingRecordKey {
        voter: MoveAddressType;
        proposal_id: bigint;
    }
    namespace VotingRecordKey {
        const TYPE_QNAME = "0x1::delegation_pool::VotingRecordKey";
        function type(): TypeDescriptor<VotingRecordKey>;
    }
    interface VotingRecordKeyInstance extends TypedEventInstance<VotingRecordKey> {
        data_decoded: VotingRecordKey;
        type_arguments: [];
    }
    interface WithdrawStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStake {
        const TYPE_QNAME = "0x1::delegation_pool::WithdrawStake";
        function type(): TypeDescriptor<WithdrawStake>;
    }
    interface WithdrawStakeInstance extends TypedEventInstance<WithdrawStake> {
        data_decoded: WithdrawStake;
        type_arguments: [];
    }
    interface WithdrawStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::WithdrawStakeEvent";
        function type(): TypeDescriptor<WithdrawStakeEvent>;
    }
    interface WithdrawStakeEventInstance extends TypedEventInstance<WithdrawStakeEvent> {
        data_decoded: WithdrawStakeEvent;
        type_arguments: [];
    }
    namespace entry {
        function addStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function allowlistDelegator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createProposal(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string, string, Boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function delegateVotingPower(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function disableDelegatorsAllowlisting(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function enableDelegatorsAllowlisting(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function enablePartialGovernanceVoting(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function evictDelegator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function initializeDelegationPool(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function reactivateStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeDelegatorFromAllowlist(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiaryForOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setDelegatedVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function synchronizeDelegationPool(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlock(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateCommissionPercentage(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function vote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, bigint, Boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function withdraw(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function allowlistingEnabled(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function beneficiaryForOperator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function calculateAndUpdateDelegatorVoter(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function calculateAndUpdateRemainingVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function calculateAndUpdateVoterTotalVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function calculateAndUpdateVotingDelegation(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType, MoveAddressType, bigint]>;
        function canWithdrawPendingInactive(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function delegationPoolExists(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function delegatorAllowlisted(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function getAddStakeFee(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getDelegationPoolStake(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint, bigint, bigint, bigint]>;
        function getDelegatorsAllowlist(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType[]]>;
        function getExpectedStakePoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType, string];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getOwnedPoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getPendingWithdrawal(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[Boolean, bigint]>;
        function getStake(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint, bigint, bigint]>;
        function isNextCommissionPercentageEffective(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function minRemainingSecsForCommissionChange(client: Aptos, version?: bigint): Promise<[bigint]>;
        function observedLockupCycle(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function operatorCommissionPercentage(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function operatorCommissionPercentageNextLockupCycle(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function ownerCapExists(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function partialGovernanceVotingEnabled(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function shareholdersCountActivePool(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
    }
}
export declare namespace keyless_account {
    interface Configuration {
        override_aud_vals: string[];
        max_signatures_per_txn: number;
        max_exp_horizon_secs: bigint;
        training_wheels_pubkey: option.Option<string>;
        max_commited_epk_bytes: number;
        max_iss_val_bytes: number;
        max_extra_field_bytes: number;
        max_jwt_header_b64_bytes: number;
    }
    namespace Configuration {
        const TYPE_QNAME = "0x1::keyless_account::Configuration";
        function type(): TypeDescriptor<Configuration>;
    }
    interface ConfigurationInstance extends TypedEventInstance<Configuration> {
        data_decoded: Configuration;
        type_arguments: [];
    }
    interface Groth16VerificationKey {
        alpha_g1: string;
        beta_g2: string;
        gamma_g2: string;
        delta_g2: string;
        gamma_abc_g1: string[];
    }
    namespace Groth16VerificationKey {
        const TYPE_QNAME = "0x1::keyless_account::Groth16VerificationKey";
        function type(): TypeDescriptor<Groth16VerificationKey>;
    }
    interface Groth16VerificationKeyInstance extends TypedEventInstance<Groth16VerificationKey> {
        data_decoded: Groth16VerificationKey;
        type_arguments: [];
    }
    interface Group {
        dummy_field: Boolean;
    }
    namespace Group {
        const TYPE_QNAME = "0x1::keyless_account::Group";
        function type(): TypeDescriptor<Group>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace reconfiguration {
    interface Configuration {
        epoch: bigint;
        last_reconfiguration_time: bigint;
        events: event.EventHandle<reconfiguration.NewEpochEvent>;
    }
    namespace Configuration {
        const TYPE_QNAME = "0x1::reconfiguration::Configuration";
        function type(): TypeDescriptor<Configuration>;
    }
    interface DisableReconfiguration {
        dummy_field: Boolean;
    }
    namespace DisableReconfiguration {
        const TYPE_QNAME = "0x1::reconfiguration::DisableReconfiguration";
        function type(): TypeDescriptor<DisableReconfiguration>;
    }
    interface NewEpoch {
        epoch: bigint;
    }
    namespace NewEpoch {
        const TYPE_QNAME = "0x1::reconfiguration::NewEpoch";
        function type(): TypeDescriptor<NewEpoch>;
    }
    interface NewEpochInstance extends TypedEventInstance<NewEpoch> {
        data_decoded: NewEpoch;
        type_arguments: [];
    }
    interface NewEpochEvent {
        epoch: bigint;
    }
    namespace NewEpochEvent {
        const TYPE_QNAME = "0x1::reconfiguration::NewEpochEvent";
        function type(): TypeDescriptor<NewEpochEvent>;
    }
    interface NewEpochEventInstance extends TypedEventInstance<NewEpochEvent> {
        data_decoded: NewEpochEvent;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace transaction_fee {
    interface AptosCoinCapabilities {
        burn_cap: coin.BurnCapability<aptos_coin.AptosCoin>;
    }
    namespace AptosCoinCapabilities {
        const TYPE_QNAME = "0x1::transaction_fee::AptosCoinCapabilities";
        function type(): TypeDescriptor<AptosCoinCapabilities>;
    }
    interface AptosCoinMintCapability {
        mint_cap: coin.MintCapability<aptos_coin.AptosCoin>;
    }
    namespace AptosCoinMintCapability {
        const TYPE_QNAME = "0x1::transaction_fee::AptosCoinMintCapability";
        function type(): TypeDescriptor<AptosCoinMintCapability>;
    }
    interface AptosFABurnCapabilities {
        burn_ref: fungible_asset.BurnRef;
    }
    namespace AptosFABurnCapabilities {
        const TYPE_QNAME = "0x1::transaction_fee::AptosFABurnCapabilities";
        function type(): TypeDescriptor<AptosFABurnCapabilities>;
    }
    interface CollectedFeesPerBlock {
        amount: coin.AggregatableCoin<aptos_coin.AptosCoin>;
        proposer: option.Option<MoveAddressType>;
        burn_percentage: number;
    }
    namespace CollectedFeesPerBlock {
        const TYPE_QNAME = "0x1::transaction_fee::CollectedFeesPerBlock";
        function type(): TypeDescriptor<CollectedFeesPerBlock>;
    }
    interface FeeStatement {
        total_charge_gas_units: bigint;
        execution_gas_units: bigint;
        io_gas_units: bigint;
        storage_fee_octas: bigint;
        storage_fee_refund_octas: bigint;
    }
    namespace FeeStatement {
        const TYPE_QNAME = "0x1::transaction_fee::FeeStatement";
        function type(): TypeDescriptor<FeeStatement>;
    }
    interface FeeStatementInstance extends TypedEventInstance<FeeStatement> {
        data_decoded: FeeStatement;
        type_arguments: [];
    }
    namespace entry {
        function convertToAptosFaBurnRef(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace aptos_governance {
    interface ApprovedExecutionHashes {
        hashes: simple_map.SimpleMap<bigint, string>;
    }
    namespace ApprovedExecutionHashes {
        const TYPE_QNAME = "0x1::aptos_governance::ApprovedExecutionHashes";
        function type(): TypeDescriptor<ApprovedExecutionHashes>;
    }
    interface CreateProposal {
        proposer: MoveAddressType;
        stake_pool: MoveAddressType;
        proposal_id: bigint;
        execution_hash: string;
        proposal_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace CreateProposal {
        const TYPE_QNAME = "0x1::aptos_governance::CreateProposal";
        function type(): TypeDescriptor<CreateProposal>;
    }
    interface CreateProposalInstance extends TypedEventInstance<CreateProposal> {
        data_decoded: CreateProposal;
        type_arguments: [];
    }
    interface CreateProposalEvent {
        proposer: MoveAddressType;
        stake_pool: MoveAddressType;
        proposal_id: bigint;
        execution_hash: string;
        proposal_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace CreateProposalEvent {
        const TYPE_QNAME = "0x1::aptos_governance::CreateProposalEvent";
        function type(): TypeDescriptor<CreateProposalEvent>;
    }
    interface CreateProposalEventInstance extends TypedEventInstance<CreateProposalEvent> {
        data_decoded: CreateProposalEvent;
        type_arguments: [];
    }
    interface GovernanceConfig {
        min_voting_threshold: bigint;
        required_proposer_stake: bigint;
        voting_duration_secs: bigint;
    }
    namespace GovernanceConfig {
        const TYPE_QNAME = "0x1::aptos_governance::GovernanceConfig";
        function type(): TypeDescriptor<GovernanceConfig>;
    }
    interface GovernanceEvents {
        create_proposal_events: event.EventHandle<aptos_governance.CreateProposalEvent>;
        update_config_events: event.EventHandle<aptos_governance.UpdateConfigEvent>;
        vote_events: event.EventHandle<aptos_governance.VoteEvent>;
    }
    namespace GovernanceEvents {
        const TYPE_QNAME = "0x1::aptos_governance::GovernanceEvents";
        function type(): TypeDescriptor<GovernanceEvents>;
    }
    interface GovernanceResponsbility {
        signer_caps: simple_map.SimpleMap<MoveAddressType, account.SignerCapability>;
    }
    namespace GovernanceResponsbility {
        const TYPE_QNAME = "0x1::aptos_governance::GovernanceResponsbility";
        function type(): TypeDescriptor<GovernanceResponsbility>;
    }
    interface RecordKey {
        stake_pool: MoveAddressType;
        proposal_id: bigint;
    }
    namespace RecordKey {
        const TYPE_QNAME = "0x1::aptos_governance::RecordKey";
        function type(): TypeDescriptor<RecordKey>;
    }
    interface RecordKeyInstance extends TypedEventInstance<RecordKey> {
        data_decoded: RecordKey;
        type_arguments: [];
    }
    interface UpdateConfig {
        min_voting_threshold: bigint;
        required_proposer_stake: bigint;
        voting_duration_secs: bigint;
    }
    namespace UpdateConfig {
        const TYPE_QNAME = "0x1::aptos_governance::UpdateConfig";
        function type(): TypeDescriptor<UpdateConfig>;
    }
    interface UpdateConfigInstance extends TypedEventInstance<UpdateConfig> {
        data_decoded: UpdateConfig;
        type_arguments: [];
    }
    interface UpdateConfigEvent {
        min_voting_threshold: bigint;
        required_proposer_stake: bigint;
        voting_duration_secs: bigint;
    }
    namespace UpdateConfigEvent {
        const TYPE_QNAME = "0x1::aptos_governance::UpdateConfigEvent";
        function type(): TypeDescriptor<UpdateConfigEvent>;
    }
    interface UpdateConfigEventInstance extends TypedEventInstance<UpdateConfigEvent> {
        data_decoded: UpdateConfigEvent;
        type_arguments: [];
    }
    interface Vote {
        proposal_id: bigint;
        voter: MoveAddressType;
        stake_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: Boolean;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::aptos_governance::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    interface VoteInstance extends TypedEventInstance<Vote> {
        data_decoded: Vote;
        type_arguments: [];
    }
    interface VoteEvent {
        proposal_id: bigint;
        voter: MoveAddressType;
        stake_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: Boolean;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::aptos_governance::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    interface VoteEventInstance extends TypedEventInstance<VoteEvent> {
        data_decoded: VoteEvent;
        type_arguments: [];
    }
    interface VotingRecords {
        votes: table.Table<aptos_governance.RecordKey, Boolean>;
    }
    namespace VotingRecords {
        const TYPE_QNAME = "0x1::aptos_governance::VotingRecords";
        function type(): TypeDescriptor<VotingRecords>;
    }
    interface VotingRecordsV2 {
        votes: smart_table.SmartTable<aptos_governance.RecordKey, bigint>;
    }
    namespace VotingRecordsV2 {
        const TYPE_QNAME = "0x1::aptos_governance::VotingRecordsV2";
        function type(): TypeDescriptor<VotingRecordsV2>;
    }
    namespace entry {
        function addApprovedScriptHashScript(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchPartialVote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, bigint, Boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function batchVote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, Boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createProposal(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createProposalV2(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string, string, string, Boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function forceEndEpoch(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function forceEndEpochTestOnly(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function partialVote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, bigint, Boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function reconfigure(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function vote(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, Boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function getMinVotingThreshold(client: Aptos, version?: bigint): Promise<[bigint]>;
        function getRemainingVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[bigint]>;
        function getRequiredProposerStake(client: Aptos, version?: bigint): Promise<[bigint]>;
        function getVotingDurationSecs(client: Aptos, version?: bigint): Promise<[bigint]>;
        function getVotingPower(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function hasEntirelyVoted(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[Boolean]>;
    }
}
export declare namespace bls12381_algebra {
    interface FormatFq12LscLsb {
        dummy_field: Boolean;
    }
    namespace FormatFq12LscLsb {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatFq12LscLsb";
        function type(): TypeDescriptor<FormatFq12LscLsb>;
    }
    interface FormatFrLsb {
        dummy_field: Boolean;
    }
    namespace FormatFrLsb {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatFrLsb";
        function type(): TypeDescriptor<FormatFrLsb>;
    }
    interface FormatFrMsb {
        dummy_field: Boolean;
    }
    namespace FormatFrMsb {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatFrMsb";
        function type(): TypeDescriptor<FormatFrMsb>;
    }
    interface FormatG1Compr {
        dummy_field: Boolean;
    }
    namespace FormatG1Compr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG1Compr";
        function type(): TypeDescriptor<FormatG1Compr>;
    }
    interface FormatG1Uncompr {
        dummy_field: Boolean;
    }
    namespace FormatG1Uncompr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG1Uncompr";
        function type(): TypeDescriptor<FormatG1Uncompr>;
    }
    interface FormatG2Compr {
        dummy_field: Boolean;
    }
    namespace FormatG2Compr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG2Compr";
        function type(): TypeDescriptor<FormatG2Compr>;
    }
    interface FormatG2Uncompr {
        dummy_field: Boolean;
    }
    namespace FormatG2Uncompr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG2Uncompr";
        function type(): TypeDescriptor<FormatG2Uncompr>;
    }
    interface FormatGt {
        dummy_field: Boolean;
    }
    namespace FormatGt {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatGt";
        function type(): TypeDescriptor<FormatGt>;
    }
    interface Fq12 {
        dummy_field: Boolean;
    }
    namespace Fq12 {
        const TYPE_QNAME = "0x1::bls12381_algebra::Fq12";
        function type(): TypeDescriptor<Fq12>;
    }
    interface Fr {
        dummy_field: Boolean;
    }
    namespace Fr {
        const TYPE_QNAME = "0x1::bls12381_algebra::Fr";
        function type(): TypeDescriptor<Fr>;
    }
    interface G1 {
        dummy_field: Boolean;
    }
    namespace G1 {
        const TYPE_QNAME = "0x1::bls12381_algebra::G1";
        function type(): TypeDescriptor<G1>;
    }
    interface G2 {
        dummy_field: Boolean;
    }
    namespace G2 {
        const TYPE_QNAME = "0x1::bls12381_algebra::G2";
        function type(): TypeDescriptor<G2>;
    }
    interface Gt {
        dummy_field: Boolean;
    }
    namespace Gt {
        const TYPE_QNAME = "0x1::bls12381_algebra::Gt";
        function type(): TypeDescriptor<Gt>;
    }
    interface HashG1XmdSha256SswuRo {
        dummy_field: Boolean;
    }
    namespace HashG1XmdSha256SswuRo {
        const TYPE_QNAME = "0x1::bls12381_algebra::HashG1XmdSha256SswuRo";
        function type(): TypeDescriptor<HashG1XmdSha256SswuRo>;
    }
    interface HashG2XmdSha256SswuRo {
        dummy_field: Boolean;
    }
    namespace HashG2XmdSha256SswuRo {
        const TYPE_QNAME = "0x1::bls12381_algebra::HashG2XmdSha256SswuRo";
        function type(): TypeDescriptor<HashG2XmdSha256SswuRo>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace consensus_config {
    interface ConsensusConfig {
        config: string;
    }
    namespace ConsensusConfig {
        const TYPE_QNAME = "0x1::consensus_config::ConsensusConfig";
        function type(): TypeDescriptor<ConsensusConfig>;
    }
    interface ConsensusConfigInstance extends TypedEventInstance<ConsensusConfig> {
        data_decoded: ConsensusConfig;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace execution_config {
    interface ExecutionConfig {
        config: string;
    }
    namespace ExecutionConfig {
        const TYPE_QNAME = "0x1::execution_config::ExecutionConfig";
        function type(): TypeDescriptor<ExecutionConfig>;
    }
    interface ExecutionConfigInstance extends TypedEventInstance<ExecutionConfig> {
        data_decoded: ExecutionConfig;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace multisig_account {
    interface AddOwners {
        multisig_account: MoveAddressType;
        owners_added: MoveAddressType[];
    }
    namespace AddOwners {
        const TYPE_QNAME = "0x1::multisig_account::AddOwners";
        function type(): TypeDescriptor<AddOwners>;
    }
    interface AddOwnersInstance extends TypedEventInstance<AddOwners> {
        data_decoded: AddOwners;
        type_arguments: [];
    }
    interface AddOwnersEvent {
        owners_added: MoveAddressType[];
    }
    namespace AddOwnersEvent {
        const TYPE_QNAME = "0x1::multisig_account::AddOwnersEvent";
        function type(): TypeDescriptor<AddOwnersEvent>;
    }
    interface AddOwnersEventInstance extends TypedEventInstance<AddOwnersEvent> {
        data_decoded: AddOwnersEvent;
        type_arguments: [];
    }
    interface CreateTransaction {
        multisig_account: MoveAddressType;
        creator: MoveAddressType;
        sequence_number: bigint;
        transaction: multisig_account.MultisigTransaction;
    }
    namespace CreateTransaction {
        const TYPE_QNAME = "0x1::multisig_account::CreateTransaction";
        function type(): TypeDescriptor<CreateTransaction>;
    }
    interface CreateTransactionInstance extends TypedEventInstance<CreateTransaction> {
        data_decoded: CreateTransaction;
        type_arguments: [];
    }
    interface CreateTransactionEvent {
        creator: MoveAddressType;
        sequence_number: bigint;
        transaction: multisig_account.MultisigTransaction;
    }
    namespace CreateTransactionEvent {
        const TYPE_QNAME = "0x1::multisig_account::CreateTransactionEvent";
        function type(): TypeDescriptor<CreateTransactionEvent>;
    }
    interface CreateTransactionEventInstance extends TypedEventInstance<CreateTransactionEvent> {
        data_decoded: CreateTransactionEvent;
        type_arguments: [];
    }
    interface ExecuteRejectedTransaction {
        multisig_account: MoveAddressType;
        sequence_number: bigint;
        num_rejections: bigint;
        executor: MoveAddressType;
    }
    namespace ExecuteRejectedTransaction {
        const TYPE_QNAME = "0x1::multisig_account::ExecuteRejectedTransaction";
        function type(): TypeDescriptor<ExecuteRejectedTransaction>;
    }
    interface ExecuteRejectedTransactionInstance extends TypedEventInstance<ExecuteRejectedTransaction> {
        data_decoded: ExecuteRejectedTransaction;
        type_arguments: [];
    }
    interface ExecuteRejectedTransactionEvent {
        sequence_number: bigint;
        num_rejections: bigint;
        executor: MoveAddressType;
    }
    namespace ExecuteRejectedTransactionEvent {
        const TYPE_QNAME = "0x1::multisig_account::ExecuteRejectedTransactionEvent";
        function type(): TypeDescriptor<ExecuteRejectedTransactionEvent>;
    }
    interface ExecuteRejectedTransactionEventInstance extends TypedEventInstance<ExecuteRejectedTransactionEvent> {
        data_decoded: ExecuteRejectedTransactionEvent;
        type_arguments: [];
    }
    interface ExecutionError {
        abort_location: string;
        error_type: string;
        error_code: bigint;
    }
    namespace ExecutionError {
        const TYPE_QNAME = "0x1::multisig_account::ExecutionError";
        function type(): TypeDescriptor<ExecutionError>;
    }
    interface ExecutionErrorInstance extends TypedEventInstance<ExecutionError> {
        data_decoded: ExecutionError;
        type_arguments: [];
    }
    interface MetadataUpdated {
        multisig_account: MoveAddressType;
        old_metadata: simple_map.SimpleMap<string, string>;
        new_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace MetadataUpdated {
        const TYPE_QNAME = "0x1::multisig_account::MetadataUpdated";
        function type(): TypeDescriptor<MetadataUpdated>;
    }
    interface MetadataUpdatedInstance extends TypedEventInstance<MetadataUpdated> {
        data_decoded: MetadataUpdated;
        type_arguments: [];
    }
    interface MetadataUpdatedEvent {
        old_metadata: simple_map.SimpleMap<string, string>;
        new_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace MetadataUpdatedEvent {
        const TYPE_QNAME = "0x1::multisig_account::MetadataUpdatedEvent";
        function type(): TypeDescriptor<MetadataUpdatedEvent>;
    }
    interface MetadataUpdatedEventInstance extends TypedEventInstance<MetadataUpdatedEvent> {
        data_decoded: MetadataUpdatedEvent;
        type_arguments: [];
    }
    interface MultisigAccount {
        owners: MoveAddressType[];
        num_signatures_required: bigint;
        transactions: table.Table<bigint, multisig_account.MultisigTransaction>;
        last_executed_sequence_number: bigint;
        next_sequence_number: bigint;
        signer_cap: option.Option<account.SignerCapability>;
        metadata: simple_map.SimpleMap<string, string>;
        add_owners_events: event.EventHandle<multisig_account.AddOwnersEvent>;
        remove_owners_events: event.EventHandle<multisig_account.RemoveOwnersEvent>;
        update_signature_required_events: event.EventHandle<multisig_account.UpdateSignaturesRequiredEvent>;
        create_transaction_events: event.EventHandle<multisig_account.CreateTransactionEvent>;
        vote_events: event.EventHandle<multisig_account.VoteEvent>;
        execute_rejected_transaction_events: event.EventHandle<multisig_account.ExecuteRejectedTransactionEvent>;
        execute_transaction_events: event.EventHandle<multisig_account.TransactionExecutionSucceededEvent>;
        transaction_execution_failed_events: event.EventHandle<multisig_account.TransactionExecutionFailedEvent>;
        metadata_updated_events: event.EventHandle<multisig_account.MetadataUpdatedEvent>;
    }
    namespace MultisigAccount {
        const TYPE_QNAME = "0x1::multisig_account::MultisigAccount";
        function type(): TypeDescriptor<MultisigAccount>;
    }
    interface MultisigAccountCreationMessage {
        chain_id: number;
        account_address: MoveAddressType;
        sequence_number: bigint;
        owners: MoveAddressType[];
        num_signatures_required: bigint;
    }
    namespace MultisigAccountCreationMessage {
        const TYPE_QNAME = "0x1::multisig_account::MultisigAccountCreationMessage";
        function type(): TypeDescriptor<MultisigAccountCreationMessage>;
    }
    interface MultisigAccountCreationWithAuthKeyRevocationMessage {
        chain_id: number;
        account_address: MoveAddressType;
        sequence_number: bigint;
        owners: MoveAddressType[];
        num_signatures_required: bigint;
    }
    namespace MultisigAccountCreationWithAuthKeyRevocationMessage {
        const TYPE_QNAME = "0x1::multisig_account::MultisigAccountCreationWithAuthKeyRevocationMessage";
        function type(): TypeDescriptor<MultisigAccountCreationWithAuthKeyRevocationMessage>;
    }
    interface MultisigTransaction {
        payload: option.Option<string>;
        payload_hash: option.Option<string>;
        votes: simple_map.SimpleMap<MoveAddressType, Boolean>;
        creator: MoveAddressType;
        creation_time_secs: bigint;
    }
    namespace MultisigTransaction {
        const TYPE_QNAME = "0x1::multisig_account::MultisigTransaction";
        function type(): TypeDescriptor<MultisigTransaction>;
    }
    interface MultisigTransactionInstance extends TypedEventInstance<MultisigTransaction> {
        data_decoded: MultisigTransaction;
        type_arguments: [];
    }
    interface RemoveOwners {
        multisig_account: MoveAddressType;
        owners_removed: MoveAddressType[];
    }
    namespace RemoveOwners {
        const TYPE_QNAME = "0x1::multisig_account::RemoveOwners";
        function type(): TypeDescriptor<RemoveOwners>;
    }
    interface RemoveOwnersInstance extends TypedEventInstance<RemoveOwners> {
        data_decoded: RemoveOwners;
        type_arguments: [];
    }
    interface RemoveOwnersEvent {
        owners_removed: MoveAddressType[];
    }
    namespace RemoveOwnersEvent {
        const TYPE_QNAME = "0x1::multisig_account::RemoveOwnersEvent";
        function type(): TypeDescriptor<RemoveOwnersEvent>;
    }
    interface RemoveOwnersEventInstance extends TypedEventInstance<RemoveOwnersEvent> {
        data_decoded: RemoveOwnersEvent;
        type_arguments: [];
    }
    interface TransactionExecutionFailed {
        multisig_account: MoveAddressType;
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
        execution_error: multisig_account.ExecutionError;
    }
    namespace TransactionExecutionFailed {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionFailed";
        function type(): TypeDescriptor<TransactionExecutionFailed>;
    }
    interface TransactionExecutionFailedInstance extends TypedEventInstance<TransactionExecutionFailed> {
        data_decoded: TransactionExecutionFailed;
        type_arguments: [];
    }
    interface TransactionExecutionFailedEvent {
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
        execution_error: multisig_account.ExecutionError;
    }
    namespace TransactionExecutionFailedEvent {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionFailedEvent";
        function type(): TypeDescriptor<TransactionExecutionFailedEvent>;
    }
    interface TransactionExecutionFailedEventInstance extends TypedEventInstance<TransactionExecutionFailedEvent> {
        data_decoded: TransactionExecutionFailedEvent;
        type_arguments: [];
    }
    interface TransactionExecutionSucceeded {
        multisig_account: MoveAddressType;
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
    }
    namespace TransactionExecutionSucceeded {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionSucceeded";
        function type(): TypeDescriptor<TransactionExecutionSucceeded>;
    }
    interface TransactionExecutionSucceededInstance extends TypedEventInstance<TransactionExecutionSucceeded> {
        data_decoded: TransactionExecutionSucceeded;
        type_arguments: [];
    }
    interface TransactionExecutionSucceededEvent {
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
    }
    namespace TransactionExecutionSucceededEvent {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionSucceededEvent";
        function type(): TypeDescriptor<TransactionExecutionSucceededEvent>;
    }
    interface TransactionExecutionSucceededEventInstance extends TypedEventInstance<TransactionExecutionSucceededEvent> {
        data_decoded: TransactionExecutionSucceededEvent;
        type_arguments: [];
    }
    interface UpdateSignaturesRequired {
        multisig_account: MoveAddressType;
        old_num_signatures_required: bigint;
        new_num_signatures_required: bigint;
    }
    namespace UpdateSignaturesRequired {
        const TYPE_QNAME = "0x1::multisig_account::UpdateSignaturesRequired";
        function type(): TypeDescriptor<UpdateSignaturesRequired>;
    }
    interface UpdateSignaturesRequiredInstance extends TypedEventInstance<UpdateSignaturesRequired> {
        data_decoded: UpdateSignaturesRequired;
        type_arguments: [];
    }
    interface UpdateSignaturesRequiredEvent {
        old_num_signatures_required: bigint;
        new_num_signatures_required: bigint;
    }
    namespace UpdateSignaturesRequiredEvent {
        const TYPE_QNAME = "0x1::multisig_account::UpdateSignaturesRequiredEvent";
        function type(): TypeDescriptor<UpdateSignaturesRequiredEvent>;
    }
    interface UpdateSignaturesRequiredEventInstance extends TypedEventInstance<UpdateSignaturesRequiredEvent> {
        data_decoded: UpdateSignaturesRequiredEvent;
        type_arguments: [];
    }
    interface Vote {
        multisig_account: MoveAddressType;
        owner: MoveAddressType;
        sequence_number: bigint;
        approved: Boolean;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::multisig_account::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    interface VoteInstance extends TypedEventInstance<Vote> {
        data_decoded: Vote;
        type_arguments: [];
    }
    interface VoteEvent {
        owner: MoveAddressType;
        sequence_number: bigint;
        approved: Boolean;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::multisig_account::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    interface VoteEventInstance extends TypedEventInstance<VoteEvent> {
        data_decoded: VoteEvent;
        type_arguments: [];
    }
    namespace entry {
        function addOwner(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addOwners(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addOwnersAndUpdateSignaturesRequired(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function approveTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function create(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createTransactionWithHash(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithExistingAccount(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                MoveAddressType,
                MoveAddressType[],
                bigint,
                number,
                string,
                string,
                string[],
                string[]
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithExistingAccountAndRevokeAuthKey(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                MoveAddressType,
                MoveAddressType[],
                bigint,
                number,
                string,
                string,
                string[],
                string[]
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithOwners(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createWithOwnersThenRemoveBootstrapper(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], bigint, string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function executeRejectedTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function executeRejectedTransactions(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function rejectTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeOwner(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeOwners(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function swapOwner(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function swapOwners(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], MoveAddressType[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function swapOwnersAndUpdateSignaturesRequired(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType[], MoveAddressType[], bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateMetadata(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string[], string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateSignaturesRequired(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function voteTransaction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, Boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function voteTransactions(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, bigint, Boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function voteTransanction(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint, Boolean];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function availableTransactionQueueCapacity(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function canBeExecuted(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[Boolean]>;
        function canBeRejected(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[Boolean]>;
        function canExecute(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, version?: bigint): Promise<[Boolean]>;
        function canReject(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, version?: bigint): Promise<[Boolean]>;
        function getNextMultisigAccountAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function getNextTransactionPayload(client: Aptos, request: {
            functionArguments: [MoveAddressType, string];
        }, version?: bigint): Promise<[string]>;
        function getPendingTransactions(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[multisig_account.MultisigTransaction[]]>;
        function getTransaction(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint];
        }, version?: bigint): Promise<[multisig_account.MultisigTransaction]>;
        function isOwner(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
        function lastResolvedSequenceNumber(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function metadata(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[simple_map.SimpleMap<string, string>]>;
        function nextSequenceNumber(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function numSignaturesRequired(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function owners(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType[]]>;
        function vote(client: Aptos, request: {
            functionArguments: [MoveAddressType, bigint, MoveAddressType];
        }, version?: bigint): Promise<[Boolean, Boolean]>;
    }
}
export declare namespace pool_u64_unbound {
    interface Pool {
        total_coins: bigint;
        total_shares: bigint;
        shares: table_with_length.TableWithLength<MoveAddressType, bigint>;
        scaling_factor: bigint;
    }
    namespace Pool {
        const TYPE_QNAME = "0x1::pool_u64_unbound::Pool";
        function type(): TypeDescriptor<Pool>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace resource_account {
    interface Container {
        store: simple_map.SimpleMap<MoveAddressType, account.SignerCapability>;
    }
    namespace Container {
        const TYPE_QNAME = "0x1::resource_account::Container";
        function type(): TypeDescriptor<Container>;
    }
    namespace entry {
        function createResourceAccount(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createResourceAccountAndFund(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createResourceAccountAndPublishPackage(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string, string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace staking_contract {
    interface AddDistribution {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddDistribution {
        const TYPE_QNAME = "0x1::staking_contract::AddDistribution";
        function type(): TypeDescriptor<AddDistribution>;
    }
    interface AddDistributionInstance extends TypedEventInstance<AddDistribution> {
        data_decoded: AddDistribution;
        type_arguments: [];
    }
    interface AddDistributionEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddDistributionEvent {
        const TYPE_QNAME = "0x1::staking_contract::AddDistributionEvent";
        function type(): TypeDescriptor<AddDistributionEvent>;
    }
    interface AddDistributionEventInstance extends TypedEventInstance<AddDistributionEvent> {
        data_decoded: AddDistributionEvent;
        type_arguments: [];
    }
    interface AddStake {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddStake {
        const TYPE_QNAME = "0x1::staking_contract::AddStake";
        function type(): TypeDescriptor<AddStake>;
    }
    interface AddStakeInstance extends TypedEventInstance<AddStake> {
        data_decoded: AddStake;
        type_arguments: [];
    }
    interface AddStakeEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddStakeEvent {
        const TYPE_QNAME = "0x1::staking_contract::AddStakeEvent";
        function type(): TypeDescriptor<AddStakeEvent>;
    }
    interface AddStakeEventInstance extends TypedEventInstance<AddStakeEvent> {
        data_decoded: AddStakeEvent;
        type_arguments: [];
    }
    interface BeneficiaryForOperator {
        beneficiary_for_operator: MoveAddressType;
    }
    namespace BeneficiaryForOperator {
        const TYPE_QNAME = "0x1::staking_contract::BeneficiaryForOperator";
        function type(): TypeDescriptor<BeneficiaryForOperator>;
    }
    interface CreateStakingContract {
        operator: MoveAddressType;
        voter: MoveAddressType;
        pool_address: MoveAddressType;
        principal: bigint;
        commission_percentage: bigint;
    }
    namespace CreateStakingContract {
        const TYPE_QNAME = "0x1::staking_contract::CreateStakingContract";
        function type(): TypeDescriptor<CreateStakingContract>;
    }
    interface CreateStakingContractInstance extends TypedEventInstance<CreateStakingContract> {
        data_decoded: CreateStakingContract;
        type_arguments: [];
    }
    interface CreateStakingContractEvent {
        operator: MoveAddressType;
        voter: MoveAddressType;
        pool_address: MoveAddressType;
        principal: bigint;
        commission_percentage: bigint;
    }
    namespace CreateStakingContractEvent {
        const TYPE_QNAME = "0x1::staking_contract::CreateStakingContractEvent";
        function type(): TypeDescriptor<CreateStakingContractEvent>;
    }
    interface CreateStakingContractEventInstance extends TypedEventInstance<CreateStakingContractEvent> {
        data_decoded: CreateStakingContractEvent;
        type_arguments: [];
    }
    interface Distribute {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        recipient: MoveAddressType;
        amount: bigint;
    }
    namespace Distribute {
        const TYPE_QNAME = "0x1::staking_contract::Distribute";
        function type(): TypeDescriptor<Distribute>;
    }
    interface DistributeInstance extends TypedEventInstance<Distribute> {
        data_decoded: Distribute;
        type_arguments: [];
    }
    interface DistributeEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        recipient: MoveAddressType;
        amount: bigint;
    }
    namespace DistributeEvent {
        const TYPE_QNAME = "0x1::staking_contract::DistributeEvent";
        function type(): TypeDescriptor<DistributeEvent>;
    }
    interface DistributeEventInstance extends TypedEventInstance<DistributeEvent> {
        data_decoded: DistributeEvent;
        type_arguments: [];
    }
    interface RequestCommission {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        accumulated_rewards: bigint;
        commission_amount: bigint;
    }
    namespace RequestCommission {
        const TYPE_QNAME = "0x1::staking_contract::RequestCommission";
        function type(): TypeDescriptor<RequestCommission>;
    }
    interface RequestCommissionInstance extends TypedEventInstance<RequestCommission> {
        data_decoded: RequestCommission;
        type_arguments: [];
    }
    interface RequestCommissionEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        accumulated_rewards: bigint;
        commission_amount: bigint;
    }
    namespace RequestCommissionEvent {
        const TYPE_QNAME = "0x1::staking_contract::RequestCommissionEvent";
        function type(): TypeDescriptor<RequestCommissionEvent>;
    }
    interface RequestCommissionEventInstance extends TypedEventInstance<RequestCommissionEvent> {
        data_decoded: RequestCommissionEvent;
        type_arguments: [];
    }
    interface ResetLockup {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace ResetLockup {
        const TYPE_QNAME = "0x1::staking_contract::ResetLockup";
        function type(): TypeDescriptor<ResetLockup>;
    }
    interface ResetLockupInstance extends TypedEventInstance<ResetLockup> {
        data_decoded: ResetLockup;
        type_arguments: [];
    }
    interface ResetLockupEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace ResetLockupEvent {
        const TYPE_QNAME = "0x1::staking_contract::ResetLockupEvent";
        function type(): TypeDescriptor<ResetLockupEvent>;
    }
    interface ResetLockupEventInstance extends TypedEventInstance<ResetLockupEvent> {
        data_decoded: ResetLockupEvent;
        type_arguments: [];
    }
    interface SetBeneficiaryForOperator {
        operator: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiaryForOperator {
        const TYPE_QNAME = "0x1::staking_contract::SetBeneficiaryForOperator";
        function type(): TypeDescriptor<SetBeneficiaryForOperator>;
    }
    interface SetBeneficiaryForOperatorInstance extends TypedEventInstance<SetBeneficiaryForOperator> {
        data_decoded: SetBeneficiaryForOperator;
        type_arguments: [];
    }
    interface StakingContract {
        principal: bigint;
        pool_address: MoveAddressType;
        owner_cap: stake.OwnerCapability;
        commission_percentage: bigint;
        distribution_pool: pool_u64.Pool;
        signer_cap: account.SignerCapability;
    }
    namespace StakingContract {
        const TYPE_QNAME = "0x1::staking_contract::StakingContract";
        function type(): TypeDescriptor<StakingContract>;
    }
    interface StakingGroupContainer {
        dummy_field: Boolean;
    }
    namespace StakingGroupContainer {
        const TYPE_QNAME = "0x1::staking_contract::StakingGroupContainer";
        function type(): TypeDescriptor<StakingGroupContainer>;
    }
    interface StakingGroupUpdateCommissionEvent {
        update_commission_events: event.EventHandle<staking_contract.UpdateCommissionEvent>;
    }
    namespace StakingGroupUpdateCommissionEvent {
        const TYPE_QNAME = "0x1::staking_contract::StakingGroupUpdateCommissionEvent";
        function type(): TypeDescriptor<StakingGroupUpdateCommissionEvent>;
    }
    interface Store {
        staking_contracts: simple_map.SimpleMap<MoveAddressType, staking_contract.StakingContract>;
        create_staking_contract_events: event.EventHandle<staking_contract.CreateStakingContractEvent>;
        update_voter_events: event.EventHandle<staking_contract.UpdateVoterEvent>;
        reset_lockup_events: event.EventHandle<staking_contract.ResetLockupEvent>;
        add_stake_events: event.EventHandle<staking_contract.AddStakeEvent>;
        request_commission_events: event.EventHandle<staking_contract.RequestCommissionEvent>;
        unlock_stake_events: event.EventHandle<staking_contract.UnlockStakeEvent>;
        switch_operator_events: event.EventHandle<staking_contract.SwitchOperatorEvent>;
        add_distribution_events: event.EventHandle<staking_contract.AddDistributionEvent>;
        distribute_events: event.EventHandle<staking_contract.DistributeEvent>;
    }
    namespace Store {
        const TYPE_QNAME = "0x1::staking_contract::Store";
        function type(): TypeDescriptor<Store>;
    }
    interface SwitchOperator {
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace SwitchOperator {
        const TYPE_QNAME = "0x1::staking_contract::SwitchOperator";
        function type(): TypeDescriptor<SwitchOperator>;
    }
    interface SwitchOperatorInstance extends TypedEventInstance<SwitchOperator> {
        data_decoded: SwitchOperator;
        type_arguments: [];
    }
    interface SwitchOperatorEvent {
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace SwitchOperatorEvent {
        const TYPE_QNAME = "0x1::staking_contract::SwitchOperatorEvent";
        function type(): TypeDescriptor<SwitchOperatorEvent>;
    }
    interface SwitchOperatorEventInstance extends TypedEventInstance<SwitchOperatorEvent> {
        data_decoded: SwitchOperatorEvent;
        type_arguments: [];
    }
    interface UnlockStake {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
        commission_paid: bigint;
    }
    namespace UnlockStake {
        const TYPE_QNAME = "0x1::staking_contract::UnlockStake";
        function type(): TypeDescriptor<UnlockStake>;
    }
    interface UnlockStakeInstance extends TypedEventInstance<UnlockStake> {
        data_decoded: UnlockStake;
        type_arguments: [];
    }
    interface UnlockStakeEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
        commission_paid: bigint;
    }
    namespace UnlockStakeEvent {
        const TYPE_QNAME = "0x1::staking_contract::UnlockStakeEvent";
        function type(): TypeDescriptor<UnlockStakeEvent>;
    }
    interface UnlockStakeEventInstance extends TypedEventInstance<UnlockStakeEvent> {
        data_decoded: UnlockStakeEvent;
        type_arguments: [];
    }
    interface UpdateCommission {
        staker: MoveAddressType;
        operator: MoveAddressType;
        old_commission_percentage: bigint;
        new_commission_percentage: bigint;
    }
    namespace UpdateCommission {
        const TYPE_QNAME = "0x1::staking_contract::UpdateCommission";
        function type(): TypeDescriptor<UpdateCommission>;
    }
    interface UpdateCommissionInstance extends TypedEventInstance<UpdateCommission> {
        data_decoded: UpdateCommission;
        type_arguments: [];
    }
    interface UpdateCommissionEvent {
        staker: MoveAddressType;
        operator: MoveAddressType;
        old_commission_percentage: bigint;
        new_commission_percentage: bigint;
    }
    namespace UpdateCommissionEvent {
        const TYPE_QNAME = "0x1::staking_contract::UpdateCommissionEvent";
        function type(): TypeDescriptor<UpdateCommissionEvent>;
    }
    interface UpdateCommissionEventInstance extends TypedEventInstance<UpdateCommissionEvent> {
        data_decoded: UpdateCommissionEvent;
        type_arguments: [];
    }
    interface UpdateVoter {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoter {
        const TYPE_QNAME = "0x1::staking_contract::UpdateVoter";
        function type(): TypeDescriptor<UpdateVoter>;
    }
    interface UpdateVoterInstance extends TypedEventInstance<UpdateVoter> {
        data_decoded: UpdateVoter;
        type_arguments: [];
    }
    interface UpdateVoterEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoterEvent {
        const TYPE_QNAME = "0x1::staking_contract::UpdateVoterEvent";
        function type(): TypeDescriptor<UpdateVoterEvent>;
    }
    interface UpdateVoterEventInstance extends TypedEventInstance<UpdateVoterEvent> {
        data_decoded: UpdateVoterEvent;
        type_arguments: [];
    }
    namespace entry {
        function addStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createStakingContract(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                MoveAddressType,
                MoveAddressType,
                bigint,
                bigint,
                string
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function distribute(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function requestCommission(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function resetLockup(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setBeneficiaryForOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function switchOperator(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function switchOperatorWithSameCommission(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlockRewards(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unlockStake(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateCommision(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateVoter(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [MoveAddressType, MoveAddressType];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function beneficiaryForOperator(client: Aptos, request: {
            functionArguments: [MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function commissionPercentage(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function getExpectedStakePoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType, string];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function lastRecordedPrincipal(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function pendingDistributionCounts(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint]>;
        function stakePoolAddress(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function stakingContractAmounts(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[bigint, bigint, bigint]>;
        function stakingContractExists(client: Aptos, request: {
            functionArguments: [MoveAddressType, MoveAddressType];
        }, version?: bigint): Promise<[Boolean]>;
    }
}
export declare namespace system_addresses {
    namespace entry { }
    namespace view { }
}
export declare namespace randomness_config {
    interface ConfigOff {
        dummy_field: Boolean;
    }
    namespace ConfigOff {
        const TYPE_QNAME = "0x1::randomness_config::ConfigOff";
        function type(): TypeDescriptor<ConfigOff>;
    }
    interface ConfigOffInstance extends TypedEventInstance<ConfigOff> {
        data_decoded: ConfigOff;
        type_arguments: [];
    }
    interface ConfigV1 {
        secrecy_threshold: fixed_point64.FixedPoint64;
        reconstruction_threshold: fixed_point64.FixedPoint64;
    }
    namespace ConfigV1 {
        const TYPE_QNAME = "0x1::randomness_config::ConfigV1";
        function type(): TypeDescriptor<ConfigV1>;
    }
    interface ConfigV1Instance extends TypedEventInstance<ConfigV1> {
        data_decoded: ConfigV1;
        type_arguments: [];
    }
    interface ConfigV2 {
        secrecy_threshold: fixed_point64.FixedPoint64;
        reconstruction_threshold: fixed_point64.FixedPoint64;
        fast_path_secrecy_threshold: fixed_point64.FixedPoint64;
    }
    namespace ConfigV2 {
        const TYPE_QNAME = "0x1::randomness_config::ConfigV2";
        function type(): TypeDescriptor<ConfigV2>;
    }
    interface ConfigV2Instance extends TypedEventInstance<ConfigV2> {
        data_decoded: ConfigV2;
        type_arguments: [];
    }
    interface RandomnessConfig {
        variant: copyable_any.Any;
    }
    namespace RandomnessConfig {
        const TYPE_QNAME = "0x1::randomness_config::RandomnessConfig";
        function type(): TypeDescriptor<RandomnessConfig>;
    }
    interface RandomnessConfigInstance extends TypedEventInstance<RandomnessConfig> {
        data_decoded: RandomnessConfig;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace table_with_length {
    interface TableWithLength<T0, T1> {
        inner: table.Table<T0, T1>;
        length: bigint;
    }
    namespace TableWithLength {
        const TYPE_QNAME = "0x1::table_with_length::TableWithLength";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<TableWithLength<T0, T1>>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace aggregator_factory {
    interface AggregatorFactory {
        phantom_table: table.Table<MoveAddressType, bigint>;
    }
    namespace AggregatorFactory {
        const TYPE_QNAME = "0x1::aggregator_factory::AggregatorFactory";
        function type(): TypeDescriptor<AggregatorFactory>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace governance_proposal {
    interface GovernanceProposal {
        dummy_field: Boolean;
    }
    namespace GovernanceProposal {
        const TYPE_QNAME = "0x1::governance_proposal::GovernanceProposal";
        function type(): TypeDescriptor<GovernanceProposal>;
    }
    interface GovernanceProposalInstance extends TypedEventInstance<GovernanceProposal> {
        data_decoded: GovernanceProposal;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace optional_aggregator {
    interface Integer {
        value: bigint;
        limit: bigint;
    }
    namespace Integer {
        const TYPE_QNAME = "0x1::optional_aggregator::Integer";
        function type(): TypeDescriptor<Integer>;
    }
    interface OptionalAggregator {
        aggregator: option.Option<aggregator.Aggregator>;
        integer: option.Option<optional_aggregator.Integer>;
    }
    namespace OptionalAggregator {
        const TYPE_QNAME = "0x1::optional_aggregator::OptionalAggregator";
        function type(): TypeDescriptor<OptionalAggregator>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace transaction_context {
    interface AUID {
        unique_address: MoveAddressType;
    }
    namespace AUID {
        const TYPE_QNAME = "0x1::transaction_context::AUID";
        function type(): TypeDescriptor<AUID>;
    }
    interface AUIDInstance extends TypedEventInstance<AUID> {
        data_decoded: AUID;
        type_arguments: [];
    }
    interface EntryFunctionPayload {
        account_address: MoveAddressType;
        module_name: string;
        function_name: string;
        ty_args_names: string[];
        args: string[];
    }
    namespace EntryFunctionPayload {
        const TYPE_QNAME = "0x1::transaction_context::EntryFunctionPayload";
        function type(): TypeDescriptor<EntryFunctionPayload>;
    }
    interface MultisigPayload {
        multisig_address: MoveAddressType;
        entry_function_payload: option.Option<transaction_context.EntryFunctionPayload>;
    }
    namespace MultisigPayload {
        const TYPE_QNAME = "0x1::transaction_context::MultisigPayload";
        function type(): TypeDescriptor<MultisigPayload>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace jwk_consensus_config {
    interface ConfigOff {
        dummy_field: Boolean;
    }
    namespace ConfigOff {
        const TYPE_QNAME = "0x1::jwk_consensus_config::ConfigOff";
        function type(): TypeDescriptor<ConfigOff>;
    }
    interface ConfigOffInstance extends TypedEventInstance<ConfigOff> {
        data_decoded: ConfigOff;
        type_arguments: [];
    }
    interface ConfigV1 {
        oidc_providers: jwk_consensus_config.OIDCProvider[];
    }
    namespace ConfigV1 {
        const TYPE_QNAME = "0x1::jwk_consensus_config::ConfigV1";
        function type(): TypeDescriptor<ConfigV1>;
    }
    interface ConfigV1Instance extends TypedEventInstance<ConfigV1> {
        data_decoded: ConfigV1;
        type_arguments: [];
    }
    interface JWKConsensusConfig {
        variant: copyable_any.Any;
    }
    namespace JWKConsensusConfig {
        const TYPE_QNAME = "0x1::jwk_consensus_config::JWKConsensusConfig";
        function type(): TypeDescriptor<JWKConsensusConfig>;
    }
    interface JWKConsensusConfigInstance extends TypedEventInstance<JWKConsensusConfig> {
        data_decoded: JWKConsensusConfig;
        type_arguments: [];
    }
    interface OIDCProvider {
        name: string;
        config_url: string;
    }
    namespace OIDCProvider {
        const TYPE_QNAME = "0x1::jwk_consensus_config::OIDCProvider";
        function type(): TypeDescriptor<OIDCProvider>;
    }
    interface OIDCProviderInstance extends TypedEventInstance<OIDCProvider> {
        data_decoded: OIDCProvider;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ristretto255_elgamal {
    interface Ciphertext {
        left: ristretto255.RistrettoPoint;
        right: ristretto255.RistrettoPoint;
    }
    namespace Ciphertext {
        const TYPE_QNAME = "0x1::ristretto255_elgamal::Ciphertext";
        function type(): TypeDescriptor<Ciphertext>;
    }
    interface CompressedCiphertext {
        left: ristretto255.CompressedRistretto;
        right: ristretto255.CompressedRistretto;
    }
    namespace CompressedCiphertext {
        const TYPE_QNAME = "0x1::ristretto255_elgamal::CompressedCiphertext";
        function type(): TypeDescriptor<CompressedCiphertext>;
    }
    interface CompressedCiphertextInstance extends TypedEventInstance<CompressedCiphertext> {
        data_decoded: CompressedCiphertext;
        type_arguments: [];
    }
    interface CompressedPubkey {
        point: ristretto255.CompressedRistretto;
    }
    namespace CompressedPubkey {
        const TYPE_QNAME = "0x1::ristretto255_elgamal::CompressedPubkey";
        function type(): TypeDescriptor<CompressedPubkey>;
    }
    interface CompressedPubkeyInstance extends TypedEventInstance<CompressedPubkey> {
        data_decoded: CompressedPubkey;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace reconfiguration_state {
    interface State {
        variant: copyable_any.Any;
    }
    namespace State {
        const TYPE_QNAME = "0x1::reconfiguration_state::State";
        function type(): TypeDescriptor<State>;
    }
    interface StateActive {
        start_time_secs: bigint;
    }
    namespace StateActive {
        const TYPE_QNAME = "0x1::reconfiguration_state::StateActive";
        function type(): TypeDescriptor<StateActive>;
    }
    interface StateActiveInstance extends TypedEventInstance<StateActive> {
        data_decoded: StateActive;
        type_arguments: [];
    }
    interface StateInactive {
        dummy_field: Boolean;
    }
    namespace StateInactive {
        const TYPE_QNAME = "0x1::reconfiguration_state::StateInactive";
        function type(): TypeDescriptor<StateInactive>;
    }
    interface StateInactiveInstance extends TypedEventInstance<StateInactive> {
        data_decoded: StateInactive;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ristretto255_pedersen {
    interface Commitment {
        point: ristretto255.RistrettoPoint;
    }
    namespace Commitment {
        const TYPE_QNAME = "0x1::ristretto255_pedersen::Commitment";
        function type(): TypeDescriptor<Commitment>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace object_code_deployment {
    interface Freeze {
        object_address: MoveAddressType;
    }
    namespace Freeze {
        const TYPE_QNAME = "0x1::object_code_deployment::Freeze";
        function type(): TypeDescriptor<Freeze>;
    }
    interface FreezeInstance extends TypedEventInstance<Freeze> {
        data_decoded: Freeze;
        type_arguments: [];
    }
    interface ManagingRefs {
        extend_ref: object_.ExtendRef;
    }
    namespace ManagingRefs {
        const TYPE_QNAME = "0x1::object_code_deployment::ManagingRefs";
        function type(): TypeDescriptor<ManagingRefs>;
    }
    interface Publish {
        object_address: MoveAddressType;
    }
    namespace Publish {
        const TYPE_QNAME = "0x1::object_code_deployment::Publish";
        function type(): TypeDescriptor<Publish>;
    }
    interface PublishInstance extends TypedEventInstance<Publish> {
        data_decoded: Publish;
        type_arguments: [];
    }
    interface Upgrade {
        object_address: MoveAddressType;
    }
    namespace Upgrade {
        const TYPE_QNAME = "0x1::object_code_deployment::Upgrade";
        function type(): TypeDescriptor<Upgrade>;
    }
    interface UpgradeInstance extends TypedEventInstance<Upgrade> {
        data_decoded: Upgrade;
        type_arguments: [];
    }
    namespace entry {
        function freezeCodeObject(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [object_.Object<code.PackageRegistry>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function publish(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [string, string[]];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function upgrade(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                string,
                string[],
                object_.Object<code.PackageRegistry>
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view { }
}
export declare namespace primary_fungible_store {
    interface DeriveRefPod {
        metadata_derive_ref: object_.DeriveRef;
    }
    namespace DeriveRefPod {
        const TYPE_QNAME = "0x1::primary_fungible_store::DeriveRefPod";
        function type(): TypeDescriptor<DeriveRefPod>;
    }
    namespace entry {
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>, MoveAddressType, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferAssertMinimumDeposit<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [
                object_.Object<T0>,
                MoveAddressType,
                bigint,
                bigint
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function balance<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object_.Object<T0>];
        }, version?: bigint): Promise<[bigint]>;
        function isBalanceAtLeast<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object_.Object<T0>, bigint];
        }, version?: bigint): Promise<[Boolean]>;
        function isFrozen<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
        function primaryStore<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object_.Object<T0>];
        }, version?: bigint): Promise<[object_.Object<fungible_asset.FungibleStore>]>;
        function primaryStoreAddress<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object_.Object<T0>];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function primaryStoreExists<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [MoveAddressType, object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
    }
}
export declare namespace transaction_validation {
    interface TransactionValidation {
        module_addr: MoveAddressType;
        module_name: string;
        script_prologue_name: string;
        module_prologue_name: string;
        multi_agent_prologue_name: string;
        user_epilogue_name: string;
    }
    namespace TransactionValidation {
        const TYPE_QNAME = "0x1::transaction_validation::TransactionValidation";
        function type(): TypeDescriptor<TransactionValidation>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace randomness_api_v0_config {
    interface AllowCustomMaxGasFlag {
        value: Boolean;
    }
    namespace AllowCustomMaxGasFlag {
        const TYPE_QNAME = "0x1::randomness_api_v0_config::AllowCustomMaxGasFlag";
        function type(): TypeDescriptor<AllowCustomMaxGasFlag>;
    }
    interface AllowCustomMaxGasFlagInstance extends TypedEventInstance<AllowCustomMaxGasFlag> {
        data_decoded: AllowCustomMaxGasFlag;
        type_arguments: [];
    }
    interface RequiredGasDeposit {
        gas_amount: option.Option<bigint>;
    }
    namespace RequiredGasDeposit {
        const TYPE_QNAME = "0x1::randomness_api_v0_config::RequiredGasDeposit";
        function type(): TypeDescriptor<RequiredGasDeposit>;
    }
    interface RequiredGasDepositInstance extends TypedEventInstance<RequiredGasDeposit> {
        data_decoded: RequiredGasDeposit;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace randomness_config_seqnum {
    interface RandomnessConfigSeqNum {
        seq_num: bigint;
    }
    namespace RandomnessConfigSeqNum {
        const TYPE_QNAME = "0x1::randomness_config_seqnum::RandomnessConfigSeqNum";
        function type(): TypeDescriptor<RandomnessConfigSeqNum>;
    }
    interface RandomnessConfigSeqNumInstance extends TypedEventInstance<RandomnessConfigSeqNum> {
        data_decoded: RandomnessConfigSeqNum;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace reconfiguration_with_dkg {
    namespace entry { }
    namespace view { }
}
export declare namespace validator_consensus_info {
    interface ValidatorConsensusInfo {
        addr: MoveAddressType;
        pk_bytes: string;
        voting_power: bigint;
    }
    namespace ValidatorConsensusInfo {
        const TYPE_QNAME = "0x1::validator_consensus_info::ValidatorConsensusInfo";
        function type(): TypeDescriptor<ValidatorConsensusInfo>;
    }
    interface ValidatorConsensusInfoInstance extends TypedEventInstance<ValidatorConsensusInfo> {
        data_decoded: ValidatorConsensusInfo;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace ristretto255_bulletproofs {
    interface RangeProof {
        bytes: string;
    }
    namespace RangeProof {
        const TYPE_QNAME = "0x1::ristretto255_bulletproofs::RangeProof";
        function type(): TypeDescriptor<RangeProof>;
    }
    interface RangeProofInstance extends TypedEventInstance<RangeProof> {
        data_decoded: RangeProof;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare namespace dispatchable_fungible_asset {
    interface TransferRefStore {
        transfer_ref: fungible_asset.TransferRef;
    }
    namespace TransferRefStore {
        const TYPE_QNAME = "0x1::dispatchable_fungible_asset::TransferRefStore";
        function type(): TypeDescriptor<TransferRefStore>;
    }
    namespace entry {
        function transfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>, object_.Object<T0>, bigint];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function transferAssertMinimumDeposit<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [
                object_.Object<T0>,
                object_.Object<T0>,
                bigint,
                bigint
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function derivedBalance<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[bigint]>;
        function derivedSupply<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [object_.Object<T0>];
        }, version?: bigint): Promise<[option.Option<bigint>]>;
    }
}
export declare function loadAllTypes(coder: MoveCoder): void;
//# sourceMappingURL=0x1.d.ts.map