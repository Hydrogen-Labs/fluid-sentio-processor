import { TypeDescriptor } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/aptos";
import { Aptos, Account as AptosAccount, MoveAddressType, PendingTransactionResponse, InputGenerateTransactionOptions, MoveStructId } from "@aptos-labs/ts-sdk";
import * as _0x1 from "./0x1.js";
export declare namespace token {
    interface BurnRef {
        inner: _0x1.option.Option<_0x1.object_.DeleteRef>;
        self: _0x1.option.Option<MoveAddressType>;
    }
    namespace BurnRef {
        const TYPE_QNAME = "0x4::token::BurnRef";
        function type(): TypeDescriptor<BurnRef>;
    }
    interface BurnRefInstance extends TypedEventInstance<BurnRef> {
        data_decoded: BurnRef;
        type_arguments: [];
    }
    interface ConcurrentTokenIdentifiers {
        index: _0x1.aggregator_v2.AggregatorSnapshot<bigint>;
        name: _0x1.aggregator_v2.AggregatorSnapshot<string>;
    }
    namespace ConcurrentTokenIdentifiers {
        const TYPE_QNAME = "0x4::token::ConcurrentTokenIdentifiers";
        function type(): TypeDescriptor<ConcurrentTokenIdentifiers>;
    }
    interface Mutation {
        token_address: MoveAddressType;
        mutated_field_name: string;
        old_value: string;
        new_value: string;
    }
    namespace Mutation {
        const TYPE_QNAME = "0x4::token::Mutation";
        function type(): TypeDescriptor<Mutation>;
    }
    interface MutationInstance extends TypedEventInstance<Mutation> {
        data_decoded: Mutation;
        type_arguments: [];
    }
    interface MutationEvent {
        mutated_field_name: string;
        old_value: string;
        new_value: string;
    }
    namespace MutationEvent {
        const TYPE_QNAME = "0x4::token::MutationEvent";
        function type(): TypeDescriptor<MutationEvent>;
    }
    interface MutationEventInstance extends TypedEventInstance<MutationEvent> {
        data_decoded: MutationEvent;
        type_arguments: [];
    }
    interface MutatorRef {
        self: MoveAddressType;
    }
    namespace MutatorRef {
        const TYPE_QNAME = "0x4::token::MutatorRef";
        function type(): TypeDescriptor<MutatorRef>;
    }
    interface MutatorRefInstance extends TypedEventInstance<MutatorRef> {
        data_decoded: MutatorRef;
        type_arguments: [];
    }
    interface Token {
        collection: _0x1.object_.Object<collection.Collection>;
        index: bigint;
        description: string;
        name: string;
        uri: string;
        mutation_events: _0x1.event.EventHandle<token.MutationEvent>;
    }
    namespace Token {
        const TYPE_QNAME = "0x4::token::Token";
        function type(): TypeDescriptor<Token>;
    }
    interface TokenIdentifiers {
        index: _0x1.aggregator_v2.AggregatorSnapshot<bigint>;
        name: _0x1.aggregator_v2.DerivedStringSnapshot;
    }
    namespace TokenIdentifiers {
        const TYPE_QNAME = "0x4::token::TokenIdentifiers";
        function type(): TypeDescriptor<TokenIdentifiers>;
    }
    namespace entry { }
    namespace view {
        function collectionName<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function collectionObject<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[_0x1.object_.Object<collection.Collection>]>;
        function createTokenAddressWithSeed(client: Aptos, request: {
            functionArguments: [MoveAddressType, string, string, string];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function creator<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function description<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function index<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[bigint]>;
        function name<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function royalty<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[_0x1.option.Option<royalty.Royalty>]>;
        function uri<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[string]>;
    }
}
export declare namespace royalty {
    interface MutatorRef {
        inner: _0x1.object_.ExtendRef;
    }
    namespace MutatorRef {
        const TYPE_QNAME = "0x4::royalty::MutatorRef";
        function type(): TypeDescriptor<MutatorRef>;
    }
    interface MutatorRefInstance extends TypedEventInstance<MutatorRef> {
        data_decoded: MutatorRef;
        type_arguments: [];
    }
    interface Royalty {
        numerator: bigint;
        denominator: bigint;
        payee_address: MoveAddressType;
    }
    namespace Royalty {
        const TYPE_QNAME = "0x4::royalty::Royalty";
        function type(): TypeDescriptor<Royalty>;
    }
    namespace entry { }
    namespace view { }
}
export declare namespace collection {
    interface Burn {
        collection: MoveAddressType;
        index: bigint;
        token: MoveAddressType;
        previous_owner: MoveAddressType;
    }
    namespace Burn {
        const TYPE_QNAME = "0x4::collection::Burn";
        function type(): TypeDescriptor<Burn>;
    }
    interface BurnInstance extends TypedEventInstance<Burn> {
        data_decoded: Burn;
        type_arguments: [];
    }
    interface BurnEvent {
        index: bigint;
        token: MoveAddressType;
    }
    namespace BurnEvent {
        const TYPE_QNAME = "0x4::collection::BurnEvent";
        function type(): TypeDescriptor<BurnEvent>;
    }
    interface BurnEventInstance extends TypedEventInstance<BurnEvent> {
        data_decoded: BurnEvent;
        type_arguments: [];
    }
    interface Collection {
        creator: MoveAddressType;
        description: string;
        name: string;
        uri: string;
        mutation_events: _0x1.event.EventHandle<collection.MutationEvent>;
    }
    namespace Collection {
        const TYPE_QNAME = "0x4::collection::Collection";
        function type(): TypeDescriptor<Collection>;
    }
    interface ConcurrentBurnEvent {
        collection_addr: MoveAddressType;
        index: bigint;
        token: MoveAddressType;
    }
    namespace ConcurrentBurnEvent {
        const TYPE_QNAME = "0x4::collection::ConcurrentBurnEvent";
        function type(): TypeDescriptor<ConcurrentBurnEvent>;
    }
    interface ConcurrentBurnEventInstance extends TypedEventInstance<ConcurrentBurnEvent> {
        data_decoded: ConcurrentBurnEvent;
        type_arguments: [];
    }
    interface ConcurrentMintEvent {
        collection_addr: MoveAddressType;
        index: _0x1.aggregator_v2.AggregatorSnapshot<bigint>;
        token: MoveAddressType;
    }
    namespace ConcurrentMintEvent {
        const TYPE_QNAME = "0x4::collection::ConcurrentMintEvent";
        function type(): TypeDescriptor<ConcurrentMintEvent>;
    }
    interface ConcurrentMintEventInstance extends TypedEventInstance<ConcurrentMintEvent> {
        data_decoded: ConcurrentMintEvent;
        type_arguments: [];
    }
    interface ConcurrentSupply {
        current_supply: _0x1.aggregator_v2.Aggregator<bigint>;
        total_minted: _0x1.aggregator_v2.Aggregator<bigint>;
    }
    namespace ConcurrentSupply {
        const TYPE_QNAME = "0x4::collection::ConcurrentSupply";
        function type(): TypeDescriptor<ConcurrentSupply>;
    }
    interface FixedSupply {
        current_supply: bigint;
        max_supply: bigint;
        total_minted: bigint;
        burn_events: _0x1.event.EventHandle<collection.BurnEvent>;
        mint_events: _0x1.event.EventHandle<collection.MintEvent>;
    }
    namespace FixedSupply {
        const TYPE_QNAME = "0x4::collection::FixedSupply";
        function type(): TypeDescriptor<FixedSupply>;
    }
    interface Mint {
        collection: MoveAddressType;
        index: _0x1.aggregator_v2.AggregatorSnapshot<bigint>;
        token: MoveAddressType;
    }
    namespace Mint {
        const TYPE_QNAME = "0x4::collection::Mint";
        function type(): TypeDescriptor<Mint>;
    }
    interface MintInstance extends TypedEventInstance<Mint> {
        data_decoded: Mint;
        type_arguments: [];
    }
    interface MintEvent {
        index: bigint;
        token: MoveAddressType;
    }
    namespace MintEvent {
        const TYPE_QNAME = "0x4::collection::MintEvent";
        function type(): TypeDescriptor<MintEvent>;
    }
    interface MintEventInstance extends TypedEventInstance<MintEvent> {
        data_decoded: MintEvent;
        type_arguments: [];
    }
    interface Mutation {
        mutated_field_name: string;
        collection: _0x1.object_.Object<collection.Collection>;
        old_value: string;
        new_value: string;
    }
    namespace Mutation {
        const TYPE_QNAME = "0x4::collection::Mutation";
        function type(): TypeDescriptor<Mutation>;
    }
    interface MutationInstance extends TypedEventInstance<Mutation> {
        data_decoded: Mutation;
        type_arguments: [];
    }
    interface MutationEvent {
        mutated_field_name: string;
    }
    namespace MutationEvent {
        const TYPE_QNAME = "0x4::collection::MutationEvent";
        function type(): TypeDescriptor<MutationEvent>;
    }
    interface MutationEventInstance extends TypedEventInstance<MutationEvent> {
        data_decoded: MutationEvent;
        type_arguments: [];
    }
    interface MutatorRef {
        self: MoveAddressType;
    }
    namespace MutatorRef {
        const TYPE_QNAME = "0x4::collection::MutatorRef";
        function type(): TypeDescriptor<MutatorRef>;
    }
    interface MutatorRefInstance extends TypedEventInstance<MutatorRef> {
        data_decoded: MutatorRef;
        type_arguments: [];
    }
    interface SetMaxSupply {
        collection: _0x1.object_.Object<collection.Collection>;
        old_max_supply: bigint;
        new_max_supply: bigint;
    }
    namespace SetMaxSupply {
        const TYPE_QNAME = "0x4::collection::SetMaxSupply";
        function type(): TypeDescriptor<SetMaxSupply>;
    }
    interface SetMaxSupplyInstance extends TypedEventInstance<SetMaxSupply> {
        data_decoded: SetMaxSupply;
        type_arguments: [];
    }
    interface UnlimitedSupply {
        current_supply: bigint;
        total_minted: bigint;
        burn_events: _0x1.event.EventHandle<collection.BurnEvent>;
        mint_events: _0x1.event.EventHandle<collection.MintEvent>;
    }
    namespace UnlimitedSupply {
        const TYPE_QNAME = "0x4::collection::UnlimitedSupply";
        function type(): TypeDescriptor<UnlimitedSupply>;
    }
    namespace entry { }
    namespace view {
        function count<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[_0x1.option.Option<bigint>]>;
        function creator<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[MoveAddressType]>;
        function description<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function name<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[string]>;
        function uri<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[string]>;
    }
}
export declare namespace aptos_token {
    interface AptosCollection {
        mutator_ref: _0x1.option.Option<collection.MutatorRef>;
        royalty_mutator_ref: _0x1.option.Option<royalty.MutatorRef>;
        mutable_description: Boolean;
        mutable_uri: Boolean;
        mutable_token_description: Boolean;
        mutable_token_name: Boolean;
        mutable_token_properties: Boolean;
        mutable_token_uri: Boolean;
        tokens_burnable_by_creator: Boolean;
        tokens_freezable_by_creator: Boolean;
    }
    namespace AptosCollection {
        const TYPE_QNAME = "0x4::aptos_token::AptosCollection";
        function type(): TypeDescriptor<AptosCollection>;
    }
    interface AptosToken {
        burn_ref: _0x1.option.Option<token.BurnRef>;
        transfer_ref: _0x1.option.Option<_0x1.object_.TransferRef>;
        mutator_ref: _0x1.option.Option<token.MutatorRef>;
        property_mutator_ref: property_map.MutatorRef;
    }
    namespace AptosToken {
        const TYPE_QNAME = "0x4::aptos_token::AptosToken";
        function type(): TypeDescriptor<AptosToken>;
    }
    namespace entry {
        function addProperty<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function addTypedProperty<T0 = any, T1 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId, MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>, string, T1];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function burn<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function createCollection(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                string,
                bigint,
                string,
                string,
                Boolean,
                Boolean,
                Boolean,
                Boolean,
                Boolean,
                Boolean,
                Boolean,
                Boolean,
                Boolean,
                bigint,
                bigint
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function freezeTransfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function mint(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                string,
                string,
                string,
                string,
                string[],
                string[],
                string[]
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function mintSoulBound(client: Aptos, account: AptosAccount, request: {
            typeArguments: [];
            functionArguments: [
                string,
                string,
                string,
                string,
                string[],
                string[],
                string[],
                MoveAddressType
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function removeProperty<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setCollectionDescription<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setCollectionRoyaltiesCall<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [
                _0x1.object_.Object<T0>,
                bigint,
                bigint,
                MoveAddressType
            ];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setCollectionUri<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setDescription<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setName<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function setUri<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function unfreezeTransfer<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateProperty<T0 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>, string, string, string];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
        function updateTypedProperty<T0 = any, T1 = any>(client: Aptos, account: AptosAccount, request: {
            typeArguments: [MoveStructId, MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>, string, T1];
        }, options?: InputGenerateTransactionOptions): Promise<PendingTransactionResponse>;
    }
    namespace view {
        function arePropertiesMutable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
        function isBurnable<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
        function isFreezableByCreator<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
        function isMutableDescription<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
        function isMutableName<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
        function isMutableUri<T0 = any>(client: Aptos, request: {
            typeArguments: [MoveStructId];
            functionArguments: [_0x1.object_.Object<T0>];
        }, version?: bigint): Promise<[Boolean]>;
    }
}
export declare namespace property_map {
    interface MutatorRef {
        self: MoveAddressType;
    }
    namespace MutatorRef {
        const TYPE_QNAME = "0x4::property_map::MutatorRef";
        function type(): TypeDescriptor<MutatorRef>;
    }
    interface MutatorRefInstance extends TypedEventInstance<MutatorRef> {
        data_decoded: MutatorRef;
        type_arguments: [];
    }
    interface PropertyMap {
        inner: _0x1.simple_map.SimpleMap<string, property_map.PropertyValue>;
    }
    namespace PropertyMap {
        const TYPE_QNAME = "0x4::property_map::PropertyMap";
        function type(): TypeDescriptor<PropertyMap>;
    }
    interface PropertyValue {
        type: number;
        value: string;
    }
    namespace PropertyValue {
        const TYPE_QNAME = "0x4::property_map::PropertyValue";
        function type(): TypeDescriptor<PropertyValue>;
    }
    interface PropertyValueInstance extends TypedEventInstance<PropertyValue> {
        data_decoded: PropertyValue;
        type_arguments: [];
    }
    namespace entry { }
    namespace view { }
}
export declare function loadAllTypes(coder: MoveCoder): void;
//# sourceMappingURL=0x4.d.ts.map