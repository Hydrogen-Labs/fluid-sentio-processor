"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiCodegen = exports.codegen = void 0;
const tslib_1 = require("tslib");
const client_1 = require("@mysten/sui.js/client");
const fs = tslib_1.__importStar(require("fs"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const move_1 = require("@typemove/move");
const path_1 = require("path");
const sui_chain_adapter_js_1 = require("../sui-chain-adapter.js");
async function codegen(abisDir, outDir = (0, path_1.join)('src', 'types', 'sui'), endpoint, genExample = false, builtin = false) {
    if (!fs.existsSync(abisDir)) {
        console.error(chalk_1.default.red(`ABIs directory ${abisDir} does not exist`));
        return 0;
    }
    try {
        const gen = new SuiCodegen(endpoint);
        const numFiles = await gen.generate(abisDir, outDir, builtin);
        if (numFiles > 0) {
            console.log(chalk_1.default.green(`Generated for ${numFiles} accounts for Sui to ${outDir}`));
        }
        else {
            console.error(chalk_1.default.red(`No account found`));
        }
        return numFiles;
    }
    catch (e) {
        console.error(chalk_1.default.red(`Failed to generate for ${abisDir}, please check if ABI json files are valid`));
        console.log(e);
        return 0;
    }
}
exports.codegen = codegen;
class SuiCodegen extends move_1.AbstractCodegen {
    ADDRESS_TYPE = 'string';
    SYSTEM_PACKAGE = '@typemove/sui';
    // ADDRESS_TYPE = 'string'
    // MAIN_NET = SuiNetwork.MAIN_NET
    // TEST_NET = SuiNetwork.TEST_NET
    PREFIX = 'Sui';
    // STRUCT_FIELD_NAME = 'fields'
    // GENERATE_ON_ENTRY = true
    PAYLOAD_OPTIONAL = true;
    constructor(endpoint) {
        super(new sui_chain_adapter_js_1.SuiChainAdapter(new client_1.SuiClient({ url: endpoint })));
    }
    readModulesFile(fullPath) {
        const res = super.readModulesFile(fullPath);
        if (res.result) {
            return res.result;
        }
        return res;
    }
    generateStructs(module, struct, events) {
        let content = '';
        switch ((0, move_1.structQname)(module, struct)) {
            // TODO they should still have module code generated
            case '0x1::ascii::Char':
            case '0x1::ascii::String':
            case '0x2::object::ID':
                content += `export type ${struct.name} = string`;
                break;
            case '0x2::coin::Coin':
                content += `export type ${struct.name}<T> = string`;
                break;
            case '0x2::balance::Balance':
                content += `export type ${struct.name}<T> = bigint`;
                break;
            case '0x1::option::Option':
                content += `export type Option<T> = T | undefined`;
                break;
        }
        return content + super.generateStructs(module, struct, events, content !== '');
    }
    generateForEvents(module, struct) {
        switch ((0, move_1.structQname)(module, struct)) {
            case '0x1::ascii::Char':
            case '0x1::ascii::String':
            case '0x2::object::ID':
            case '0x2::coin::Coin':
            case '0x1::option::Option':
            case '0x2::balance::Balance':
                return '';
        }
        return super.generateForEvents(module, struct);
    }
    generateExtra(address, module) {
        const funcs = module.exposedFunctions.map((f) => this.generateBuilderForFunction(address || module.address, module, f));
        const viewFuncs = module.exposedFunctions.map((f) => this.generateViewFunction(module, f));
        return `
    export namespace builder {
      ${funcs.join('\n')}
    }
    export namespace view {
      ${viewFuncs.join('\n')}
    }
    `;
    }
    generateArgs(module, func) {
        const args = [];
        const argsLen = func.params.length;
        for (const [idx, arg] of func.params.entries()) {
            if (idx === argsLen - 1 && arg.qname === '0x2::tx_context::TxContext') {
                // no op
            }
            else if (arg.reference) {
                args.push({
                    paramType: `${this.ADDRESS_TYPE} | TransactionObjectArgument | TransactionArgument`,
                    callValue: `_args.push(transactionArgumentOrObject(args[${idx}], tx))`
                });
            }
            else if (arg.isVector()) {
                args.push({
                    paramType: `(${this.ADDRESS_TYPE} | TransactionObjectArgument)[] | TransactionArgument`,
                    callValue: `_args.push(transactionArgumentOrVec(args[${idx}], tx))`
                });
            }
            else {
                args.push({
                    paramType: `${this.generateTypeForDescriptor(arg, module.address)} | TransactionArgument`,
                    callValue: `_args.push(transactionArgumentOrPure(args[${idx}], tx))`
                });
            }
        }
        return args;
    }
    generateViewFunction(module, func) {
        if (func.visibility === move_1.InternalMoveFunctionVisibility.PRIVATE) {
            return '';
        }
        const genericString = this.generateFunctionTypeParameters(func);
        const typeParamArg = func.typeParams
            .map((v, idx) => {
            return `TypeDescriptor<T${idx}> | string`;
        })
            .join(',');
        const args = this.generateArgs(module, func);
        const returnType = `${this.generateFunctionReturnTypeParameters(func, module.address)}`;
        return `export async function ${(0, move_1.camel)((0, move_1.normalizeToJSName)(func.name))}${genericString}(
      client: SuiClient,
      args: [${args.map((a) => a.paramType).join(',')}],
      ${typeParamArg.length > 0 ? `typeArguments: [${typeParamArg}]` : ``} ): Promise<TypedDevInspectResults<${returnType}>> {
      const tx = new TransactionBlock()
      builder.${(0, move_1.camel)((0, move_1.normalizeToJSName)(func.name))}(tx, args ${typeParamArg.length > 0 ? `, typeArguments` : ''})
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS
      })
      
      return (await getMoveCoder(client)).decodeDevInspectResult<${returnType}>(inspectRes)
    }`;
    }
    generateBuilderForFunction(address, module, func) {
        if (func.visibility === move_1.InternalMoveFunctionVisibility.PRIVATE && func.isEntry !== true) {
            return '';
        }
        const args = this.generateArgs(module, func);
        const genericString = this.generateFunctionTypeParameters(func);
        const typeParamArg = func.typeParams
            .map((v, idx) => {
            return `TypeDescriptor<T${idx}> | string`;
        })
            .join(',');
        const typeParamToString = func.typeParams
            .map((v, idx) => {
            return `typeof typeArguments[${idx}] === 'string' ? typeArguments[${idx}] : typeArguments[${idx}].getSignature()`;
        })
            .join(',');
        return `export function ${(0, move_1.camel)((0, move_1.normalizeToJSName)(func.name))}${genericString}(tx: TransactionBlock, 
      args: [${args.map((a) => a.paramType).join(',')}],
      ${typeParamArg.length > 0 ? `typeArguments: [${typeParamArg}]` : ``} ):
       TransactionArgument & [ ${'TransactionArgument,'.repeat(args.length)} ] {
      const _args: any[] = []
      ${args.map((a) => a.callValue).join('\n')}
      
      // @ts-ignore
      return tx.moveCall({
        target: "${address}::${module.name}::${func.name}",
        arguments: _args,
        ${typeParamArg.length > 0 ? `typeArguments: [${typeParamToString}]` : ``}
      })
    }`;
    }
    generateImports() {
        return `
      ${super.generateImports()}
      import { ZERO_ADDRESS, TypedDevInspectResults, getMoveCoder } from '@typemove/sui'
      import { TransactionBlock, TransactionArgument, TransactionObjectArgument } from '@mysten/sui.js/transactions'
      import { SuiClient } from '@mysten/sui.js/client'
      import { transactionArgumentOrObject, transactionArgumentOrPure, transactionArgumentOrVec } from '@typemove/sui'
    `;
    }
}
exports.SuiCodegen = SuiCodegen;
//# sourceMappingURL=codegen.js.map