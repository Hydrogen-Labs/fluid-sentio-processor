"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMoveCoder = exports.defaultMoveCoder = exports.MoveCoder = void 0;
const move_1 = require("@typemove/move");
const client_1 = require("@mysten/sui.js/client");
const to_internal_js_1 = require("./to-internal.js");
const sui_chain_adapter_js_1 = require("./sui-chain-adapter.js");
const bcs_1 = require("@mysten/bcs");
const utils_1 = require("@mysten/sui.js/utils");
class MoveCoder extends move_1.AbstractMoveCoder {
    bcs = new bcs_1.BCS((0, bcs_1.getSuiMoveConfig)());
    constructor(client) {
        super(new sui_chain_adapter_js_1.SuiChainAdapter(client));
    }
    load(module, address) {
        let m = this.moduleMapping.get(module.address + '::' + module.name);
        const mDeclared = this.moduleMapping.get(address + '::' + module.name);
        if (m && mDeclared) {
            return m;
        }
        m = (0, to_internal_js_1.toInternalModule)(module);
        this.loadInternal(m, address);
        return m;
    }
    async decode(data, type) {
        switch (type.qname) {
            case '0x1::ascii::Char':
                if (data !== undefined && typeof data !== 'string') {
                    // bcs
                    const byte = (await super.decode(data, type)).byte;
                    return String.fromCharCode(byte);
                }
            case '0x1::ascii::String':
                if (data !== undefined && typeof data !== 'string') {
                    // bcs verified
                    const bytes = (await super.decode(data, type)).bytes;
                    return new TextDecoder().decode(new Uint8Array(bytes));
                }
            case '0x2::object::ID':
                if (data !== undefined && typeof data !== 'string') {
                    // bcs verified
                    const bytes = (await super.decode(data, type)).bytes;
                    return (0, utils_1.normalizeSuiObjectId)(bytes);
                }
            case '0x2::url::Url':
                if (data !== undefined && typeof data !== 'string') {
                    // bcs
                    return (await super.decode(data, type)).url;
                }
            case '0x2::coin::Coin':
                if (data !== undefined && typeof data !== 'string') {
                    // bcs
                    const bytes = (await super.decode(data, type)).id.id.bytes;
                    return new TextDecoder().decode(new Uint8Array(bytes));
                }
                return data;
            case '0x2::balance::Balance':
                if (data.value) {
                    // bcs verfied
                    const balance = await super.decode(data, type);
                    return balance.value;
                }
                return BigInt(data);
            case '0x1::option::Option':
                if (data === null) {
                    return data;
                }
                if (data.vec) {
                    // bcs verifed
                    let vec = await super.decode(data, type);
                    vec = vec.vec;
                    if (vec.length === 0) {
                        return null;
                    }
                    return vec[0];
                }
                return this.decode(data, type.typeArgs[0]);
            case 'Address':
                const str = data;
                return (0, utils_1.normalizeSuiAddress)(str);
            case '0x1::string::String':
                if (typeof data !== 'string') {
                    // bcs
                    return new TextDecoder().decode(new Uint8Array(data.bytes));
                }
            default:
                return super.decode(data, type);
        }
    }
    decodeEvent(event) {
        return this.decodedStruct(event);
    }
    filterAndDecodeEvents(type, resources) {
        if (typeof type === 'string') {
            type = (0, move_1.parseMoveType)(type);
        }
        return this.filterAndDecodeStruct(type, resources);
    }
    async getDynamicFields(objects, keyType = move_1.ANY_TYPE, valueType = move_1.ANY_TYPE) {
        // const type = dynamic_field.Field.TYPE
        // Not using the code above to avoid cycle initialize failed
        const type = new move_1.TypeDescriptor('0x2::dynamic_field::Field');
        type.typeArgs = [keyType, valueType];
        const res = await this.filterAndDecodeObjects(type, objects);
        return res.map((o) => o.data_decoded);
    }
    filterAndDecodeObjects(type, objects) {
        return this.filterAndDecodeStruct(type, objects);
    }
    async decodeFunctionPayload(payload, inputs) {
        const functionType = [payload.package, payload.module, payload.function].join(move_1.SPLITTER);
        const func = await this.getMoveFunction(functionType);
        const params = this.adapter.getMeaningfulFunctionParams(func.params);
        const args = [];
        for (const value of payload.arguments || []) {
            const argValue = value;
            if ('Input' in argValue) {
                const idx = argValue.Input;
                const arg = inputs[idx];
                if (arg.type === 'pure') {
                    args.push(arg.value);
                }
                else if (arg.type === 'object') {
                    // object is not there
                    args.push(undefined);
                }
                else {
                    console.error('unexpected function arg value');
                    args.push(undefined);
                }
                // args.push(arg) // TODO check why ts not work using arg.push(arg)
            }
            else {
                args.push(undefined);
            }
        }
        const argumentsTyped = await this.decodeArray(args, params, false);
        return {
            ...payload,
            arguments_decoded: argumentsTyped
        };
    }
    async _registerBCSType(qname) {
        if (this.bcs.hasType(qname)) {
            return;
        }
        const moveStruct = await this.getMoveStruct(qname);
        const structDef = {};
        for (const field of moveStruct.fields) {
            structDef[field.name] = field.type.getNormalizedSignature();
        }
        let typeName = qname;
        const generics = moveStruct.typeParams.map((p, idx) => 'T' + idx).join(', ');
        if (generics) {
            typeName = typeName + '<' + generics + '>';
        }
        this.bcs.registerStructType(typeName, structDef);
        for (const field of moveStruct.fields) {
            await this.registerBCSTypes(field.type);
        }
    }
    bcsRegistered = new Set();
    async registerBCSTypes(type) {
        const sig = type.getNormalizedSignature();
        if (this.bcsRegistered.has(sig)) {
            return;
        }
        this.bcsRegistered.add(sig);
        await this._registerBCSType('0x1::string::String');
        for (const typeArg of type.dependedTypes()) {
            await this._registerBCSType(typeArg);
        }
    }
    async decodeBCS(type, data, encoding) {
        await this.registerBCSTypes(type);
        return this.bcs.de(type.getNormalizedSignature(), data, encoding);
    }
    async decodeDevInspectResult(inspectRes) {
        const returnValues = [];
        if (inspectRes.results != null) {
            for (const r of inspectRes.results) {
                if (r.returnValues) {
                    for (const returnValue of r.returnValues) {
                        const type = (0, move_1.parseMoveType)(returnValue[1]);
                        const bcsDecoded = await this.decodeBCS(type, new Uint8Array(returnValue[0]));
                        const decoded = await this.decodedType(bcsDecoded, type);
                        returnValues.push(decoded);
                    }
                }
                else {
                    returnValues.push(null);
                }
            }
        }
        return { ...inspectRes, results_decoded: returnValues };
    }
}
exports.MoveCoder = MoveCoder;
const DEFAULT_ENDPOINT = 'https://fullnode.mainnet.sui.io/';
const CODER_MAP = new Map();
const CHAIN_ID_CODER_MAP = new Map();
function defaultMoveCoder(endpoint = DEFAULT_ENDPOINT) {
    let coder = CODER_MAP.get(endpoint);
    if (!coder) {
        coder = new MoveCoder(new client_1.SuiClient({ url: endpoint }));
        CODER_MAP.set(endpoint, coder);
    }
    return coder;
}
exports.defaultMoveCoder = defaultMoveCoder;
const PROVIDER_CODER_MAP = new Map();
let DEFAULT_CHAIN_ID;
async function getMoveCoder(client) {
    let coder = PROVIDER_CODER_MAP.get(client);
    if (!coder) {
        coder = new MoveCoder(client);
        // TODO how to dedup
        const id = await client.getChainIdentifier();
        const defaultCoder = defaultMoveCoder();
        if (!DEFAULT_CHAIN_ID) {
            DEFAULT_CHAIN_ID = await defaultCoder.adapter.getChainId();
        }
        if (id === DEFAULT_CHAIN_ID) {
            coder = defaultCoder;
        }
        PROVIDER_CODER_MAP.set(client, coder);
    }
    return coder;
}
exports.getMoveCoder = getMoveCoder;
//# sourceMappingURL=move-coder.js.map