"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toInternalModule = void 0;
const move_1 = require("@typemove/move");
function toInternalModule(module) {
    return {
        address: module.address,
        exposedFunctions: Object.entries(module.exposedFunctions).map(([n, f]) => toInternalFunction(n, f)),
        name: module.name,
        structs: Object.entries(module.structs).map(([n, s]) => toInternalStruct(n, s)),
    };
}
exports.toInternalModule = toInternalModule;
function toInternalFunction(name, func) {
    let visibility;
    switch (func.visibility) {
        case 'Private':
            visibility = move_1.InternalMoveFunctionVisibility.PRIVATE;
            break;
        case 'Public':
            visibility = move_1.InternalMoveFunctionVisibility.PUBLIC;
            break;
        case 'Friend':
            visibility = move_1.InternalMoveFunctionVisibility.FRIEND;
            break;
        default:
            throw Error('No visibility for function' + name);
    }
    return {
        typeParams: func.typeParameters.map((p) => {
            return { constraints: p.abilities };
        }),
        isEntry: func.isEntry,
        name: name,
        params: func.parameters.map(toTypeDescriptor),
        return: func.return.map(toTypeDescriptor),
        visibility: visibility,
    };
}
function toInternalStruct(name, struct) {
    return {
        abilities: struct.abilities.abilities,
        fields: struct.fields.map(toInternalField),
        typeParams: struct.typeParameters.map((p) => {
            return { constraints: p.constraints.abilities };
        }),
        isNative: false,
        name: name,
    };
}
function toInternalField(module) {
    return {
        name: module.name,
        type: toTypeDescriptor(module.type),
    };
}
function toTypeDescriptor(normalizedType) {
    if (typeof normalizedType === 'string') {
        return new move_1.TypeDescriptor(normalizedType);
    }
    if ('Struct' in normalizedType) {
        const qname = [normalizedType.Struct.address, normalizedType.Struct.module, normalizedType.Struct.name].join(move_1.SPLITTER);
        const args = normalizedType.Struct.typeArguments.map(toTypeDescriptor);
        return new move_1.TypeDescriptor(qname, args);
    }
    if ('Vector' in normalizedType) {
        return new move_1.TypeDescriptor('Vector', [toTypeDescriptor(normalizedType.Vector)]);
    }
    if ('TypeParameter' in normalizedType) {
        return new move_1.TypeDescriptor('T' + normalizedType.TypeParameter);
    }
    if ('Reference' in normalizedType) {
        const res = toTypeDescriptor(normalizedType.Reference);
        res.reference = true;
        return res;
    }
    if ('MutableReference' in normalizedType) {
        const res = toTypeDescriptor(normalizedType.MutableReference);
        res.reference = true;
        res.mutable = true;
        return res;
    }
    throw new Error('Unexpected sui type');
}
//# sourceMappingURL=to-internal.js.map