/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* Generated types for 0x1, original address 0x1 */
import { TypeDescriptor, ANY_TYPE } from "@typemove/move";
import { defaultMoveCoder } from "@typemove/sui";
import { ZERO_ADDRESS, getMoveCoder, } from "@typemove/sui";
import { TransactionBlock, } from "@mysten/sui.js/transactions";
import { transactionArgumentOrObject, transactionArgumentOrPure, transactionArgumentOrVec, } from "@typemove/sui";
export var address;
(function (address) {
    let builder;
    (function (builder) {
        function length(tx, args) {
            const _args = [];
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::address::length",
                arguments: _args,
            });
        }
        builder.length = length;
    })(builder = address.builder || (address.builder = {}));
    let view;
    (function (view) {
        async function length(client, args) {
            const tx = new TransactionBlock();
            builder.length(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.length = length;
    })(view = address.view || (address.view = {}));
})(address || (address = {}));
export var ascii;
(function (ascii) {
    let Char;
    (function (Char) {
        Char.TYPE_QNAME = "0x1::ascii::Char";
        const TYPE = new TypeDescriptor(Char.TYPE_QNAME);
        function type() {
            return TYPE.apply();
        }
        Char.type = type;
    })(Char = ascii.Char || (ascii.Char = {}));
    let String;
    (function (String) {
        String.TYPE_QNAME = "0x1::ascii::String";
        const TYPE = new TypeDescriptor(String.TYPE_QNAME);
        function type() {
            return TYPE.apply();
        }
        String.type = type;
    })(String = ascii.String || (ascii.String = {}));
    let builder;
    (function (builder) {
        function allCharactersPrintable(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::all_characters_printable",
                arguments: _args,
            });
        }
        builder.allCharactersPrintable = allCharactersPrintable;
        function append(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::append",
                arguments: _args,
            });
        }
        builder.append = append;
        function asBytes(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::as_bytes",
                arguments: _args,
            });
        }
        builder.asBytes = asBytes;
        function byte(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::byte",
                arguments: _args,
            });
        }
        builder.byte = byte;
        function char(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::char",
                arguments: _args,
            });
        }
        builder.char = char;
        function indexOf(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrObject(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::index_of",
                arguments: _args,
            });
        }
        builder.indexOf = indexOf;
        function insert(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            _args.push(transactionArgumentOrPure(args[2], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::insert",
                arguments: _args,
            });
        }
        builder.insert = insert;
        function intoBytes(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::into_bytes",
                arguments: _args,
            });
        }
        builder.intoBytes = intoBytes;
        function isEmpty(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::is_empty",
                arguments: _args,
            });
        }
        builder.isEmpty = isEmpty;
        function isPrintableChar(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::is_printable_char",
                arguments: _args,
            });
        }
        builder.isPrintableChar = isPrintableChar;
        function isValidChar(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::is_valid_char",
                arguments: _args,
            });
        }
        builder.isValidChar = isValidChar;
        function length(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::length",
                arguments: _args,
            });
        }
        builder.length = length;
        function popChar(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::pop_char",
                arguments: _args,
            });
        }
        builder.popChar = popChar;
        function pushChar(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::push_char",
                arguments: _args,
            });
        }
        builder.pushChar = pushChar;
        function string_(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrVec(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::string",
                arguments: _args,
            });
        }
        builder.string_ = string_;
        function substring(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            _args.push(transactionArgumentOrPure(args[2], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::substring",
                arguments: _args,
            });
        }
        builder.substring = substring;
        function toLowercase(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::to_lowercase",
                arguments: _args,
            });
        }
        builder.toLowercase = toLowercase;
        function toUppercase(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::to_uppercase",
                arguments: _args,
            });
        }
        builder.toUppercase = toUppercase;
        function tryString(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrVec(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::ascii::try_string",
                arguments: _args,
            });
        }
        builder.tryString = tryString;
    })(builder = ascii.builder || (ascii.builder = {}));
    let view;
    (function (view) {
        async function allCharactersPrintable(client, args) {
            const tx = new TransactionBlock();
            builder.allCharactersPrintable(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.allCharactersPrintable = allCharactersPrintable;
        async function append(client, args) {
            const tx = new TransactionBlock();
            builder.append(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.append = append;
        async function asBytes(client, args) {
            const tx = new TransactionBlock();
            builder.asBytes(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.asBytes = asBytes;
        async function byte(client, args) {
            const tx = new TransactionBlock();
            builder.byte(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.byte = byte;
        async function char(client, args) {
            const tx = new TransactionBlock();
            builder.char(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.char = char;
        async function indexOf(client, args) {
            const tx = new TransactionBlock();
            builder.indexOf(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.indexOf = indexOf;
        async function insert(client, args) {
            const tx = new TransactionBlock();
            builder.insert(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.insert = insert;
        async function intoBytes(client, args) {
            const tx = new TransactionBlock();
            builder.intoBytes(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.intoBytes = intoBytes;
        async function isEmpty(client, args) {
            const tx = new TransactionBlock();
            builder.isEmpty(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.isEmpty = isEmpty;
        async function isPrintableChar(client, args) {
            const tx = new TransactionBlock();
            builder.isPrintableChar(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.isPrintableChar = isPrintableChar;
        async function isValidChar(client, args) {
            const tx = new TransactionBlock();
            builder.isValidChar(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.isValidChar = isValidChar;
        async function length(client, args) {
            const tx = new TransactionBlock();
            builder.length(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.length = length;
        async function popChar(client, args) {
            const tx = new TransactionBlock();
            builder.popChar(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.popChar = popChar;
        async function pushChar(client, args) {
            const tx = new TransactionBlock();
            builder.pushChar(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.pushChar = pushChar;
        async function string_(client, args) {
            const tx = new TransactionBlock();
            builder.string_(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.string_ = string_;
        async function substring(client, args) {
            const tx = new TransactionBlock();
            builder.substring(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.substring = substring;
        async function toLowercase(client, args) {
            const tx = new TransactionBlock();
            builder.toLowercase(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.toLowercase = toLowercase;
        async function toUppercase(client, args) {
            const tx = new TransactionBlock();
            builder.toUppercase(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.toUppercase = toUppercase;
        async function tryString(client, args) {
            const tx = new TransactionBlock();
            builder.tryString(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.tryString = tryString;
    })(view = ascii.view || (ascii.view = {}));
})(ascii || (ascii = {}));
export var bcs;
(function (bcs) {
    let builder;
    (function (builder) {
        function toBytes(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::bcs::to_bytes",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.toBytes = toBytes;
    })(builder = bcs.builder || (bcs.builder = {}));
    let view;
    (function (view) {
        async function toBytes(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.toBytes(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.toBytes = toBytes;
    })(view = bcs.view || (bcs.view = {}));
})(bcs || (bcs = {}));
export var bit_vector;
(function (bit_vector) {
    let BitVector;
    (function (BitVector) {
        BitVector.TYPE_QNAME = "0x1::bit_vector::BitVector";
        const TYPE = new TypeDescriptor(BitVector.TYPE_QNAME);
        function type() {
            return TYPE.apply();
        }
        BitVector.type = type;
    })(BitVector = bit_vector.BitVector || (bit_vector.BitVector = {}));
    let builder;
    (function (builder) {
        function isIndexSet(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::bit_vector::is_index_set",
                arguments: _args,
            });
        }
        builder.isIndexSet = isIndexSet;
        function length(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::bit_vector::length",
                arguments: _args,
            });
        }
        builder.length = length;
        function longestSetSequenceStartingAt(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::bit_vector::longest_set_sequence_starting_at",
                arguments: _args,
            });
        }
        builder.longestSetSequenceStartingAt = longestSetSequenceStartingAt;
        function new_(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::bit_vector::new",
                arguments: _args,
            });
        }
        builder.new_ = new_;
        function set(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::bit_vector::set",
                arguments: _args,
            });
        }
        builder.set = set;
        function shiftLeft(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::bit_vector::shift_left",
                arguments: _args,
            });
        }
        builder.shiftLeft = shiftLeft;
        function unset(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::bit_vector::unset",
                arguments: _args,
            });
        }
        builder.unset = unset;
    })(builder = bit_vector.builder || (bit_vector.builder = {}));
    let view;
    (function (view) {
        async function isIndexSet(client, args) {
            const tx = new TransactionBlock();
            builder.isIndexSet(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.isIndexSet = isIndexSet;
        async function length(client, args) {
            const tx = new TransactionBlock();
            builder.length(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.length = length;
        async function longestSetSequenceStartingAt(client, args) {
            const tx = new TransactionBlock();
            builder.longestSetSequenceStartingAt(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.longestSetSequenceStartingAt = longestSetSequenceStartingAt;
        async function new_(client, args) {
            const tx = new TransactionBlock();
            builder.new_(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.new_ = new_;
        async function set(client, args) {
            const tx = new TransactionBlock();
            builder.set(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.set = set;
        async function shiftLeft(client, args) {
            const tx = new TransactionBlock();
            builder.shiftLeft(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.shiftLeft = shiftLeft;
        async function unset(client, args) {
            const tx = new TransactionBlock();
            builder.unset(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.unset = unset;
    })(view = bit_vector.view || (bit_vector.view = {}));
})(bit_vector || (bit_vector = {}));
export var debug;
(function (debug) {
    let builder;
    (function (builder) {
        function print(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::debug::print",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.print = print;
        function printStackTrace(tx, args) {
            const _args = [];
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::debug::print_stack_trace",
                arguments: _args,
            });
        }
        builder.printStackTrace = printStackTrace;
    })(builder = debug.builder || (debug.builder = {}));
    let view;
    (function (view) {
        async function print(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.print(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.print = print;
        async function printStackTrace(client, args) {
            const tx = new TransactionBlock();
            builder.printStackTrace(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.printStackTrace = printStackTrace;
    })(view = debug.view || (debug.view = {}));
})(debug || (debug = {}));
export var fixed_point32;
(function (fixed_point32) {
    let FixedPoint32;
    (function (FixedPoint32) {
        FixedPoint32.TYPE_QNAME = "0x1::fixed_point32::FixedPoint32";
        const TYPE = new TypeDescriptor(FixedPoint32.TYPE_QNAME);
        function type() {
            return TYPE.apply();
        }
        FixedPoint32.type = type;
    })(FixedPoint32 = fixed_point32.FixedPoint32 || (fixed_point32.FixedPoint32 = {}));
    let builder;
    (function (builder) {
        function createFromRational(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::fixed_point32::create_from_rational",
                arguments: _args,
            });
        }
        builder.createFromRational = createFromRational;
        function createFromRawValue(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::fixed_point32::create_from_raw_value",
                arguments: _args,
            });
        }
        builder.createFromRawValue = createFromRawValue;
        function divideU64(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::fixed_point32::divide_u64",
                arguments: _args,
            });
        }
        builder.divideU64 = divideU64;
        function getRawValue(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::fixed_point32::get_raw_value",
                arguments: _args,
            });
        }
        builder.getRawValue = getRawValue;
        function isZero(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::fixed_point32::is_zero",
                arguments: _args,
            });
        }
        builder.isZero = isZero;
        function multiplyU64(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::fixed_point32::multiply_u64",
                arguments: _args,
            });
        }
        builder.multiplyU64 = multiplyU64;
    })(builder = fixed_point32.builder || (fixed_point32.builder = {}));
    let view;
    (function (view) {
        async function createFromRational(client, args) {
            const tx = new TransactionBlock();
            builder.createFromRational(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.createFromRational = createFromRational;
        async function createFromRawValue(client, args) {
            const tx = new TransactionBlock();
            builder.createFromRawValue(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.createFromRawValue = createFromRawValue;
        async function divideU64(client, args) {
            const tx = new TransactionBlock();
            builder.divideU64(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.divideU64 = divideU64;
        async function getRawValue(client, args) {
            const tx = new TransactionBlock();
            builder.getRawValue(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.getRawValue = getRawValue;
        async function isZero(client, args) {
            const tx = new TransactionBlock();
            builder.isZero(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.isZero = isZero;
        async function multiplyU64(client, args) {
            const tx = new TransactionBlock();
            builder.multiplyU64(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.multiplyU64 = multiplyU64;
    })(view = fixed_point32.view || (fixed_point32.view = {}));
})(fixed_point32 || (fixed_point32 = {}));
export var hash;
(function (hash) {
    let builder;
    (function (builder) {
        function sha2256(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrVec(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::hash::sha2_256",
                arguments: _args,
            });
        }
        builder.sha2256 = sha2256;
        function sha3256(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrVec(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::hash::sha3_256",
                arguments: _args,
            });
        }
        builder.sha3256 = sha3256;
    })(builder = hash.builder || (hash.builder = {}));
    let view;
    (function (view) {
        async function sha2256(client, args) {
            const tx = new TransactionBlock();
            builder.sha2256(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.sha2256 = sha2256;
        async function sha3256(client, args) {
            const tx = new TransactionBlock();
            builder.sha3256(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.sha3256 = sha3256;
    })(view = hash.view || (hash.view = {}));
})(hash || (hash = {}));
export var option;
(function (option) {
    let Option;
    (function (Option) {
        Option.TYPE_QNAME = "0x1::option::Option";
        const TYPE = new TypeDescriptor(Option.TYPE_QNAME);
        function type(arg0 = ANY_TYPE) {
            return TYPE.apply(arg0);
        }
        Option.type = type;
    })(Option = option.Option || (option.Option = {}));
    let builder;
    (function (builder) {
        function borrow(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::borrow",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.borrow = borrow;
        function borrowMut(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::borrow_mut",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.borrowMut = borrowMut;
        function borrowWithDefault(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrObject(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::borrow_with_default",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.borrowWithDefault = borrowWithDefault;
        function contains(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrObject(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::contains",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.contains = contains;
        function destroyNone(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::destroy_none",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.destroyNone = destroyNone;
        function destroySome(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::destroy_some",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.destroySome = destroySome;
        function destroyWithDefault(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::destroy_with_default",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.destroyWithDefault = destroyWithDefault;
        function extract(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::extract",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.extract = extract;
        function fill(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::fill",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.fill = fill;
        function getWithDefault(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::get_with_default",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.getWithDefault = getWithDefault;
        function isNone(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::is_none",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.isNone = isNone;
        function isSome(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::is_some",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.isSome = isSome;
        function none(tx, args, typeArguments) {
            const _args = [];
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::none",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.none = none;
        function some(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::some",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.some = some;
        function swap(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::swap",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.swap = swap;
        function swapOrFill(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::swap_or_fill",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.swapOrFill = swapOrFill;
        function toVec(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::option::to_vec",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.toVec = toVec;
    })(builder = option.builder || (option.builder = {}));
    let view;
    (function (view) {
        async function borrow(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.borrow(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.borrow = borrow;
        async function borrowMut(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.borrowMut(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.borrowMut = borrowMut;
        async function borrowWithDefault(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.borrowWithDefault(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.borrowWithDefault = borrowWithDefault;
        async function contains(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.contains(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.contains = contains;
        async function destroyNone(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.destroyNone(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.destroyNone = destroyNone;
        async function destroySome(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.destroySome(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.destroySome = destroySome;
        async function destroyWithDefault(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.destroyWithDefault(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.destroyWithDefault = destroyWithDefault;
        async function extract(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.extract(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.extract = extract;
        async function fill(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.fill(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.fill = fill;
        async function getWithDefault(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.getWithDefault(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.getWithDefault = getWithDefault;
        async function isNone(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.isNone(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.isNone = isNone;
        async function isSome(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.isSome(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.isSome = isSome;
        async function none(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.none(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.none = none;
        async function some(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.some(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.some = some;
        async function swap(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.swap(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.swap = swap;
        async function swapOrFill(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.swapOrFill(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.swapOrFill = swapOrFill;
        async function toVec(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.toVec(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.toVec = toVec;
    })(view = option.view || (option.view = {}));
})(option || (option = {}));
export var string_;
(function (string_) {
    let String;
    (function (String) {
        String.TYPE_QNAME = "0x1::string::String";
        const TYPE = new TypeDescriptor(String.TYPE_QNAME);
        function type() {
            return TYPE.apply();
        }
        String.type = type;
    })(String = string_.String || (string_.String = {}));
    let builder;
    (function (builder) {
        function append(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::append",
                arguments: _args,
            });
        }
        builder.append = append;
        function appendUtf8(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrVec(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::append_utf8",
                arguments: _args,
            });
        }
        builder.appendUtf8 = appendUtf8;
        function asBytes(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::as_bytes",
                arguments: _args,
            });
        }
        builder.asBytes = asBytes;
        function bytes(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::bytes",
                arguments: _args,
            });
        }
        builder.bytes = bytes;
        function fromAscii(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::from_ascii",
                arguments: _args,
            });
        }
        builder.fromAscii = fromAscii;
        function indexOf(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrObject(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::index_of",
                arguments: _args,
            });
        }
        builder.indexOf = indexOf;
        function insert(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            _args.push(transactionArgumentOrPure(args[2], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::insert",
                arguments: _args,
            });
        }
        builder.insert = insert;
        function intoBytes(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::into_bytes",
                arguments: _args,
            });
        }
        builder.intoBytes = intoBytes;
        function isEmpty(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::is_empty",
                arguments: _args,
            });
        }
        builder.isEmpty = isEmpty;
        function length(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::length",
                arguments: _args,
            });
        }
        builder.length = length;
        function subString(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            _args.push(transactionArgumentOrPure(args[2], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::sub_string",
                arguments: _args,
            });
        }
        builder.subString = subString;
        function substring(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            _args.push(transactionArgumentOrPure(args[2], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::substring",
                arguments: _args,
            });
        }
        builder.substring = substring;
        function toAscii(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::to_ascii",
                arguments: _args,
            });
        }
        builder.toAscii = toAscii;
        function tryUtf8(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrVec(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::try_utf8",
                arguments: _args,
            });
        }
        builder.tryUtf8 = tryUtf8;
        function utf8(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrVec(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::string::utf8",
                arguments: _args,
            });
        }
        builder.utf8 = utf8;
    })(builder = string_.builder || (string_.builder = {}));
    let view;
    (function (view) {
        async function append(client, args) {
            const tx = new TransactionBlock();
            builder.append(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.append = append;
        async function appendUtf8(client, args) {
            const tx = new TransactionBlock();
            builder.appendUtf8(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.appendUtf8 = appendUtf8;
        async function asBytes(client, args) {
            const tx = new TransactionBlock();
            builder.asBytes(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.asBytes = asBytes;
        async function bytes(client, args) {
            const tx = new TransactionBlock();
            builder.bytes(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.bytes = bytes;
        async function fromAscii(client, args) {
            const tx = new TransactionBlock();
            builder.fromAscii(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.fromAscii = fromAscii;
        async function indexOf(client, args) {
            const tx = new TransactionBlock();
            builder.indexOf(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.indexOf = indexOf;
        async function insert(client, args) {
            const tx = new TransactionBlock();
            builder.insert(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.insert = insert;
        async function intoBytes(client, args) {
            const tx = new TransactionBlock();
            builder.intoBytes(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.intoBytes = intoBytes;
        async function isEmpty(client, args) {
            const tx = new TransactionBlock();
            builder.isEmpty(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.isEmpty = isEmpty;
        async function length(client, args) {
            const tx = new TransactionBlock();
            builder.length(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.length = length;
        async function subString(client, args) {
            const tx = new TransactionBlock();
            builder.subString(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.subString = subString;
        async function substring(client, args) {
            const tx = new TransactionBlock();
            builder.substring(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.substring = substring;
        async function toAscii(client, args) {
            const tx = new TransactionBlock();
            builder.toAscii(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.toAscii = toAscii;
        async function tryUtf8(client, args) {
            const tx = new TransactionBlock();
            builder.tryUtf8(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.tryUtf8 = tryUtf8;
        async function utf8(client, args) {
            const tx = new TransactionBlock();
            builder.utf8(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.utf8 = utf8;
    })(view = string_.view || (string_.view = {}));
})(string_ || (string_ = {}));
export var type_name;
(function (type_name) {
    let TypeName;
    (function (TypeName) {
        TypeName.TYPE_QNAME = "0x1::type_name::TypeName";
        const TYPE = new TypeDescriptor(TypeName.TYPE_QNAME);
        function type() {
            return TYPE.apply();
        }
        TypeName.type = type;
    })(TypeName = type_name.TypeName || (type_name.TypeName = {}));
    let builder;
    (function (builder) {
        function borrowString(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::type_name::borrow_string",
                arguments: _args,
            });
        }
        builder.borrowString = borrowString;
        function get(tx, args, typeArguments) {
            const _args = [];
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::type_name::get",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.get = get;
        function getAddress(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::type_name::get_address",
                arguments: _args,
            });
        }
        builder.getAddress = getAddress;
        function getModule(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::type_name::get_module",
                arguments: _args,
            });
        }
        builder.getModule = getModule;
        function getWithOriginalIds(tx, args, typeArguments) {
            const _args = [];
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::type_name::get_with_original_ids",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.getWithOriginalIds = getWithOriginalIds;
        function intoString(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::type_name::into_string",
                arguments: _args,
            });
        }
        builder.intoString = intoString;
        function isPrimitive(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::type_name::is_primitive",
                arguments: _args,
            });
        }
        builder.isPrimitive = isPrimitive;
    })(builder = type_name.builder || (type_name.builder = {}));
    let view;
    (function (view) {
        async function borrowString(client, args) {
            const tx = new TransactionBlock();
            builder.borrowString(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.borrowString = borrowString;
        async function get(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.get(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.get = get;
        async function getAddress(client, args) {
            const tx = new TransactionBlock();
            builder.getAddress(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.getAddress = getAddress;
        async function getModule(client, args) {
            const tx = new TransactionBlock();
            builder.getModule(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.getModule = getModule;
        async function getWithOriginalIds(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.getWithOriginalIds(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.getWithOriginalIds = getWithOriginalIds;
        async function intoString(client, args) {
            const tx = new TransactionBlock();
            builder.intoString(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.intoString = intoString;
        async function isPrimitive(client, args) {
            const tx = new TransactionBlock();
            builder.isPrimitive(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.isPrimitive = isPrimitive;
    })(view = type_name.view || (type_name.view = {}));
})(type_name || (type_name = {}));
export var u128;
(function (u128) {
    let builder;
    (function (builder) {
        function diff(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u128::diff",
                arguments: _args,
            });
        }
        builder.diff = diff;
        function divideAndRoundUp(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u128::divide_and_round_up",
                arguments: _args,
            });
        }
        builder.divideAndRoundUp = divideAndRoundUp;
        function max(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u128::max",
                arguments: _args,
            });
        }
        builder.max = max;
        function min(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u128::min",
                arguments: _args,
            });
        }
        builder.min = min;
        function pow(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u128::pow",
                arguments: _args,
            });
        }
        builder.pow = pow;
        function sqrt(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u128::sqrt",
                arguments: _args,
            });
        }
        builder.sqrt = sqrt;
    })(builder = u128.builder || (u128.builder = {}));
    let view;
    (function (view) {
        async function diff(client, args) {
            const tx = new TransactionBlock();
            builder.diff(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.diff = diff;
        async function divideAndRoundUp(client, args) {
            const tx = new TransactionBlock();
            builder.divideAndRoundUp(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.divideAndRoundUp = divideAndRoundUp;
        async function max(client, args) {
            const tx = new TransactionBlock();
            builder.max(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.max = max;
        async function min(client, args) {
            const tx = new TransactionBlock();
            builder.min(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.min = min;
        async function pow(client, args) {
            const tx = new TransactionBlock();
            builder.pow(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.pow = pow;
        async function sqrt(client, args) {
            const tx = new TransactionBlock();
            builder.sqrt(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.sqrt = sqrt;
    })(view = u128.view || (u128.view = {}));
})(u128 || (u128 = {}));
export var u16;
(function (u16) {
    let builder;
    (function (builder) {
        function diff(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u16::diff",
                arguments: _args,
            });
        }
        builder.diff = diff;
        function divideAndRoundUp(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u16::divide_and_round_up",
                arguments: _args,
            });
        }
        builder.divideAndRoundUp = divideAndRoundUp;
        function max(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u16::max",
                arguments: _args,
            });
        }
        builder.max = max;
        function min(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u16::min",
                arguments: _args,
            });
        }
        builder.min = min;
        function pow(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u16::pow",
                arguments: _args,
            });
        }
        builder.pow = pow;
        function sqrt(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u16::sqrt",
                arguments: _args,
            });
        }
        builder.sqrt = sqrt;
    })(builder = u16.builder || (u16.builder = {}));
    let view;
    (function (view) {
        async function diff(client, args) {
            const tx = new TransactionBlock();
            builder.diff(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.diff = diff;
        async function divideAndRoundUp(client, args) {
            const tx = new TransactionBlock();
            builder.divideAndRoundUp(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.divideAndRoundUp = divideAndRoundUp;
        async function max(client, args) {
            const tx = new TransactionBlock();
            builder.max(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.max = max;
        async function min(client, args) {
            const tx = new TransactionBlock();
            builder.min(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.min = min;
        async function pow(client, args) {
            const tx = new TransactionBlock();
            builder.pow(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.pow = pow;
        async function sqrt(client, args) {
            const tx = new TransactionBlock();
            builder.sqrt(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.sqrt = sqrt;
    })(view = u16.view || (u16.view = {}));
})(u16 || (u16 = {}));
export var u256;
(function (u256) {
    let builder;
    (function (builder) {
        function diff(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u256::diff",
                arguments: _args,
            });
        }
        builder.diff = diff;
        function divideAndRoundUp(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u256::divide_and_round_up",
                arguments: _args,
            });
        }
        builder.divideAndRoundUp = divideAndRoundUp;
        function max(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u256::max",
                arguments: _args,
            });
        }
        builder.max = max;
        function min(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u256::min",
                arguments: _args,
            });
        }
        builder.min = min;
        function pow(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u256::pow",
                arguments: _args,
            });
        }
        builder.pow = pow;
    })(builder = u256.builder || (u256.builder = {}));
    let view;
    (function (view) {
        async function diff(client, args) {
            const tx = new TransactionBlock();
            builder.diff(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.diff = diff;
        async function divideAndRoundUp(client, args) {
            const tx = new TransactionBlock();
            builder.divideAndRoundUp(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.divideAndRoundUp = divideAndRoundUp;
        async function max(client, args) {
            const tx = new TransactionBlock();
            builder.max(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.max = max;
        async function min(client, args) {
            const tx = new TransactionBlock();
            builder.min(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.min = min;
        async function pow(client, args) {
            const tx = new TransactionBlock();
            builder.pow(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.pow = pow;
    })(view = u256.view || (u256.view = {}));
})(u256 || (u256 = {}));
export var u32;
(function (u32) {
    let builder;
    (function (builder) {
        function diff(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u32::diff",
                arguments: _args,
            });
        }
        builder.diff = diff;
        function divideAndRoundUp(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u32::divide_and_round_up",
                arguments: _args,
            });
        }
        builder.divideAndRoundUp = divideAndRoundUp;
        function max(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u32::max",
                arguments: _args,
            });
        }
        builder.max = max;
        function min(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u32::min",
                arguments: _args,
            });
        }
        builder.min = min;
        function pow(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u32::pow",
                arguments: _args,
            });
        }
        builder.pow = pow;
        function sqrt(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u32::sqrt",
                arguments: _args,
            });
        }
        builder.sqrt = sqrt;
    })(builder = u32.builder || (u32.builder = {}));
    let view;
    (function (view) {
        async function diff(client, args) {
            const tx = new TransactionBlock();
            builder.diff(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.diff = diff;
        async function divideAndRoundUp(client, args) {
            const tx = new TransactionBlock();
            builder.divideAndRoundUp(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.divideAndRoundUp = divideAndRoundUp;
        async function max(client, args) {
            const tx = new TransactionBlock();
            builder.max(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.max = max;
        async function min(client, args) {
            const tx = new TransactionBlock();
            builder.min(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.min = min;
        async function pow(client, args) {
            const tx = new TransactionBlock();
            builder.pow(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.pow = pow;
        async function sqrt(client, args) {
            const tx = new TransactionBlock();
            builder.sqrt(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.sqrt = sqrt;
    })(view = u32.view || (u32.view = {}));
})(u32 || (u32 = {}));
export var u64;
(function (u64) {
    let builder;
    (function (builder) {
        function diff(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u64::diff",
                arguments: _args,
            });
        }
        builder.diff = diff;
        function divideAndRoundUp(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u64::divide_and_round_up",
                arguments: _args,
            });
        }
        builder.divideAndRoundUp = divideAndRoundUp;
        function max(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u64::max",
                arguments: _args,
            });
        }
        builder.max = max;
        function min(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u64::min",
                arguments: _args,
            });
        }
        builder.min = min;
        function pow(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u64::pow",
                arguments: _args,
            });
        }
        builder.pow = pow;
        function sqrt(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u64::sqrt",
                arguments: _args,
            });
        }
        builder.sqrt = sqrt;
    })(builder = u64.builder || (u64.builder = {}));
    let view;
    (function (view) {
        async function diff(client, args) {
            const tx = new TransactionBlock();
            builder.diff(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.diff = diff;
        async function divideAndRoundUp(client, args) {
            const tx = new TransactionBlock();
            builder.divideAndRoundUp(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.divideAndRoundUp = divideAndRoundUp;
        async function max(client, args) {
            const tx = new TransactionBlock();
            builder.max(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.max = max;
        async function min(client, args) {
            const tx = new TransactionBlock();
            builder.min(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.min = min;
        async function pow(client, args) {
            const tx = new TransactionBlock();
            builder.pow(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.pow = pow;
        async function sqrt(client, args) {
            const tx = new TransactionBlock();
            builder.sqrt(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.sqrt = sqrt;
    })(view = u64.view || (u64.view = {}));
})(u64 || (u64 = {}));
export var u8;
(function (u8) {
    let builder;
    (function (builder) {
        function diff(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u8::diff",
                arguments: _args,
            });
        }
        builder.diff = diff;
        function divideAndRoundUp(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u8::divide_and_round_up",
                arguments: _args,
            });
        }
        builder.divideAndRoundUp = divideAndRoundUp;
        function max(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u8::max",
                arguments: _args,
            });
        }
        builder.max = max;
        function min(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u8::min",
                arguments: _args,
            });
        }
        builder.min = min;
        function pow(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u8::pow",
                arguments: _args,
            });
        }
        builder.pow = pow;
        function sqrt(tx, args) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::u8::sqrt",
                arguments: _args,
            });
        }
        builder.sqrt = sqrt;
    })(builder = u8.builder || (u8.builder = {}));
    let view;
    (function (view) {
        async function diff(client, args) {
            const tx = new TransactionBlock();
            builder.diff(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.diff = diff;
        async function divideAndRoundUp(client, args) {
            const tx = new TransactionBlock();
            builder.divideAndRoundUp(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.divideAndRoundUp = divideAndRoundUp;
        async function max(client, args) {
            const tx = new TransactionBlock();
            builder.max(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.max = max;
        async function min(client, args) {
            const tx = new TransactionBlock();
            builder.min(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.min = min;
        async function pow(client, args) {
            const tx = new TransactionBlock();
            builder.pow(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.pow = pow;
        async function sqrt(client, args) {
            const tx = new TransactionBlock();
            builder.sqrt(tx, args);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.sqrt = sqrt;
    })(view = u8.view || (u8.view = {}));
})(u8 || (u8 = {}));
export var vector;
(function (vector) {
    let builder;
    (function (builder) {
        function append(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrVec(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::append",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.append = append;
        function borrow(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::borrow",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.borrow = borrow;
        function borrowMut(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::borrow_mut",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.borrowMut = borrowMut;
        function contains(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrObject(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::contains",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.contains = contains;
        function destroyEmpty(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrVec(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::destroy_empty",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.destroyEmpty = destroyEmpty;
        function empty(tx, args, typeArguments) {
            const _args = [];
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::empty",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.empty = empty;
        function indexOf(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrObject(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::index_of",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.indexOf = indexOf;
        function insert(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            _args.push(transactionArgumentOrPure(args[2], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::insert",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.insert = insert;
        function isEmpty(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::is_empty",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.isEmpty = isEmpty;
        function length(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::length",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.length = length;
        function popBack(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::pop_back",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.popBack = popBack;
        function pushBack(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::push_back",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.pushBack = pushBack;
        function remove(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::remove",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.remove = remove;
        function reverse(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::reverse",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.reverse = reverse;
        function singleton(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrPure(args[0], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::singleton",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.singleton = singleton;
        function swap(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            _args.push(transactionArgumentOrPure(args[2], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::swap",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.swap = swap;
        function swapRemove(tx, args, typeArguments) {
            const _args = [];
            _args.push(transactionArgumentOrObject(args[0], tx));
            _args.push(transactionArgumentOrPure(args[1], tx));
            // @ts-ignore
            return tx.moveCall({
                target: "0x1::vector::swap_remove",
                arguments: _args,
                typeArguments: [
                    typeof typeArguments[0] === "string"
                        ? typeArguments[0]
                        : typeArguments[0].getSignature(),
                ],
            });
        }
        builder.swapRemove = swapRemove;
    })(builder = vector.builder || (vector.builder = {}));
    let view;
    (function (view) {
        async function append(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.append(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.append = append;
        async function borrow(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.borrow(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.borrow = borrow;
        async function borrowMut(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.borrowMut(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.borrowMut = borrowMut;
        async function contains(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.contains(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.contains = contains;
        async function destroyEmpty(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.destroyEmpty(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.destroyEmpty = destroyEmpty;
        async function empty(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.empty(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.empty = empty;
        async function indexOf(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.indexOf(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.indexOf = indexOf;
        async function insert(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.insert(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.insert = insert;
        async function isEmpty(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.isEmpty(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.isEmpty = isEmpty;
        async function length(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.length(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.length = length;
        async function popBack(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.popBack(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.popBack = popBack;
        async function pushBack(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.pushBack(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.pushBack = pushBack;
        async function remove(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.remove(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.remove = remove;
        async function reverse(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.reverse(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.reverse = reverse;
        async function singleton(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.singleton(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.singleton = singleton;
        async function swap(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.swap(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.swap = swap;
        async function swapRemove(client, args, typeArguments) {
            const tx = new TransactionBlock();
            builder.swapRemove(tx, args, typeArguments);
            const inspectRes = await client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ZERO_ADDRESS,
            });
            return (await getMoveCoder(client)).decodeDevInspectResult(inspectRes);
        }
        view.swapRemove = swapRemove;
    })(view = vector.view || (vector.view = {}));
})(vector || (vector = {}));
const MODULES = JSON.parse('{"address":{"fileFormatVersion":6,"address":"0x1","name":"address","friends":[],"structs":{},"exposedFunctions":{"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":["U64"]}}},"ascii":{"fileFormatVersion":6,"address":"0x1","name":"ascii","friends":[],"structs":{"Char":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"byte","type":"U8"}]},"String":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"all_characters_printable":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":["Bool"]},"append":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[]},"as_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"byte":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"ascii","name":"Char","typeArguments":[]}}],"return":["U8"]},"char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"Char","typeArguments":[]}}]},"index_of":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":["U64"]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},"U64",{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[]},"into_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[{"Vector":"U8"}]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":["Bool"]},"is_printable_char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":["Bool"]},"is_valid_char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":["U64"]},"pop_char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"Char","typeArguments":[]}}]},"push_char":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},{"Struct":{"address":"0x1","module":"ascii","name":"Char","typeArguments":[]}}],"return":[]},"string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"substring":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}},"U64","U64"],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"to_lowercase":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"to_uppercase":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"try_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]}}]}}},"bcs":{"fileFormatVersion":6,"address":"0x1","name":"bcs","friends":[],"structs":{},"exposedFunctions":{"to_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[{"Vector":"U8"}]}}},"bit_vector":{"fileFormatVersion":6,"address":"0x1","name":"bit_vector","friends":[],"structs":{"BitVector":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"length","type":"U64"},{"name":"bit_field","type":{"Vector":"Bool"}}]}},"exposedFunctions":{"is_index_set":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}}],"return":["U64"]},"longest_set_sequence_starting_at":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":["U64"]},"new":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}]},"set":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":[]},"shift_left":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":[]},"unset":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"bit_vector","name":"BitVector","typeArguments":[]}}},"U64"],"return":[]}}},"debug":{"fileFormatVersion":6,"address":"0x1","name":"debug","friends":[],"structs":{},"exposedFunctions":{"print":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"TypeParameter":0}}],"return":[]},"print_stack_trace":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[],"return":[]}}},"fixed_point32":{"fileFormatVersion":6,"address":"0x1","name":"fixed_point32","friends":[],"structs":{"FixedPoint32":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"value","type":"U64"}]}},"exposedFunctions":{"create_from_rational":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":[{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}]},"create_from_raw_value":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":[{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}]},"divide_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64",{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}],"return":["U64"]},"get_raw_value":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}],"return":["U64"]},"is_zero":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}],"return":["Bool"]},"multiply_u64":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64",{"Struct":{"address":"0x1","module":"fixed_point32","name":"FixedPoint32","typeArguments":[]}}],"return":["U64"]}}},"hash":{"fileFormatVersion":6,"address":"0x1","name":"hash","friends":[],"structs":{},"exposedFunctions":{"sha2_256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Vector":"U8"}]},"sha3_256":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Vector":"U8"}]}}},"macros":{"fileFormatVersion":6,"address":"0x1","name":"macros","friends":[],"structs":{},"exposedFunctions":{}},"option":{"fileFormatVersion":6,"address":"0x1","name":"option","friends":[],"structs":{"Option":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":false}],"fields":[{"name":"vec","type":{"Vector":{"TypeParameter":0}}}]}},"exposedFunctions":{"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"MutableReference":{"TypeParameter":0}}]},"borrow_with_default":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"TypeParameter":0}}],"return":[{"Reference":{"TypeParameter":0}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"TypeParameter":0}}],"return":["Bool"]},"destroy_none":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"destroy_some":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}],"return":[{"TypeParameter":0}]},"destroy_with_default":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Drop"]}],"parameters":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}},{"TypeParameter":0}],"return":[{"TypeParameter":0}]},"extract":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":[{"TypeParameter":0}]},"fill":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[]},"get_with_default":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Copy","Drop"]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[{"TypeParameter":0}]},"is_none":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"is_some":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"none":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}]},"some":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}]},"swap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[{"TypeParameter":0}]},"swap_or_fill":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}},{"TypeParameter":0}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}]},"to_vec":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"TypeParameter":0}]}}],"return":[{"Vector":{"TypeParameter":0}}]}}},"string":{"fileFormatVersion":6,"address":"0x1","name":"string","friends":[],"structs":{"String":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"bytes","type":{"Vector":"U8"}}]}},"exposedFunctions":{"append":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"append_utf8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Vector":"U8"}],"return":[]},"as_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":[{"Reference":{"Vector":"U8"}}]},"from_ascii":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"index_of":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["U64"]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},"U64",{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[]},"into_bytes":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[{"Vector":"U8"}]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}}],"return":["U64"]},"sub_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},"U64","U64"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"substring":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}},"U64","U64"],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]},"to_ascii":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"try_utf8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}]},"utf8":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Vector":"U8"}],"return":[{"Struct":{"address":"0x1","module":"string","name":"String","typeArguments":[]}}]}}},"type_name":{"fileFormatVersion":6,"address":"0x1","name":"type_name","friends":[],"structs":{"TypeName":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"name","type":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]}},"exposedFunctions":{"borrow_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}}]},"get":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]},"get_address":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"get_module":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"get_with_original_ids":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}]},"into_string":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}],"return":[{"Struct":{"address":"0x1","module":"ascii","name":"String","typeArguments":[]}}]},"is_primitive":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}}],"return":["Bool"]}}},"u128":{"fileFormatVersion":6,"address":"0x1","name":"u128","friends":[],"structs":{},"exposedFunctions":{"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U128"],"return":["U128"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U128"],"return":["U128"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U128"],"return":["U128"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U128"],"return":["U128"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128","U8"],"return":["U128"]},"sqrt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U128"],"return":["U128"]}}},"u16":{"fileFormatVersion":6,"address":"0x1","name":"u16","friends":[],"structs":{},"exposedFunctions":{"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16","U16"],"return":["U16"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16","U16"],"return":["U16"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16","U16"],"return":["U16"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16","U16"],"return":["U16"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16","U8"],"return":["U16"]},"sqrt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U16"],"return":["U16"]}}},"u256":{"fileFormatVersion":6,"address":"0x1","name":"u256","friends":[],"structs":{},"exposedFunctions":{"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256","U256"],"return":["U256"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256","U256"],"return":["U256"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256","U256"],"return":["U256"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256","U256"],"return":["U256"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U256","U8"],"return":["U256"]}}},"u32":{"fileFormatVersion":6,"address":"0x1","name":"u32","friends":[],"structs":{},"exposedFunctions":{"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32","U32"],"return":["U32"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32","U32"],"return":["U32"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32","U32"],"return":["U32"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32","U32"],"return":["U32"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32","U8"],"return":["U32"]},"sqrt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U32"],"return":["U32"]}}},"u64":{"fileFormatVersion":6,"address":"0x1","name":"u64","friends":[],"structs":{},"exposedFunctions":{"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U8"],"return":["U64"]},"sqrt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64"],"return":["U64"]}}},"u8":{"fileFormatVersion":6,"address":"0x1","name":"u8","friends":[],"structs":{},"exposedFunctions":{"diff":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8","U8"],"return":["U8"]},"divide_and_round_up":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8","U8"],"return":["U8"]},"max":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8","U8"],"return":["U8"]},"min":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8","U8"],"return":["U8"]},"pow":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8","U8"],"return":["U8"]},"sqrt":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U8"],"return":["U8"]}}},"vector":{"fileFormatVersion":6,"address":"0x1","name":"vector","friends":[],"structs":{},"exposedFunctions":{"append":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},{"Vector":{"TypeParameter":0}}],"return":[]},"borrow":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}},"U64"],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_mut":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},"U64"],"return":[{"MutableReference":{"TypeParameter":0}}]},"contains":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}},{"Reference":{"TypeParameter":0}}],"return":["Bool"]},"destroy_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Vector":{"TypeParameter":0}}],"return":[]},"empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[],"return":[{"Vector":{"TypeParameter":0}}]},"index_of":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}},{"Reference":{"TypeParameter":0}}],"return":["Bool","U64"]},"insert":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},{"TypeParameter":0},"U64"],"return":[]},"is_empty":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}}],"return":["Bool"]},"length":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Vector":{"TypeParameter":0}}}],"return":["U64"]},"pop_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}}],"return":[{"TypeParameter":0}]},"push_back":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},{"TypeParameter":0}],"return":[]},"remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},"U64"],"return":[{"TypeParameter":0}]},"reverse":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}}],"return":[]},"singleton":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"TypeParameter":0}],"return":[{"Vector":{"TypeParameter":0}}]},"swap":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},"U64","U64"],"return":[]},"swap_remove":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Vector":{"TypeParameter":0}}},"U64"],"return":[{"TypeParameter":0}]}}}}');
export function loadAllTypes(coder) {
    for (const m of Object.values(MODULES)) {
        coder.load(m, "0x1");
    }
}
loadAllTypes(defaultMoveCoder());
//# sourceMappingURL=0x1.js.map