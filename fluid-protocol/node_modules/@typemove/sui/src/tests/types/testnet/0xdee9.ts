/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

/* Generated types for 0xdee9, original address 0xdee9 */

import { TypeDescriptor, ANY_TYPE } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/sui";

import { defaultMoveCoder } from "@typemove/sui";

import {
  ZERO_ADDRESS,
  TypedDevInspectResults,
  getMoveCoder,
} from "@typemove/sui";
import {
  TransactionBlock,
  TransactionArgument,
  TransactionObjectArgument,
} from "@mysten/sui.js/transactions";
import { SuiClient } from "@mysten/sui.js/client";
import {
  transactionArgumentOrObject,
  transactionArgumentOrPure,
  transactionArgumentOrVec,
} from "@typemove/sui";

import { _0x2 } from "@typemove/sui/builtin";
import { _0x1 } from "@typemove/sui/builtin";

export namespace clob {
  export interface Order {
    order_id: bigint;
    price: bigint;
    quantity: bigint;
    is_bid: Boolean;
    owner: _0x2.object_.ID;
    expire_timestamp: bigint;
  }

  export namespace Order {
    export const TYPE_QNAME = "0xdee9::clob::Order";

    const TYPE = new TypeDescriptor<Order>(Order.TYPE_QNAME);

    export function type(): TypeDescriptor<Order> {
      return TYPE.apply();
    }
  }

  export interface OrderCanceled<T0, T1> {
    pool_id: _0x2.object_.ID;
    order_id: bigint;
    is_bid: Boolean;
    owner: _0x2.object_.ID;
    base_asset_quantity_canceled: bigint;
    price: bigint;
  }

  export namespace OrderCanceled {
    export const TYPE_QNAME = "0xdee9::clob::OrderCanceled";

    const TYPE = new TypeDescriptor<OrderCanceled<any, any>>(
      OrderCanceled.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<OrderCanceled<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface OrderCanceledInstance
    extends TypedEventInstance<OrderCanceled<any, any>> {
    data_decoded: OrderCanceled<any, any>;
    type_arguments: [string, string];
  }

  export interface OrderFilled<T0, T1> {
    pool_id: _0x2.object_.ID;
    order_id: bigint;
    is_bid: Boolean;
    owner: _0x2.object_.ID;
    total_quantity: bigint;
    base_asset_quantity_filled: bigint;
    base_asset_quantity_remaining: bigint;
    price: bigint;
  }

  export namespace OrderFilled {
    export const TYPE_QNAME = "0xdee9::clob::OrderFilled";

    const TYPE = new TypeDescriptor<OrderFilled<any, any>>(
      OrderFilled.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<OrderFilled<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface OrderFilledInstance
    extends TypedEventInstance<OrderFilled<any, any>> {
    data_decoded: OrderFilled<any, any>;
    type_arguments: [string, string];
  }

  export interface OrderFilledV2<T0, T1> {
    pool_id: _0x2.object_.ID;
    order_id: bigint;
    is_bid: Boolean;
    owner: _0x2.object_.ID;
    total_quantity: bigint;
    base_asset_quantity_filled: bigint;
    base_asset_quantity_remaining: bigint;
    price: bigint;
    taker_commission: bigint;
    maker_rebates: bigint;
  }

  export namespace OrderFilledV2 {
    export const TYPE_QNAME = "0xdee9::clob::OrderFilledV2";

    const TYPE = new TypeDescriptor<OrderFilledV2<any, any>>(
      OrderFilledV2.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<OrderFilledV2<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface OrderFilledV2Instance
    extends TypedEventInstance<OrderFilledV2<any, any>> {
    data_decoded: OrderFilledV2<any, any>;
    type_arguments: [string, string];
  }

  export interface OrderPlaced<T0, T1> {
    pool_id: _0x2.object_.ID;
    order_id: bigint;
    is_bid: Boolean;
    owner: _0x2.object_.ID;
    base_asset_quantity_placed: bigint;
    price: bigint;
  }

  export namespace OrderPlaced {
    export const TYPE_QNAME = "0xdee9::clob::OrderPlaced";

    const TYPE = new TypeDescriptor<OrderPlaced<any, any>>(
      OrderPlaced.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<OrderPlaced<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface OrderPlacedInstance
    extends TypedEventInstance<OrderPlaced<any, any>> {
    data_decoded: OrderPlaced<any, any>;
    type_arguments: [string, string];
  }

  export interface OrderPlacedV2<T0, T1> {
    pool_id: _0x2.object_.ID;
    order_id: bigint;
    is_bid: Boolean;
    owner: _0x2.object_.ID;
    base_asset_quantity_placed: bigint;
    price: bigint;
    expire_timestamp: bigint;
  }

  export namespace OrderPlacedV2 {
    export const TYPE_QNAME = "0xdee9::clob::OrderPlacedV2";

    const TYPE = new TypeDescriptor<OrderPlacedV2<any, any>>(
      OrderPlacedV2.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<OrderPlacedV2<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface OrderPlacedV2Instance
    extends TypedEventInstance<OrderPlacedV2<any, any>> {
    data_decoded: OrderPlacedV2<any, any>;
    type_arguments: [string, string];
  }

  export interface Pool<T0, T1> {
    id: _0x2.object_.UID;
    bids: critbit.CritbitTree<clob.TickLevel>;
    asks: critbit.CritbitTree<clob.TickLevel>;
    next_bid_order_id: bigint;
    next_ask_order_id: bigint;
    usr_open_orders: _0x2.table.Table<
      _0x2.object_.ID,
      _0x2.linked_table.LinkedTable<bigint, bigint>
    >;
    taker_fee_rate: bigint;
    maker_rebate_rate: bigint;
    tick_size: bigint;
    lot_size: bigint;
    base_custodian: custodian.Custodian<T0>;
    quote_custodian: custodian.Custodian<T1>;
    creation_fee: _0x2.balance.Balance<_0x2.sui.SUI>;
    base_asset_trading_fees: _0x2.balance.Balance<T0>;
    quote_asset_trading_fees: _0x2.balance.Balance<T1>;
  }

  export namespace Pool {
    export const TYPE_QNAME = "0xdee9::clob::Pool";

    const TYPE = new TypeDescriptor<Pool<any, any>>(Pool.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<Pool<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface PoolCreated {
    pool_id: _0x2.object_.ID;
    base_asset: _0x1.type_name.TypeName;
    quote_asset: _0x1.type_name.TypeName;
    taker_fee_rate: bigint;
    maker_rebate_rate: bigint;
    tick_size: bigint;
    lot_size: bigint;
  }

  export namespace PoolCreated {
    export const TYPE_QNAME = "0xdee9::clob::PoolCreated";

    const TYPE = new TypeDescriptor<PoolCreated>(PoolCreated.TYPE_QNAME);

    export function type(): TypeDescriptor<PoolCreated> {
      return TYPE.apply();
    }
  }

  export interface PoolCreatedInstance extends TypedEventInstance<PoolCreated> {
    data_decoded: PoolCreated;
    type_arguments: [];
  }

  export interface TickLevel {
    price: bigint;
    open_orders: _0x2.linked_table.LinkedTable<bigint, clob.Order>;
  }

  export namespace TickLevel {
    export const TYPE_QNAME = "0xdee9::clob::TickLevel";

    const TYPE = new TypeDescriptor<TickLevel>(TickLevel.TYPE_QNAME);

    export function type(): TypeDescriptor<TickLevel> {
      return TYPE.apply();
    }
  }

  export namespace builder {
    export function accountBalance<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::account_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function batchCancelOrder<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::batch_cancel_order",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function cancelAllOrders<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::cancel_all_orders",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function cancelOrder<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::cancel_order",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function createAccount(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::create_account",
        arguments: _args,
      });
    }
    export function createPool<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        _0x2.coin.Coin<_0x2.sui.SUI> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::create_pool",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function depositBase<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.coin.Coin<T0> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::deposit_base",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function depositQuote<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::deposit_quote",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getLevel2BookStatusAskSide<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::get_level2_book_status_ask_side",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getLevel2BookStatusBidSide<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::get_level2_book_status_bid_side",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getMarketPrice<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::get_market_price",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getOrderStatus<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::get_order_status",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function listOpenOrders<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::list_open_orders",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function placeLimitOrder<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        Boolean | TransactionArgument,
        bigint | TransactionArgument,
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));
      _args.push(transactionArgumentOrPure(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));
      _args.push(transactionArgumentOrObject(args[6], tx));
      _args.push(transactionArgumentOrObject(args[7], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::place_limit_order",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function placeMarketOrder<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        Boolean | TransactionArgument,
        _0x2.coin.Coin<T0> | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));
      _args.push(transactionArgumentOrPure(args[4], tx));
      _args.push(transactionArgumentOrObject(args[5], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::place_market_order",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function swapExactBaseForQuote<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        _0x2.coin.Coin<T0> | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));
      _args.push(transactionArgumentOrObject(args[4], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::swap_exact_base_for_quote",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function swapExactQuoteForBase<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::swap_exact_quote_for_base",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function withdrawBase<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::withdraw_base",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function withdrawQuote<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob::withdraw_quote",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function accountBalance<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint, bigint, bigint, bigint]>> {
      const tx = new TransactionBlock();
      builder.accountBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint, bigint, bigint]
      >(inspectRes);
    }
    export async function batchCancelOrder<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.batchCancelOrder(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function cancelAllOrders<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.cancelAllOrders(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function cancelOrder<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.cancelOrder(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function createAccount(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[custodian.AccountCap]>> {
      const tx = new TransactionBlock();
      builder.createAccount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [custodian.AccountCap]
      >(inspectRes);
    }
    export async function createPool<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        _0x2.coin.Coin<_0x2.sui.SUI> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.createPool(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function depositBase<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.coin.Coin<T0> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.depositBase(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function depositQuote<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.depositQuote(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function getLevel2BookStatusAskSide<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint[], bigint[]]>> {
      const tx = new TransactionBlock();
      builder.getLevel2BookStatusAskSide(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint[], bigint[]]
      >(inspectRes);
    }
    export async function getLevel2BookStatusBidSide<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint[], bigint[]]>> {
      const tx = new TransactionBlock();
      builder.getLevel2BookStatusBidSide(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint[], bigint[]]
      >(inspectRes);
    }
    export async function getMarketPrice<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint, bigint]>> {
      const tx = new TransactionBlock();
      builder.getMarketPrice(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint]
      >(inspectRes);
    }
    export async function getOrderStatus<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.getOrderStatus(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function listOpenOrders<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[clob.Order[]]>> {
      const tx = new TransactionBlock();
      builder.listOpenOrders(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [clob.Order[]]
      >(inspectRes);
    }
    export async function placeLimitOrder<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        Boolean | TransactionArgument,
        bigint | TransactionArgument,
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint, bigint, Boolean, bigint]>> {
      const tx = new TransactionBlock();
      builder.placeLimitOrder(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint, Boolean, bigint]
      >(inspectRes);
    }
    export async function placeMarketOrder<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        Boolean | TransactionArgument,
        _0x2.coin.Coin<T0> | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<
      TypedDevInspectResults<[_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>]>
    > {
      const tx = new TransactionBlock();
      builder.placeMarketOrder(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>]
      >(inspectRes);
    }
    export async function swapExactBaseForQuote<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        _0x2.coin.Coin<T0> | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<
      TypedDevInspectResults<[_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>, bigint]>
    > {
      const tx = new TransactionBlock();
      builder.swapExactBaseForQuote(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>, bigint]
      >(inspectRes);
    }
    export async function swapExactQuoteForBase<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<
      TypedDevInspectResults<[_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>, bigint]>
    > {
      const tx = new TransactionBlock();
      builder.swapExactQuoteForBase(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>, bigint]
      >(inspectRes);
    }
    export async function withdrawBase<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x2.coin.Coin<T0>]>> {
      const tx = new TransactionBlock();
      builder.withdrawBase(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>]
      >(inspectRes);
    }
    export async function withdrawQuote<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x2.coin.Coin<T1>]>> {
      const tx = new TransactionBlock();
      builder.withdrawQuote(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T1>]
      >(inspectRes);
    }
  }
}

export namespace clob_v2 {
  export interface DepositAsset<T0> {
    pool_id: _0x2.object_.ID;
    quantity: bigint;
    owner: string;
  }

  export namespace DepositAsset {
    export const TYPE_QNAME = "0xdee9::clob_v2::DepositAsset";

    const TYPE = new TypeDescriptor<DepositAsset<any>>(DepositAsset.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<DepositAsset<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface DepositAssetInstance
    extends TypedEventInstance<DepositAsset<any>> {
    data_decoded: DepositAsset<any>;
    type_arguments: [string];
  }

  export interface Order {
    order_id: bigint;
    client_order_id: bigint;
    price: bigint;
    original_quantity: bigint;
    quantity: bigint;
    is_bid: Boolean;
    owner: string;
    expire_timestamp: bigint;
    self_matching_prevention: number;
  }

  export namespace Order {
    export const TYPE_QNAME = "0xdee9::clob_v2::Order";

    const TYPE = new TypeDescriptor<Order>(Order.TYPE_QNAME);

    export function type(): TypeDescriptor<Order> {
      return TYPE.apply();
    }
  }

  export interface OrderCanceled<T0, T1> {
    pool_id: _0x2.object_.ID;
    order_id: bigint;
    client_order_id: bigint;
    is_bid: Boolean;
    owner: string;
    original_quantity: bigint;
    base_asset_quantity_canceled: bigint;
    price: bigint;
  }

  export namespace OrderCanceled {
    export const TYPE_QNAME = "0xdee9::clob_v2::OrderCanceled";

    const TYPE = new TypeDescriptor<OrderCanceled<any, any>>(
      OrderCanceled.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<OrderCanceled<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface OrderCanceledInstance
    extends TypedEventInstance<OrderCanceled<any, any>> {
    data_decoded: OrderCanceled<any, any>;
    type_arguments: [string, string];
  }

  export interface OrderFilled<T0, T1> {
    pool_id: _0x2.object_.ID;
    order_id: bigint;
    taker_client_order_id: bigint;
    maker_client_order_id: bigint;
    is_bid: Boolean;
    taker_address: string;
    maker_address: string;
    original_quantity: bigint;
    base_asset_quantity_filled: bigint;
    base_asset_quantity_remaining: bigint;
    price: bigint;
    taker_commission: bigint;
    maker_rebates: bigint;
  }

  export namespace OrderFilled {
    export const TYPE_QNAME = "0xdee9::clob_v2::OrderFilled";

    const TYPE = new TypeDescriptor<OrderFilled<any, any>>(
      OrderFilled.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<OrderFilled<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface OrderFilledInstance
    extends TypedEventInstance<OrderFilled<any, any>> {
    data_decoded: OrderFilled<any, any>;
    type_arguments: [string, string];
  }

  export interface OrderPlaced<T0, T1> {
    pool_id: _0x2.object_.ID;
    order_id: bigint;
    client_order_id: bigint;
    is_bid: Boolean;
    owner: string;
    original_quantity: bigint;
    base_asset_quantity_placed: bigint;
    price: bigint;
    expire_timestamp: bigint;
  }

  export namespace OrderPlaced {
    export const TYPE_QNAME = "0xdee9::clob_v2::OrderPlaced";

    const TYPE = new TypeDescriptor<OrderPlaced<any, any>>(
      OrderPlaced.TYPE_QNAME,
    );

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<OrderPlaced<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface OrderPlacedInstance
    extends TypedEventInstance<OrderPlaced<any, any>> {
    data_decoded: OrderPlaced<any, any>;
    type_arguments: [string, string];
  }

  export interface Pool<T0, T1> {
    id: _0x2.object_.UID;
    bids: critbit.CritbitTree<clob_v2.TickLevel>;
    asks: critbit.CritbitTree<clob_v2.TickLevel>;
    next_bid_order_id: bigint;
    next_ask_order_id: bigint;
    usr_open_orders: _0x2.table.Table<
      string,
      _0x2.linked_table.LinkedTable<bigint, bigint>
    >;
    taker_fee_rate: bigint;
    maker_rebate_rate: bigint;
    tick_size: bigint;
    lot_size: bigint;
    base_custodian: custodian_v2.Custodian<T0>;
    quote_custodian: custodian_v2.Custodian<T1>;
    creation_fee: _0x2.balance.Balance<_0x2.sui.SUI>;
    base_asset_trading_fees: _0x2.balance.Balance<T0>;
    quote_asset_trading_fees: _0x2.balance.Balance<T1>;
  }

  export namespace Pool {
    export const TYPE_QNAME = "0xdee9::clob_v2::Pool";

    const TYPE = new TypeDescriptor<Pool<any, any>>(Pool.TYPE_QNAME);

    export function type<T0, T1>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
      arg1: TypeDescriptor<T1> = ANY_TYPE,
    ): TypeDescriptor<Pool<T0, T1>> {
      return TYPE.apply(arg0, arg1);
    }
  }

  export interface PoolCreated {
    pool_id: _0x2.object_.ID;
    base_asset: _0x1.type_name.TypeName;
    quote_asset: _0x1.type_name.TypeName;
    taker_fee_rate: bigint;
    maker_rebate_rate: bigint;
    tick_size: bigint;
    lot_size: bigint;
  }

  export namespace PoolCreated {
    export const TYPE_QNAME = "0xdee9::clob_v2::PoolCreated";

    const TYPE = new TypeDescriptor<PoolCreated>(PoolCreated.TYPE_QNAME);

    export function type(): TypeDescriptor<PoolCreated> {
      return TYPE.apply();
    }
  }

  export interface PoolCreatedInstance extends TypedEventInstance<PoolCreated> {
    data_decoded: PoolCreated;
    type_arguments: [];
  }

  export interface TickLevel {
    price: bigint;
    open_orders: _0x2.linked_table.LinkedTable<bigint, clob_v2.Order>;
  }

  export namespace TickLevel {
    export const TYPE_QNAME = "0xdee9::clob_v2::TickLevel";

    const TYPE = new TypeDescriptor<TickLevel>(TickLevel.TYPE_QNAME);

    export function type(): TypeDescriptor<TickLevel> {
      return TYPE.apply();
    }
  }

  export interface WithdrawAsset<T0> {
    pool_id: _0x2.object_.ID;
    quantity: bigint;
    owner: string;
  }

  export namespace WithdrawAsset {
    export const TYPE_QNAME = "0xdee9::clob_v2::WithdrawAsset";

    const TYPE = new TypeDescriptor<WithdrawAsset<any>>(
      WithdrawAsset.TYPE_QNAME,
    );

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<WithdrawAsset<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface WithdrawAssetInstance
    extends TypedEventInstance<WithdrawAsset<any>> {
    data_decoded: WithdrawAsset<any>;
    type_arguments: [string];
  }

  export namespace builder {
    export function accountBalance<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::account_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function batchCancelOrder<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrVec(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::batch_cancel_order",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function cancelAllOrders<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::cancel_all_orders",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function cancelOrder<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::cancel_order",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function cleanUpExpiredOrders<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrVec(args[2], tx));
      _args.push(transactionArgumentOrVec(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::clean_up_expired_orders",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function createAccount(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::create_account",
        arguments: _args,
      });
    }
    export function createPool<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        _0x2.coin.Coin<_0x2.sui.SUI> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::create_pool",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function depositBase<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.coin.Coin<T0> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::deposit_base",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function depositQuote<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::deposit_quote",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getLevel2BookStatusAskSide<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::get_level2_book_status_ask_side",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getLevel2BookStatusBidSide<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrObject(args[3], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::get_level2_book_status_bid_side",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getMarketPrice<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::get_market_price",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function getOrderStatus<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::get_order_status",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function listOpenOrders<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::list_open_orders",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function placeLimitOrder<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        number | TransactionArgument,
        Boolean | TransactionArgument,
        bigint | TransactionArgument,
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));
      _args.push(transactionArgumentOrPure(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));
      _args.push(transactionArgumentOrPure(args[6], tx));
      _args.push(transactionArgumentOrPure(args[7], tx));
      _args.push(transactionArgumentOrObject(args[8], tx));
      _args.push(transactionArgumentOrObject(args[9], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::place_limit_order",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function placeMarketOrder<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        Boolean | TransactionArgument,
        _0x2.coin.Coin<T0> | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));
      _args.push(transactionArgumentOrPure(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));
      _args.push(transactionArgumentOrPure(args[6], tx));
      _args.push(transactionArgumentOrObject(args[7], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::place_market_order",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function swapExactBaseForQuote<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        _0x2.coin.Coin<T0> | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));
      _args.push(transactionArgumentOrPure(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));
      _args.push(transactionArgumentOrObject(args[6], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::swap_exact_base_for_quote",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function swapExactQuoteForBase<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
        TransactionArgument,
      ] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));
      _args.push(transactionArgumentOrPure(args[3], tx));
      _args.push(transactionArgumentOrObject(args[4], tx));
      _args.push(transactionArgumentOrPure(args[5], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::swap_exact_quote_for_base",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function withdrawBase<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::withdraw_base",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
    export function withdrawQuote<T0 = any, T1 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::clob_v2::withdraw_quote",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
          typeof typeArguments[1] === "string"
            ? typeArguments[1]
            : typeArguments[1].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function accountBalance<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint, bigint, bigint, bigint]>> {
      const tx = new TransactionBlock();
      builder.accountBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint, bigint, bigint]
      >(inspectRes);
    }
    export async function batchCancelOrder<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.batchCancelOrder(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function cancelAllOrders<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.cancelAllOrders(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function cancelOrder<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.cancelOrder(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function cleanUpExpiredOrders<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
        (string | TransactionObjectArgument)[] | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.cleanUpExpiredOrders(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function createAccount(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[custodian_v2.AccountCap]>> {
      const tx = new TransactionBlock();
      builder.createAccount(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [custodian_v2.AccountCap]
      >(inspectRes);
    }
    export async function createPool<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        _0x2.coin.Coin<_0x2.sui.SUI> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.createPool(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function depositBase<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.coin.Coin<T0> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.depositBase(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function depositQuote<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.depositQuote(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function getLevel2BookStatusAskSide<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint[], bigint[]]>> {
      const tx = new TransactionBlock();
      builder.getLevel2BookStatusAskSide(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint[], bigint[]]
      >(inspectRes);
    }
    export async function getLevel2BookStatusBidSide<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint[], bigint[]]>> {
      const tx = new TransactionBlock();
      builder.getLevel2BookStatusBidSide(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint[], bigint[]]
      >(inspectRes);
    }
    export async function getMarketPrice<T0 = any, T1 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<
      TypedDevInspectResults<
        [_0x1.option.Option<bigint>, _0x1.option.Option<bigint>]
      >
    > {
      const tx = new TransactionBlock();
      builder.getMarketPrice(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x1.option.Option<bigint>, _0x1.option.Option<bigint>]
      >(inspectRes);
    }
    export async function getOrderStatus<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.getOrderStatus(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function listOpenOrders<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[clob_v2.Order[]]>> {
      const tx = new TransactionBlock();
      builder.listOpenOrders(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [clob_v2.Order[]]
      >(inspectRes);
    }
    export async function placeLimitOrder<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        number | TransactionArgument,
        Boolean | TransactionArgument,
        bigint | TransactionArgument,
        number | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[bigint, bigint, Boolean, bigint]>> {
      const tx = new TransactionBlock();
      builder.placeLimitOrder(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint, Boolean, bigint]
      >(inspectRes);
    }
    export async function placeMarketOrder<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        bigint | TransactionArgument,
        Boolean | TransactionArgument,
        _0x2.coin.Coin<T0> | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<
      TypedDevInspectResults<[_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>]>
    > {
      const tx = new TransactionBlock();
      builder.placeMarketOrder(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>]
      >(inspectRes);
    }
    export async function swapExactBaseForQuote<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        _0x2.coin.Coin<T0> | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<
      TypedDevInspectResults<[_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>, bigint]>
    > {
      const tx = new TransactionBlock();
      builder.swapExactBaseForQuote(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>, bigint]
      >(inspectRes);
    }
    export async function swapExactQuoteForBase<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.coin.Coin<T1> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<
      TypedDevInspectResults<[_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>, bigint]>
    > {
      const tx = new TransactionBlock();
      builder.swapExactQuoteForBase(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>, _0x2.coin.Coin<T1>, bigint]
      >(inspectRes);
    }
    export async function withdrawBase<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x2.coin.Coin<T0>]>> {
      const tx = new TransactionBlock();
      builder.withdrawBase(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>]
      >(inspectRes);
    }
    export async function withdrawQuote<T0 = any, T1 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string, TypeDescriptor<T1> | string],
    ): Promise<TypedDevInspectResults<[_0x2.coin.Coin<T1>]>> {
      const tx = new TransactionBlock();
      builder.withdrawQuote(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T1>]
      >(inspectRes);
    }
  }
}

export namespace critbit {
  export interface CritbitTree<T0> {
    root: bigint;
    internal_nodes: _0x2.table.Table<bigint, critbit.InternalNode>;
    leaves: _0x2.table.Table<bigint, critbit.Leaf<T0>>;
    min_leaf: bigint;
    max_leaf: bigint;
    next_internal_node_index: bigint;
    next_leaf_index: bigint;
  }

  export namespace CritbitTree {
    export const TYPE_QNAME = "0xdee9::critbit::CritbitTree";

    const TYPE = new TypeDescriptor<CritbitTree<any>>(CritbitTree.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<CritbitTree<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface InternalNode {
    mask: bigint;
    left_child: bigint;
    right_child: bigint;
    parent: bigint;
  }

  export namespace InternalNode {
    export const TYPE_QNAME = "0xdee9::critbit::InternalNode";

    const TYPE = new TypeDescriptor<InternalNode>(InternalNode.TYPE_QNAME);

    export function type(): TypeDescriptor<InternalNode> {
      return TYPE.apply();
    }
  }

  export interface Leaf<T0> {
    key: bigint;
    value: T0;
    parent: bigint;
  }

  export namespace Leaf {
    export const TYPE_QNAME = "0xdee9::critbit::Leaf";

    const TYPE = new TypeDescriptor<Leaf<any>>(Leaf.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Leaf<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function borrowLeafByIndex<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::borrow_leaf_by_index",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowLeafByKey<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::borrow_leaf_by_key",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function borrowMutLeafByIndex<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::borrow_mut_leaf_by_index",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function destroyEmpty<T0 = any>(
      tx: TransactionBlock,
      args: [critbit.CritbitTree<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::destroy_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function drop<T0 = any>(
      tx: TransactionBlock,
      args: [critbit.CritbitTree<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::drop",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function findClosestKey<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::find_closest_key",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function findLeaf<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::find_leaf",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function insertLeaf<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::insert_leaf",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function isEmpty<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::is_empty",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function maxLeaf<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::max_leaf",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function minLeaf<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::min_leaf",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function new_<T0 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function nextLeaf<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::next_leaf",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function previousLeaf<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::previous_leaf",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function removeLeafByIndex<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::remove_leaf_by_index",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function size<T0 = any>(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::critbit::size",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function borrowLeafByIndex<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowLeafByIndex(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowLeafByKey<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowLeafByKey(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function borrowMutLeafByIndex<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.borrowMutLeafByIndex(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function destroyEmpty<T0 = any>(
      client: SuiClient,
      args: [critbit.CritbitTree<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.destroyEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function drop<T0 = any>(
      client: SuiClient,
      args: [critbit.CritbitTree<T0> | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.drop(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function findClosestKey<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.findClosestKey(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function findLeaf<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean, bigint]>> {
      const tx = new TransactionBlock();
      builder.findLeaf(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [Boolean, bigint]
      >(inspectRes);
    }
    export async function insertLeaf<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        T0 | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.insertLeaf(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function isEmpty<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[Boolean]>> {
      const tx = new TransactionBlock();
      builder.isEmpty(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[Boolean]>(
        inspectRes,
      );
    }
    export async function maxLeaf<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint, bigint]>> {
      const tx = new TransactionBlock();
      builder.maxLeaf(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint]
      >(inspectRes);
    }
    export async function minLeaf<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint, bigint]>> {
      const tx = new TransactionBlock();
      builder.minLeaf(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint]
      >(inspectRes);
    }
    export async function new_<T0 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[critbit.CritbitTree<T0>]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [critbit.CritbitTree<T0>]
      >(inspectRes);
    }
    export async function nextLeaf<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint, bigint]>> {
      const tx = new TransactionBlock();
      builder.nextLeaf(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint]
      >(inspectRes);
    }
    export async function previousLeaf<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint, bigint]>> {
      const tx = new TransactionBlock();
      builder.previousLeaf(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint]
      >(inspectRes);
    }
    export async function removeLeafByIndex<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[T0]>> {
      const tx = new TransactionBlock();
      builder.removeLeafByIndex(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[T0]>(
        inspectRes,
      );
    }
    export async function size<T0 = any>(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.size(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
  }
}

export namespace custodian {
  export interface Account<T0> {
    available_balance: _0x2.balance.Balance<T0>;
    locked_balance: _0x2.balance.Balance<T0>;
  }

  export namespace Account {
    export const TYPE_QNAME = "0xdee9::custodian::Account";

    const TYPE = new TypeDescriptor<Account<any>>(Account.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Account<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface AccountCap {
    id: _0x2.object_.UID;
  }

  export namespace AccountCap {
    export const TYPE_QNAME = "0xdee9::custodian::AccountCap";

    const TYPE = new TypeDescriptor<AccountCap>(AccountCap.TYPE_QNAME);

    export function type(): TypeDescriptor<AccountCap> {
      return TYPE.apply();
    }
  }

  export interface Custodian<T0> {
    id: _0x2.object_.UID;
    account_balances: _0x2.table.Table<_0x2.object_.ID, custodian.Account<T0>>;
  }

  export namespace Custodian {
    export const TYPE_QNAME = "0xdee9::custodian::Custodian";

    const TYPE = new TypeDescriptor<Custodian<any>>(Custodian.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Custodian<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function accountAvailableBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian::account_available_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function accountBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian::account_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function accountLockedBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian::account_locked_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function decreaseUserAvailableBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian::decrease_user_available_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function decreaseUserLockedBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.object_.ID | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian::decrease_user_locked_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function increaseUserAvailableBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.object_.ID | TransactionArgument,
        _0x2.balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian::increase_user_available_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function increaseUserLockedBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian::increase_user_locked_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function lockBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian::lock_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mintAccountCap(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian::mint_account_cap",
        arguments: _args,
      });
    }
    export function new_<T0 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function unlockBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.object_.ID | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian::unlock_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function withdrawAsset<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian::withdraw_asset",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function accountAvailableBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.accountAvailableBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function accountBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint, bigint]>> {
      const tx = new TransactionBlock();
      builder.accountBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint]
      >(inspectRes);
    }
    export async function accountLockedBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.object_.ID | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.accountLockedBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function decreaseUserAvailableBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x2.balance.Balance<T0>]>> {
      const tx = new TransactionBlock();
      builder.decreaseUserAvailableBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.balance.Balance<T0>]
      >(inspectRes);
    }
    export async function decreaseUserLockedBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.object_.ID | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x2.balance.Balance<T0>]>> {
      const tx = new TransactionBlock();
      builder.decreaseUserLockedBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.balance.Balance<T0>]
      >(inspectRes);
    }
    export async function increaseUserAvailableBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.object_.ID | TransactionArgument,
        _0x2.balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.increaseUserAvailableBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function increaseUserLockedBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.increaseUserLockedBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function lockBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.lockBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function mintAccountCap(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[custodian.AccountCap]>> {
      const tx = new TransactionBlock();
      builder.mintAccountCap(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [custodian.AccountCap]
      >(inspectRes);
    }
    export async function new_<T0 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[custodian.Custodian<T0>]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [custodian.Custodian<T0>]
      >(inspectRes);
    }
    export async function unlockBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.object_.ID | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.unlockBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function withdrawAsset<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x2.coin.Coin<T0>]>> {
      const tx = new TransactionBlock();
      builder.withdrawAsset(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>]
      >(inspectRes);
    }
  }
}

export namespace custodian_v2 {
  export interface Account<T0> {
    available_balance: _0x2.balance.Balance<T0>;
    locked_balance: _0x2.balance.Balance<T0>;
  }

  export namespace Account {
    export const TYPE_QNAME = "0xdee9::custodian_v2::Account";

    const TYPE = new TypeDescriptor<Account<any>>(Account.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Account<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export interface AccountCap {
    id: _0x2.object_.UID;
    owner: string;
  }

  export namespace AccountCap {
    export const TYPE_QNAME = "0xdee9::custodian_v2::AccountCap";

    const TYPE = new TypeDescriptor<AccountCap>(AccountCap.TYPE_QNAME);

    export function type(): TypeDescriptor<AccountCap> {
      return TYPE.apply();
    }
  }

  export interface Custodian<T0> {
    id: _0x2.object_.UID;
    account_balances: _0x2.table.Table<string, custodian_v2.Account<T0>>;
  }

  export namespace Custodian {
    export const TYPE_QNAME = "0xdee9::custodian_v2::Custodian";

    const TYPE = new TypeDescriptor<Custodian<any>>(Custodian.TYPE_QNAME);

    export function type<T0>(
      arg0: TypeDescriptor<T0> = ANY_TYPE,
    ): TypeDescriptor<Custodian<T0>> {
      return TYPE.apply(arg0);
    }
  }

  export namespace builder {
    export function accountAvailableBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::account_available_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function accountBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::account_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function accountLockedBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::account_locked_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function accountOwner(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::account_owner",
        arguments: _args,
      });
    }
    export function createChildAccountCap(
      tx: TransactionBlock,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::create_child_account_cap",
        arguments: _args,
      });
    }
    export function decreaseUserAvailableBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::decrease_user_available_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function decreaseUserLockedBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::decrease_user_locked_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function deleteAccountCap(
      tx: TransactionBlock,
      args: [custodian_v2.AccountCap | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::delete_account_cap",
        arguments: _args,
      });
    }
    export function increaseUserAvailableBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
        _0x2.balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::increase_user_available_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function increaseUserLockedBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::increase_user_locked_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function lockBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrObject(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::lock_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function mintAccountCap(
      tx: TransactionBlock,
      args: [],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::mint_account_cap",
        arguments: _args,
      });
    }
    export function new_<T0 = any>(
      tx: TransactionBlock,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument & [] {
      const _args: any[] = [];

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::new",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function unlockBalance<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrPure(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::unlock_balance",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
    export function withdrawAsset<T0 = any>(
      tx: TransactionBlock,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): TransactionArgument &
      [TransactionArgument, TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrObject(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));
      _args.push(transactionArgumentOrObject(args[2], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::custodian_v2::withdraw_asset",
        arguments: _args,
        typeArguments: [
          typeof typeArguments[0] === "string"
            ? typeArguments[0]
            : typeArguments[0].getSignature(),
        ],
      });
    }
  }
  export namespace view {
    export async function accountAvailableBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.accountAvailableBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function accountBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint, bigint]>> {
      const tx = new TransactionBlock();
      builder.accountBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [bigint, bigint]
      >(inspectRes);
    }
    export async function accountLockedBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.accountLockedBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function accountOwner(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[string]>> {
      const tx = new TransactionBlock();
      builder.accountOwner(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[string]>(
        inspectRes,
      );
    }
    export async function createChildAccountCap(
      client: SuiClient,
      args: [string | TransactionObjectArgument | TransactionArgument],
    ): Promise<TypedDevInspectResults<[custodian_v2.AccountCap]>> {
      const tx = new TransactionBlock();
      builder.createChildAccountCap(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [custodian_v2.AccountCap]
      >(inspectRes);
    }
    export async function decreaseUserAvailableBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x2.balance.Balance<T0>]>> {
      const tx = new TransactionBlock();
      builder.decreaseUserAvailableBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.balance.Balance<T0>]
      >(inspectRes);
    }
    export async function decreaseUserLockedBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x2.balance.Balance<T0>]>> {
      const tx = new TransactionBlock();
      builder.decreaseUserLockedBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.balance.Balance<T0>]
      >(inspectRes);
    }
    export async function deleteAccountCap(
      client: SuiClient,
      args: [custodian_v2.AccountCap | TransactionArgument],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.deleteAccountCap(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function increaseUserAvailableBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
        _0x2.balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.increaseUserAvailableBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function increaseUserLockedBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        _0x2.balance.Balance<T0> | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.increaseUserLockedBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function lockBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.lockBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function mintAccountCap(
      client: SuiClient,
      args: [],
    ): Promise<TypedDevInspectResults<[custodian_v2.AccountCap]>> {
      const tx = new TransactionBlock();
      builder.mintAccountCap(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [custodian_v2.AccountCap]
      >(inspectRes);
    }
    export async function new_<T0 = any>(
      client: SuiClient,
      args: [],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[custodian_v2.Custodian<T0>]>> {
      const tx = new TransactionBlock();
      builder.new_(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [custodian_v2.Custodian<T0>]
      >(inspectRes);
    }
    export async function unlockBalance<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        string | TransactionArgument,
        bigint | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[]>> {
      const tx = new TransactionBlock();
      builder.unlockBalance(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[]>(
        inspectRes,
      );
    }
    export async function withdrawAsset<T0 = any>(
      client: SuiClient,
      args: [
        string | TransactionObjectArgument | TransactionArgument,
        bigint | TransactionArgument,
        string | TransactionObjectArgument | TransactionArgument,
      ],
      typeArguments: [TypeDescriptor<T0> | string],
    ): Promise<TypedDevInspectResults<[_0x2.coin.Coin<T0>]>> {
      const tx = new TransactionBlock();
      builder.withdrawAsset(tx, args, typeArguments);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [_0x2.coin.Coin<T0>]
      >(inspectRes);
    }
  }
}

export namespace math {
  export namespace builder {
    export function countLeadingZeros(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::math::count_leading_zeros",
        arguments: _args,
      });
    }
    export function divRound(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::math::div_round",
        arguments: _args,
      });
    }
    export function mul(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::math::mul",
        arguments: _args,
      });
    }
    export function mulRound(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::math::mul_round",
        arguments: _args,
      });
    }
    export function unsafeDiv(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::math::unsafe_div",
        arguments: _args,
      });
    }
    export function unsafeDivRound(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::math::unsafe_div_round",
        arguments: _args,
      });
    }
    export function unsafeMul(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::math::unsafe_mul",
        arguments: _args,
      });
    }
    export function unsafeMulRound(
      tx: TransactionBlock,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): TransactionArgument & [TransactionArgument, TransactionArgument] {
      const _args: any[] = [];
      _args.push(transactionArgumentOrPure(args[0], tx));
      _args.push(transactionArgumentOrPure(args[1], tx));

      // @ts-ignore
      return tx.moveCall({
        target: "0xdee9::math::unsafe_mul_round",
        arguments: _args,
      });
    }
  }
  export namespace view {
    export async function countLeadingZeros(
      client: SuiClient,
      args: [bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[number]>> {
      const tx = new TransactionBlock();
      builder.countLeadingZeros(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[number]>(
        inspectRes,
      );
    }
    export async function divRound(
      client: SuiClient,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean, bigint]>> {
      const tx = new TransactionBlock();
      builder.divRound(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [Boolean, bigint]
      >(inspectRes);
    }
    export async function mul(
      client: SuiClient,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.mul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function mulRound(
      client: SuiClient,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean, bigint]>> {
      const tx = new TransactionBlock();
      builder.mulRound(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [Boolean, bigint]
      >(inspectRes);
    }
    export async function unsafeDiv(
      client: SuiClient,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.unsafeDiv(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function unsafeDivRound(
      client: SuiClient,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean, bigint]>> {
      const tx = new TransactionBlock();
      builder.unsafeDivRound(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [Boolean, bigint]
      >(inspectRes);
    }
    export async function unsafeMul(
      client: SuiClient,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[bigint]>> {
      const tx = new TransactionBlock();
      builder.unsafeMul(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<[bigint]>(
        inspectRes,
      );
    }
    export async function unsafeMulRound(
      client: SuiClient,
      args: [bigint | TransactionArgument, bigint | TransactionArgument],
    ): Promise<TypedDevInspectResults<[Boolean, bigint]>> {
      const tx = new TransactionBlock();
      builder.unsafeMulRound(tx, args);
      const inspectRes = await client.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: ZERO_ADDRESS,
      });

      return (await getMoveCoder(client)).decodeDevInspectResult<
        [Boolean, bigint]
      >(inspectRes);
    }
  }
}

const MODULES = JSON.parse(
  '{"clob":{"fileFormatVersion":6,"address":"0xdee9","name":"clob","friends":[],"structs":{"Order":{"abilities":{"abilities":["Drop","Store"]},"typeParameters":[],"fields":[{"name":"order_id","type":"U64"},{"name":"price","type":"U64"},{"name":"quantity","type":"U64"},{"name":"is_bid","type":"Bool"},{"name":"owner","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"expire_timestamp","type":"U64"}]},"OrderCanceled":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"order_id","type":"U64"},{"name":"is_bid","type":"Bool"},{"name":"owner","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"base_asset_quantity_canceled","type":"U64"},{"name":"price","type":"U64"}]},"OrderFilled":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"order_id","type":"U64"},{"name":"is_bid","type":"Bool"},{"name":"owner","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"total_quantity","type":"U64"},{"name":"base_asset_quantity_filled","type":"U64"},{"name":"base_asset_quantity_remaining","type":"U64"},{"name":"price","type":"U64"}]},"OrderFilledV2":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"order_id","type":"U64"},{"name":"is_bid","type":"Bool"},{"name":"owner","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"total_quantity","type":"U64"},{"name":"base_asset_quantity_filled","type":"U64"},{"name":"base_asset_quantity_remaining","type":"U64"},{"name":"price","type":"U64"},{"name":"taker_commission","type":"U64"},{"name":"maker_rebates","type":"U64"}]},"OrderPlaced":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"order_id","type":"U64"},{"name":"is_bid","type":"Bool"},{"name":"owner","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"base_asset_quantity_placed","type":"U64"},{"name":"price","type":"U64"}]},"OrderPlacedV2":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"order_id","type":"U64"},{"name":"is_bid","type":"Bool"},{"name":"owner","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"base_asset_quantity_placed","type":"U64"},{"name":"price","type":"U64"},{"name":"expire_timestamp","type":"U64"}]},"Pool":{"abilities":{"abilities":["Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"bids","type":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"Struct":{"address":"0xdee9","module":"clob","name":"TickLevel","typeArguments":[]}}]}}},{"name":"asks","type":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"Struct":{"address":"0xdee9","module":"clob","name":"TickLevel","typeArguments":[]}}]}}},{"name":"next_bid_order_id","type":"U64"},{"name":"next_ask_order_id","type":"U64"},{"name":"usr_open_orders","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":["U64","U64"]}}]}}},{"name":"taker_fee_rate","type":"U64"},{"name":"maker_rebate_rate","type":"U64"},{"name":"tick_size","type":"U64"},{"name":"lot_size","type":"U64"},{"name":"base_custodian","type":{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"name":"quote_custodian","type":{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":1}]}}},{"name":"creation_fee","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}}},{"name":"base_asset_trading_fees","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},{"name":"quote_asset_trading_fees","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":1}]}}}]},"PoolCreated":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"base_asset","type":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}},{"name":"quote_asset","type":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}},{"name":"taker_fee_rate","type":"U64"},{"name":"maker_rebate_rate","type":"U64"},{"name":"tick_size","type":"U64"},{"name":"lot_size","type":"U64"}]},"TickLevel":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"price","type":"U64"},{"name":"open_orders","type":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":["U64",{"Struct":{"address":"0xdee9","module":"clob","name":"Order","typeArguments":[]}}]}}}]}},"exposedFunctions":{"account_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}}],"return":["U64","U64","U64","U64"]},"batch_cancel_order":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Vector":"U64"},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}}],"return":[]},"cancel_all_orders":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}}],"return":[]},"cancel_order":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64",{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}}],"return":[]},"create_account":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}]},"create_pool":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":["U64","U64",{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"deposit_base":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}}],"return":[]},"deposit_quote":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}}],"return":[]},"get_level2_book_status_ask_side":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64","U64",{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}}],"return":[{"Vector":"U64"},{"Vector":"U64"}]},"get_level2_book_status_bid_side":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64","U64",{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}}],"return":[{"Vector":"U64"},{"Vector":"U64"}]},"get_market_price":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":["U64","U64"]},"get_order_status":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64",{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob","name":"Order","typeArguments":[]}}}]},"list_open_orders":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}}],"return":[{"Vector":{"Struct":{"address":"0xdee9","module":"clob","name":"Order","typeArguments":[]}}}]},"place_limit_order":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64","U64","Bool","U64","U8",{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["U64","U64","Bool","U64"]},"place_market_order":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64","Bool",{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}},{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}]},"swap_exact_base_for_quote":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64",{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}},{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}},"U64"]},"swap_exact_quote_for_base":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64",{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}},"U64"]},"withdraw_base":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64",{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"withdraw_quote":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64",{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}]}}},"clob_v2":{"fileFormatVersion":6,"address":"0xdee9","name":"clob_v2","friends":[],"structs":{"DepositAsset":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"quantity","type":"U64"},{"name":"owner","type":"Address"}]},"Order":{"abilities":{"abilities":["Drop","Store"]},"typeParameters":[],"fields":[{"name":"order_id","type":"U64"},{"name":"client_order_id","type":"U64"},{"name":"price","type":"U64"},{"name":"original_quantity","type":"U64"},{"name":"quantity","type":"U64"},{"name":"is_bid","type":"Bool"},{"name":"owner","type":"Address"},{"name":"expire_timestamp","type":"U64"},{"name":"self_matching_prevention","type":"U8"}]},"OrderCanceled":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"order_id","type":"U64"},{"name":"client_order_id","type":"U64"},{"name":"is_bid","type":"Bool"},{"name":"owner","type":"Address"},{"name":"original_quantity","type":"U64"},{"name":"base_asset_quantity_canceled","type":"U64"},{"name":"price","type":"U64"}]},"OrderFilled":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"order_id","type":"U64"},{"name":"taker_client_order_id","type":"U64"},{"name":"maker_client_order_id","type":"U64"},{"name":"is_bid","type":"Bool"},{"name":"taker_address","type":"Address"},{"name":"maker_address","type":"Address"},{"name":"original_quantity","type":"U64"},{"name":"base_asset_quantity_filled","type":"U64"},{"name":"base_asset_quantity_remaining","type":"U64"},{"name":"price","type":"U64"},{"name":"taker_commission","type":"U64"},{"name":"maker_rebates","type":"U64"}]},"OrderPlaced":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"order_id","type":"U64"},{"name":"client_order_id","type":"U64"},{"name":"is_bid","type":"Bool"},{"name":"owner","type":"Address"},{"name":"original_quantity","type":"U64"},{"name":"base_asset_quantity_placed","type":"U64"},{"name":"price","type":"U64"},{"name":"expire_timestamp","type":"U64"}]},"Pool":{"abilities":{"abilities":["Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true},{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"bids","type":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"Struct":{"address":"0xdee9","module":"clob_v2","name":"TickLevel","typeArguments":[]}}]}}},{"name":"asks","type":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"Struct":{"address":"0xdee9","module":"clob_v2","name":"TickLevel","typeArguments":[]}}]}}},{"name":"next_bid_order_id","type":"U64"},{"name":"next_ask_order_id","type":"U64"},{"name":"usr_open_orders","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["Address",{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":["U64","U64"]}}]}}},{"name":"taker_fee_rate","type":"U64"},{"name":"maker_rebate_rate","type":"U64"},{"name":"tick_size","type":"U64"},{"name":"lot_size","type":"U64"},{"name":"base_custodian","type":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"name":"quote_custodian","type":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":1}]}}},{"name":"creation_fee","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}}},{"name":"base_asset_trading_fees","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},{"name":"quote_asset_trading_fees","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":1}]}}}]},"PoolCreated":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"base_asset","type":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}},{"name":"quote_asset","type":{"Struct":{"address":"0x1","module":"type_name","name":"TypeName","typeArguments":[]}}},{"name":"taker_fee_rate","type":"U64"},{"name":"maker_rebate_rate","type":"U64"},{"name":"tick_size","type":"U64"},{"name":"lot_size","type":"U64"}]},"TickLevel":{"abilities":{"abilities":["Store"]},"typeParameters":[],"fields":[{"name":"price","type":"U64"},{"name":"open_orders","type":{"Struct":{"address":"0x2","module":"linked_table","name":"LinkedTable","typeArguments":["U64",{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Order","typeArguments":[]}}]}}}]},"WithdrawAsset":{"abilities":{"abilities":["Copy","Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"pool_id","type":{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}},{"name":"quantity","type":"U64"},{"name":"owner","type":"Address"}]}},"exposedFunctions":{"account_balance":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}}],"return":["U64","U64","U64","U64"]},"batch_cancel_order":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Vector":"U64"},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}}],"return":[]},"cancel_all_orders":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}}],"return":[]},"cancel_order":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64",{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}}],"return":[]},"clean_up_expired_orders":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}},{"Vector":"U64"},{"Vector":"Address"}],"return":[]},"create_account":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}]},"create_pool":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":["U64","U64",{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"Struct":{"address":"0x2","module":"sui","name":"SUI","typeArguments":[]}}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[]},"deposit_base":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}}],"return":[]},"deposit_quote":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}}],"return":[]},"get_level2_book_status_ask_side":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64","U64",{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}}],"return":[{"Vector":"U64"},{"Vector":"U64"}]},"get_level2_book_status_bid_side":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64","U64",{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}}],"return":[{"Vector":"U64"},{"Vector":"U64"}]},"get_market_price":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}}],"return":[{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}},{"Struct":{"address":"0x1","module":"option","name":"Option","typeArguments":["U64"]}}]},"get_order_status":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64",{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}}],"return":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Order","typeArguments":[]}}}]},"list_open_orders":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}}],"return":[{"Vector":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Order","typeArguments":[]}}}]},"place_limit_order":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64","U64","U64","U8","Bool","U64","U8",{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":["U64","U64","Bool","U64"]},"place_market_order":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}},"U64","U64","Bool",{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}},{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}]},"swap_exact_base_for_quote":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64",{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}},"U64",{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}},{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}},"U64"]},"swap_exact_quote_for_base":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64",{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}},"U64",{"Reference":{"Struct":{"address":"0x2","module":"clock","name":"Clock","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}},{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}},"U64"]},"withdraw_base":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64",{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]},"withdraw_quote":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":[]},{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"clob_v2","name":"Pool","typeArguments":[{"TypeParameter":0},{"TypeParameter":1}]}}},"U64",{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":1}]}}]}}},"critbit":{"fileFormatVersion":6,"address":"0xdee9","name":"critbit","friends":[{"address":"0xdee9","name":"clob"},{"address":"0xdee9","name":"clob_v2"}],"structs":{"CritbitTree":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":["Store"]},"isPhantom":false}],"fields":[{"name":"root","type":"U64"},{"name":"internal_nodes","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["U64",{"Struct":{"address":"0xdee9","module":"critbit","name":"InternalNode","typeArguments":[]}}]}}},{"name":"leaves","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["U64",{"Struct":{"address":"0xdee9","module":"critbit","name":"Leaf","typeArguments":[{"TypeParameter":0}]}}]}}},{"name":"min_leaf","type":"U64"},{"name":"max_leaf","type":"U64"},{"name":"next_internal_node_index","type":"U64"},{"name":"next_leaf_index","type":"U64"}]},"InternalNode":{"abilities":{"abilities":["Drop","Store"]},"typeParameters":[],"fields":[{"name":"mask","type":"U64"},{"name":"left_child","type":"U64"},{"name":"right_child","type":"U64"},{"name":"parent","type":"U64"}]},"Leaf":{"abilities":{"abilities":["Drop","Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":false}],"fields":[{"name":"key","type":"U64"},{"name":"value","type":{"TypeParameter":0}},{"name":"parent","type":"U64"}]}},"exposedFunctions":{"borrow_leaf_by_index":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_leaf_by_key":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"Reference":{"TypeParameter":0}}]},"borrow_mut_leaf_by_index":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"MutableReference":{"TypeParameter":0}}]},"destroy_empty":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"drop":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Drop","Store"]}],"parameters":[{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"find_closest_key":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":["U64"]},"find_leaf":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":["Bool","U64"]},"insert_leaf":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}},"U64",{"TypeParameter":0}],"return":["U64"]},"is_empty":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}}],"return":["Bool"]},"max_leaf":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64","U64"]},"min_leaf":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64","U64"]},"new":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}]},"next_leaf":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":["U64","U64"]},"previous_leaf":{"visibility":"Public","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":["U64","U64"]},"remove_leaf_by_index":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}},"U64"],"return":[{"TypeParameter":0}]},"size":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":["Store"]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"critbit","name":"CritbitTree","typeArguments":[{"TypeParameter":0}]}}}],"return":["U64"]}}},"custodian":{"fileFormatVersion":6,"address":"0xdee9","name":"custodian","friends":[{"address":"0xdee9","name":"clob"}],"structs":{"Account":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"available_balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},{"name":"locked_balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}]},"AccountCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}}]},"Custodian":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"account_balances","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":[{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},{"Struct":{"address":"0xdee9","module":"custodian","name":"Account","typeArguments":[{"TypeParameter":0}]}}]}}}]}},"exposedFunctions":{"account_available_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["U64"]},"account_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["U64","U64"]},"account_locked_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}}],"return":["U64"]},"decrease_user_available_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}},"U64"],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"decrease_user_locked_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"U64"],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"increase_user_available_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"increase_user_locked_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"lock_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}},"U64"],"return":[]},"mint_account_cap":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}]},"new":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}]},"unlock_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"Struct":{"address":"0x2","module":"object","name":"ID","typeArguments":[]}},"U64"],"return":[]},"withdraw_asset":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},"U64",{"Reference":{"Struct":{"address":"0xdee9","module":"custodian","name":"AccountCap","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]}}},"custodian_v2":{"fileFormatVersion":6,"address":"0xdee9","name":"custodian_v2","friends":[{"address":"0xdee9","name":"clob_v2"}],"structs":{"Account":{"abilities":{"abilities":["Store"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"available_balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}},{"name":"locked_balance","type":{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}}]},"AccountCap":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"owner","type":"Address"}]},"Custodian":{"abilities":{"abilities":["Store","Key"]},"typeParameters":[{"constraints":{"abilities":[]},"isPhantom":true}],"fields":[{"name":"id","type":{"Struct":{"address":"0x2","module":"object","name":"UID","typeArguments":[]}}},{"name":"account_balances","type":{"Struct":{"address":"0x2","module":"table","name":"Table","typeArguments":["Address",{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Account","typeArguments":[{"TypeParameter":0}]}}]}}}]}},"exposedFunctions":{"account_available_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},"Address"],"return":["U64"]},"account_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},"Address"],"return":["U64","U64"]},"account_locked_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},"Address"],"return":["U64"]},"account_owner":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}}],"return":["Address"]},"create_child_account_cap":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}]},"decrease_user_available_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}},"U64"],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"decrease_user_locked_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},"Address","U64"],"return":[{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}]},"delete_account_cap":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":[{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}],"return":[]},"increase_user_available_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},"Address",{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"increase_user_locked_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}},{"Struct":{"address":"0x2","module":"balance","name":"Balance","typeArguments":[{"TypeParameter":0}]}}],"return":[]},"lock_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}},"U64"],"return":[]},"mint_account_cap":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}]},"new":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}]},"unlock_balance":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},"Address","U64"],"return":[]},"withdraw_asset":{"visibility":"Friend","isEntry":false,"typeParameters":[{"abilities":[]}],"parameters":[{"MutableReference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"Custodian","typeArguments":[{"TypeParameter":0}]}}},"U64",{"Reference":{"Struct":{"address":"0xdee9","module":"custodian_v2","name":"AccountCap","typeArguments":[]}}},{"MutableReference":{"Struct":{"address":"0x2","module":"tx_context","name":"TxContext","typeArguments":[]}}}],"return":[{"Struct":{"address":"0x2","module":"coin","name":"Coin","typeArguments":[{"TypeParameter":0}]}}]}}},"math":{"fileFormatVersion":6,"address":"0xdee9","name":"math","friends":[{"address":"0xdee9","name":"clob"},{"address":"0xdee9","name":"clob_v2"},{"address":"0xdee9","name":"critbit"}],"structs":{},"exposedFunctions":{"count_leading_zeros":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["U128"],"return":["U8"]},"div_round":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["Bool","U64"]},"mul":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"mul_round":{"visibility":"Public","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["Bool","U64"]},"unsafe_div":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"unsafe_div_round":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["Bool","U64"]},"unsafe_mul":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["U64"]},"unsafe_mul_round":{"visibility":"Friend","isEntry":false,"typeParameters":[],"parameters":["U64","U64"],"return":["Bool","U64"]}}}}',
);

export function loadAllTypes(coder: MoveCoder) {
  _0x2.loadAllTypes(coder);
  _0x1.loadAllTypes(coder);
  for (const m of Object.values(MODULES)) {
    coder.load(m as any, "0xdee9");
  }
}

loadAllTypes(defaultMoveCoder());
