import { DatabaseSchema } from '../core/index.js';
import { DBRequest_DBOperator } from '@sentio/protos';
import { PluginManager } from '@sentio/runtime';
import { LocalCache } from './cache.js';
import { serializeRichValue } from './util.js';
export function getEntityName(entity) {
    if (entity == null) {
        throw new Error("can't figure out entityName from undefined");
    }
    if (typeof entity == 'string') {
        return entity;
    }
    if (typeof entity == 'function') {
        return entity.entityName;
    }
    if (typeof entity == 'object') {
        return entity.constructor.entityName;
    }
    throw new Error(`can't figure out entityName from ${typeof entity}`);
}
export class Store {
    context;
    cache = new LocalCache();
    constructor(context) {
        this.context = context;
    }
    async get(entity, id) {
        const entityName = getEntityName(entity);
        const cachedData = this.cache.get(entityName, id);
        if (cachedData) {
            return Promise.resolve(this.newEntity(entity, cachedData));
        }
        const promise = this.context.sendRequest({
            get: {
                entity: entityName,
                id: id.toString()
            }
        });
        const data = (await promise);
        if (data.entityList?.entities[0]) {
            const entityData = data.entityList?.entities[0];
            return this.newEntity(entity, entityData);
        }
        return undefined;
    }
    async delete(entity, id) {
        const request = {
            entity: [],
            id: []
        };
        const entityName = getEntityName(entity);
        if (id) {
            if (Array.isArray(id)) {
                for (const i of id) {
                    request.entity.push(entityName);
                    request.id.push(i.toString());
                    this.cache.delete(entityName, i.toString());
                }
            }
            else {
                request.entity.push(entityName);
                request.id.push(id);
                this.cache.delete(entityName, id);
            }
        }
        else {
            const entities = Array.isArray(entity) ? entity : [entity];
            for (const e of entities) {
                request.entity.push(entityName);
                request.id.push(e.id.toString());
                this.cache.delete(entityName, id);
            }
        }
        await this.context.sendRequest({
            delete: request
        });
    }
    async upsert(entity) {
        const entities = Array.isArray(entity) ? entity : [entity];
        const request = {
            upsert: {
                entity: entities.map((e) => getEntityName(e)),
                // data: entities.map((e) => serialize(e.data)),
                id: entities.map((e) => e.id.toString()),
                entityData: entities.map((e) => e._data)
            }
        };
        const promise = this.context.sendRequest(request);
        return promise.then((_data) => {
            request.upsert?.entity.forEach((entity, i) => {
                this.cache.set({
                    entity: entity,
                    data: request.upsert?.entityData[i],
                    genBlockChain: '',
                    genBlockTime: undefined,
                    genBlockNumber: 0n
                });
            });
        });
    }
    async *listIterator(entity, filters) {
        let cursor = undefined;
        while (true) {
            const response = await this.listRequest(entity, filters || [], cursor);
            for (const data of response.entityList?.entities || []) {
                yield this.newEntity(entity, data);
            }
            if (!response.nextCursor) {
                break;
            }
            cursor = response.nextCursor;
        }
    }
    async *listBatched(entity, filters, batchSize = 100) {
        let cursor = undefined;
        while (true) {
            const response = await this.listRequest(entity, filters || [], cursor, batchSize);
            const entities = (response.entityList?.entities || []).map((data) => this.newEntity(entity, data));
            yield entities;
            if (!response.nextCursor) {
                break;
            }
            cursor = response.nextCursor;
        }
    }
    async listRequest(entity, filters, cursor, pageSize) {
        const response = (await this.context.sendRequest({
            list: {
                entity: getEntityName(entity),
                cursor,
                pageSize,
                filters: filters?.map((f) => ({
                    field: f.field,
                    op: ops[f.op],
                    value: {
                        values: Array.isArray(f.value)
                            ? f.value.map((v) => serializeRichValue(v))
                            : [serializeRichValue(f.value)]
                    }
                })) || []
            }
        }, 3600));
        response.entityList?.entities?.forEach((entity) => {
            this.cache.set(entity);
        });
        return response;
    }
    async list(entity, filters, cursor) {
        if (cursor) {
            const response = await this.listRequest(entity, filters || [], cursor.cursor, cursor.pageSize);
            cursor.cursor = response.nextCursor;
            return response.entityList?.entities.map((data) => this.newEntity(entity, data)) || [];
        }
        // TODO Array.fromAsync when upgrade to node 22
        return this.fromAsync(this.listIterator(entity, filters ?? []));
    }
    async fromAsync(gen) {
        const out = [];
        for await (const x of gen) {
            out.push(x);
        }
        return out;
    }
    newEntity(entity, data) {
        if (typeof entity == 'string') {
            let en = DatabaseSchema.findEntity(entity);
            if (!en) {
                // it is an interface
                en = DatabaseSchema.findEntity(data.entity);
                if (!en) {
                    throw new Error(`Entity ${entity} not found`);
                }
            }
            entity = en;
        }
        const res = new entity({});
        res._data = data.data;
        return res;
    }
}
const ops = {
    '=': DBRequest_DBOperator.EQ,
    '!=': DBRequest_DBOperator.NE,
    '<': DBRequest_DBOperator.LT,
    '<=': DBRequest_DBOperator.LE,
    '>': DBRequest_DBOperator.GT,
    '>=': DBRequest_DBOperator.GE,
    in: DBRequest_DBOperator.IN,
    'not in': DBRequest_DBOperator.NOT_IN,
    like: DBRequest_DBOperator.LIKE,
    'not like': DBRequest_DBOperator.NOT_LIKE,
    'has all': DBRequest_DBOperator.HAS_ALL,
    'has any': DBRequest_DBOperator.HAS_ANY
};
export function getStore() {
    const dbContext = PluginManager.INSTANCE.dbContextLocalStorage.getStore();
    if (dbContext) {
        return new Store(dbContext);
    }
    return undefined;
}
//# sourceMappingURL=store.js.map