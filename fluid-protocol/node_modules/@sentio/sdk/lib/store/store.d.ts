import { StoreContext } from './context.js';
import { BigDecimal } from '@sentio/bigdecimal';
import { AbstractEntity as Entity, Bytes, Float, ID, Int, Timestamp } from './types.js';
import { Cursor } from './cursor.js';
export interface EntityClass<T> {
    new (data: Partial<T>): T;
}
export declare function getEntityName<T>(entity: EntityClass<T> | T | string): string;
export declare class Store {
    private readonly context;
    private cache;
    constructor(context: StoreContext);
    get<T extends Entity>(entity: EntityClass<T> | string, id: ID): Promise<T | undefined>;
    delete<T extends Entity>(entity: EntityClass<T> | T | T[], id?: string | string[]): Promise<void>;
    upsert<T extends Entity>(entity: T | T[]): Promise<void>;
    listIterator<T extends Entity, P extends keyof T, O extends Operators<T[P]>>(entity: EntityClass<T>, filters: ListFilter<T, P, O>[]): AsyncGenerator<T, void, unknown>;
    listBatched<T extends Entity, P extends keyof T, O extends Operators<T[P]>>(entity: EntityClass<T>, filters: ListFilter<T, P, O>[], batchSize?: number): AsyncGenerator<T[], void, unknown>;
    private listRequest;
    list<T extends Entity, P extends keyof T, O extends Operators<T[P]>>(entity: EntityClass<T>, filters?: ListFilter<T, P, O>[], cursor?: Cursor): Promise<T[]>;
    private fromAsync;
    private newEntity;
}
type ArrayOperators = 'in' | 'not in' | 'has all' | 'has any';
export type Operators<T> = T extends Array<any> ? 'in' | 'not in' | '=' | '!=' | 'has all' | 'has any' : T extends Int ? '=' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not in' : T extends Float ? '=' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not in' : T extends Bytes ? '=' | '!=' | 'in' | 'not in' : T extends ID ? '=' | '!=' | 'like' | 'not like' | 'in' | 'not in' : T extends string ? '=' | '!=' | 'like' | 'not like' | 'in' | 'not in' : T extends Timestamp ? '=' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not in' : T extends boolean ? '=' | '!=' | 'in' | 'not in' : T extends BigDecimal ? '=' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not in' : T extends bigint ? '=' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not in' : '=' | '!=' | 'in' | 'not in';
type CompatibleValue<T, O extends Operators<T>> = O extends ArrayOperators ? T extends Array<infer U> ? U[] : T[] : (T extends bigint ? bigint : T extends Int ? number : T extends Float ? number : T extends Bytes ? Bytes | string : T extends ID ? ID | string : T extends BigDecimal ? BigDecimal | number : T extends Int ? number : T) | Nullable<O>;
type Nullable<O> = O extends '=' | '!=' ? null : never;
export type ListFilter<T extends Entity, P extends keyof T, O extends Operators<T[P]>> = {
    field: P;
    op: O;
    value: CompatibleValue<T[P], O>;
};
export type ArrayFilter<T extends Entity, P extends keyof T, O extends Operators<T[P]>> = [
    P,
    O,
    CompatibleValue<T[P], O>
];
export declare function getStore(): Store | undefined;
export {};
//# sourceMappingURL=store.d.ts.map