import { Data_SuiCall, Data_SuiObject, HandleInterval, MoveAccountFetchConfig, MoveFetchConfig, MoveOwnerType, ProcessResult } from '@sentio/protos';
import { ListStateStorage } from '@sentio/runtime';
import { SuiNetwork } from './network.js';
import { SuiAddressContext, SuiContext, SuiObjectContext } from './context.js';
import { SuiMoveObject, SuiTransactionBlockResponse } from '@mysten/sui.js/client';
import { PromiseOrVoid } from '../core/index.js';
import { IndexConfigure, SuiBindOptions } from './sui-processor.js';
import { CallHandler, TransactionFilter } from '../move/index.js';
export interface SuiObjectBindOptions {
    objectId: string;
    network?: SuiNetwork;
    startCheckpoint?: bigint;
    baseLabels?: {
        [key: string]: string;
    };
}
interface ObjectHandler {
    type?: string;
    checkPointInterval?: HandleInterval;
    timeIntervalInMinutes?: HandleInterval;
    fetchConfig: MoveAccountFetchConfig;
    handler: (resource: Data_SuiObject) => Promise<ProcessResult>;
}
export declare const DEFAULT_ACCOUNT_FETCH_CONFIG: MoveAccountFetchConfig;
export declare class SuiAccountProcessorState extends ListStateStorage<SuiBaseObjectOrAddressProcessor<any>> {
    static INSTANCE: SuiAccountProcessorState;
}
export interface SuiInternalObjectsBindOptions extends SuiBindOptions {
    ownerType: MoveOwnerType;
}
export declare abstract class SuiBaseObjectOrAddressProcessor<HandlerType> {
    config: IndexConfigure;
    ownerType: MoveOwnerType;
    templateId: number | undefined;
    objectHandlers: ObjectHandler[];
    protected constructor(options: SuiInternalObjectsBindOptions);
    getChainId(): string;
    protected abstract doHandle(handler: HandlerType, data: Data_SuiObject, ctx: SuiObjectContext): PromiseOrVoid;
    onInterval(handler: HandlerType, //(resources: SuiMoveObject[], ctx: SuiObjectsContext) => PromiseOrVoid,
    timeInterval: HandleInterval | undefined, checkpointInterval: HandleInterval | undefined, type: string | undefined, fetchConfig: Partial<MoveAccountFetchConfig> | undefined): this;
    onTimeInterval(handler: HandlerType, timeIntervalInMinutes?: number, backfillTimeIntervalInMinutes?: number, type?: string, fetchConfig?: Partial<MoveAccountFetchConfig>): this;
    onCheckpointInterval(handler: HandlerType, checkpointInterval?: number, backfillCheckpointInterval?: number, type?: string, fetchConfig?: Partial<MoveAccountFetchConfig>): this;
}
export declare class SuiAddressProcessor extends SuiBaseObjectOrAddressProcessor<(objects: SuiMoveObject[], ctx: SuiAddressContext) => PromiseOrVoid> {
    callHandlers: CallHandler<Data_SuiCall>[];
    static bind(options: SuiBindOptions): SuiAddressProcessor;
    protected doHandle(handler: (objects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid, data: Data_SuiObject, ctx: SuiObjectContext): PromiseOrVoid;
    onTransactionBlock(handler: (transaction: SuiTransactionBlockResponse, ctx: SuiContext) => void, filter?: TransactionFilter, fetchConfig?: Partial<MoveFetchConfig>): this;
}
export declare class SuiObjectProcessor extends SuiBaseObjectOrAddressProcessor<(self: SuiMoveObject, dynamicFieldObjects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid> {
    static bind(options: SuiObjectBindOptions): SuiObjectProcessor;
    protected doHandle(handler: (self: SuiMoveObject, dynamicFieldObjects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid, data: Data_SuiObject, ctx: SuiObjectContext): PromiseOrVoid;
}
export declare class SuiWrappedObjectProcessor extends SuiBaseObjectOrAddressProcessor<(dynamicFieldObjects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid> {
    static bind(options: SuiObjectBindOptions): SuiWrappedObjectProcessor;
    protected doHandle(handler: (dynamicFieldObjects: SuiMoveObject[], ctx: SuiObjectContext) => PromiseOrVoid, data: Data_SuiObject, ctx: SuiObjectContext): PromiseOrVoid;
}
export {};
//# sourceMappingURL=sui-object-processor.d.ts.map