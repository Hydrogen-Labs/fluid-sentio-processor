import * as fs from 'fs';
import chalk from 'chalk';
import { structQname } from '@typemove/move';
import { SuiCodegen as BaseSuiCodegen } from '@typemove/sui/codegen';
import path, { join } from 'path';
import { SharedNetworkCodegen } from '../../move/shared-network-codegen.js';
import { getRpcEndpoint, SuiNetwork } from '../network.js';
export async function codegen(abisDir, outDir = join('src', 'types', 'sui'), genExample = false, builtin = false) {
    if (!fs.existsSync(abisDir)) {
        return;
    }
    const gen = new SuiCodegen();
    const numFiles = await gen.generate(abisDir, outDir, builtin);
    console.log(chalk.green(`Generated ${numFiles} for Sui`));
}
class SuiNetworkCodegen extends BaseSuiCodegen {
    moduleGenerator;
    constructor(network) {
        const endpoint = getRpcEndpoint(network);
        super(endpoint);
        this.moduleGenerator = new (class extends SharedNetworkCodegen {
            ADDRESS_TYPE = 'string';
            PREFIX = 'Sui';
            SYSTEM_PACKAGE = '@typemove/sui';
            generateNetworkOption(network) {
                switch (network) {
                    case SuiNetwork.MAIN_NET:
                        return 'MAIN_NET';
                    case SuiNetwork.MOVEMENT_MAIN_NET:
                        return 'MOVEMENT_MAIN_NET';
                    case SuiNetwork.MOVEMENT_TEST_NET:
                        return 'MOVEMENT_TEST_NET';
                    default:
                        return 'TEST_NET';
                }
            }
            generateStructs(module, struct, events) {
                let content = '';
                switch (structQname(module, struct)) {
                    // TODO they should still have module code generated
                    case '0x1::ascii::Char':
                    case '0x1::ascii::String':
                    case '0x2::object::ID':
                        content += `export type ${struct.name} = string`;
                        break;
                    case '0x2::coin::Coin':
                        content += `export type ${struct.name}<T> = string`;
                        break;
                    case '0x2::balance::Balance':
                        content += `export type ${struct.name}<T> = bigint`;
                        break;
                    case '0x1::option::Option':
                        content += `export type Option<T> = T | undefined`;
                        break;
                }
                return content + super.generateStructs(module, struct, events, content !== '');
            }
            generateForOnEvents(module, struct) {
                switch (structQname(module, struct)) {
                    case '0x1::ascii::Char':
                    case '0x1::ascii::String':
                    case '0x2::object::ID':
                    case '0x2::coin::Coin':
                    case '0x1::option::Option':
                    case '0x2::balance::Balance':
                        return '';
                }
                return super.generateForOnEvents(module, struct);
            }
        })(network, this.chainAdapter);
    }
    generateModule(module, allEventStructs) {
        return this.moduleGenerator.generateModule(module, allEventStructs);
    }
    generateImports() {
        return this.moduleGenerator.generateImports();
    }
    generateLoadAll(isSystem) {
        return this.moduleGenerator.generateLoadAll(isSystem);
    }
}
//
const MAINNET_CODEGEN = new SuiNetworkCodegen(SuiNetwork.MAIN_NET);
const TESTNET_CODEGEN = new SuiNetworkCodegen(SuiNetwork.TEST_NET);
class SuiCodegen {
    async generate(srcDir, outputDir, builtin = false) {
        const num1 = await MAINNET_CODEGEN.generate(srcDir, outputDir, builtin);
        const num2 = await TESTNET_CODEGEN.generate(path.join(srcDir, 'testnet'), path.join(outputDir, 'testnet'), builtin);
        return num1 + num2;
    }
}
//# sourceMappingURL=codegen.js.map