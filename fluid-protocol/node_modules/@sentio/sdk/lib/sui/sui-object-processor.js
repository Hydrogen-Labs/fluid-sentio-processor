import { MoveFetchConfig, MoveOwnerType } from '@sentio/protos';
import { ListStateStorage } from '@sentio/runtime';
import { SuiContext, SuiObjectContext } from './context.js';
import { configure, DEFAULT_FETCH_CONFIG } from './sui-processor.js';
import { ServerError, Status } from 'nice-grpc';
export const DEFAULT_ACCOUNT_FETCH_CONFIG = {
    owned: false
};
export class SuiAccountProcessorState extends ListStateStorage {
    static INSTANCE = new SuiAccountProcessorState();
}
export class SuiBaseObjectOrAddressProcessor {
    config;
    ownerType;
    templateId;
    objectHandlers = [];
    // static bind(options: SuiObjectsBindOptions): SuiBaseObjectsProcessor<any> {
    //   return new SuiBaseObjectsProcessor(options)
    // }
    constructor(options) {
        this.config = configure(options);
        this.ownerType = options.ownerType;
        SuiAccountProcessorState.INSTANCE.addValue(this);
    }
    getChainId() {
        return this.config.network;
    }
    onInterval(handler, //(resources: SuiMoveObject[], ctx: SuiObjectsContext) => PromiseOrVoid,
    timeInterval, checkpointInterval, type, fetchConfig) {
        const processor = this;
        this.objectHandlers.push({
            handler: async function (data) {
                const ctx = new SuiObjectContext(processor.config.network, processor.config.address, data.slot, data.timestamp || new Date(0), processor.config.baseLabels);
                await processor.doHandle(handler, data, ctx);
                return ctx.stopAndGetResult();
            },
            timeIntervalInMinutes: timeInterval,
            checkPointInterval: checkpointInterval,
            type,
            fetchConfig: { ...DEFAULT_ACCOUNT_FETCH_CONFIG, ...fetchConfig }
        });
        return this;
    }
    onTimeInterval(handler, timeIntervalInMinutes = 60, backfillTimeIntervalInMinutes = 240, type, fetchConfig) {
        return this.onInterval(handler, {
            recentInterval: timeIntervalInMinutes,
            backfillInterval: backfillTimeIntervalInMinutes
        }, undefined, type, fetchConfig);
    }
    onCheckpointInterval(handler, checkpointInterval = 100000, backfillCheckpointInterval = 400000, type, fetchConfig) {
        return this.onInterval(handler, undefined, { recentInterval: checkpointInterval, backfillInterval: backfillCheckpointInterval }, type, fetchConfig);
    }
}
export class SuiAddressProcessor extends SuiBaseObjectOrAddressProcessor {
    callHandlers = [];
    static bind(options) {
        return new SuiAddressProcessor({ ...options, ownerType: MoveOwnerType.ADDRESS });
    }
    doHandle(handler, data, ctx) {
        return handler(data.objects, ctx);
    }
    onTransactionBlock(handler, filter, fetchConfig) {
        const _fetchConfig = MoveFetchConfig.fromPartial({ ...DEFAULT_FETCH_CONFIG, ...fetchConfig });
        const _filter = {
            fromAndToAddress: {
                from: '',
                to: this.config.address
            },
            ...filter
        };
        const processor = this;
        this.callHandlers.push({
            handler: async function (data) {
                if (!data.transaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'transaction is null');
                }
                const tx = data.transaction;
                const ctx = new SuiContext('object', processor.config.network, processor.config.address, data.timestamp || new Date(0), data.slot, tx, 0, processor.config.baseLabels);
                if (tx) {
                    await handler(tx, ctx);
                }
                return ctx.stopAndGetResult();
            },
            filters: [{ ..._filter, function: '' }],
            fetchConfig: _fetchConfig
        });
        return this;
    }
}
export class SuiObjectProcessor extends SuiBaseObjectOrAddressProcessor {
    static bind(options) {
        return new SuiObjectProcessor({
            address: options.objectId,
            network: options.network,
            startCheckpoint: options.startCheckpoint,
            ownerType: MoveOwnerType.OBJECT,
            baseLabels: options.baseLabels
        });
    }
    doHandle(handler, data, ctx) {
        if (!data.self) {
            console.log(`Sui object not existed in ${ctx.checkpoint}, please specific a start time`);
            return;
        }
        return handler(data.self, data.objects, ctx);
    }
}
export class SuiWrappedObjectProcessor extends SuiBaseObjectOrAddressProcessor {
    static bind(options) {
        return new SuiWrappedObjectProcessor({
            address: options.objectId,
            network: options.network,
            startCheckpoint: options.startCheckpoint,
            ownerType: MoveOwnerType.WRAPPED_OBJECT,
            baseLabels: options.baseLabels
        });
    }
    doHandle(handler, data, ctx) {
        return handler(data.objects, ctx);
    }
}
//# sourceMappingURL=sui-object-processor.js.map