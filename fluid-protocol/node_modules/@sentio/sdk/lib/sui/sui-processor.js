import { MoveFetchConfig } from '@sentio/protos';
import { ListStateStorage, mergeProcessResults } from '@sentio/runtime';
import { SuiNetwork } from './network.js';
import { ServerError, Status } from 'nice-grpc';
import { SuiContext, SuiObjectChangeContext } from './context.js';
import { accountAddressString, parseMoveType, SPLITTER } from '../move/index.js';
import { getMoveCalls } from './utils.js';
import { defaultMoveCoder } from './index.js';
export const DEFAULT_FETCH_CONFIG = {
    resourceChanges: false,
    allEvents: false,
    inputs: false
};
export function configure(options) {
    return {
        startCheckpoint: options.startCheckpoint || 0n,
        address: options.address === '*' ? '*' : accountAddressString(options.address),
        network: options.network || SuiNetwork.MAIN_NET,
        baseLabels: options.baseLabels
    };
}
export class SuiProcessorState extends ListStateStorage {
    static INSTANCE = new SuiProcessorState();
}
export class SuiBaseProcessor {
    moduleName;
    config;
    eventHandlers = [];
    callHandlers = [];
    objectChangeHandlers = [];
    coder;
    constructor(name, options) {
        this.moduleName = name;
        this.config = configure(options);
        SuiProcessorState.INSTANCE.addValue(this);
        this.coder = defaultMoveCoder(this.config.network);
    }
    getChainId() {
        return this.config.network;
    }
    onMoveEvent(handler, filter, fetchConfig) {
        let _filters = [];
        const _fetchConfig = MoveFetchConfig.fromPartial({ ...DEFAULT_FETCH_CONFIG, ...fetchConfig });
        if (Array.isArray(filter)) {
            _filters = filter;
        }
        else {
            _filters.push(filter);
        }
        // const address = this.config.address
        // const moduleName = this.moduleName
        const processor = this;
        const allEventType = new Set(_filters.map((f) => f.type));
        this.eventHandlers.push({
            handler: async function (data) {
                if (!data.transaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'event is null');
                }
                const txn = data.transaction;
                if (!txn.events || !txn.events.length) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'no event in the transactions');
                }
                const processResults = [];
                for (const evt of txn.events) {
                    const idx = Number(evt.id.eventSeq) || 0;
                    const [_, module, type] = parseMoveType(evt.type).qname.split(SPLITTER);
                    if (!allEventType.has([module, type].join(SPLITTER))) {
                        continue;
                    }
                    const ctx = new SuiContext(processor.moduleName, processor.config.network, processor.config.address, data.timestamp || new Date(0), data.slot, txn, idx, processor.config.baseLabels);
                    // const parts = typeQname.split(SPLITTER)
                    // if (evt.packageId && parts[0] != evt.packageId) {
                    //   evt.type = evt.type.replace(parts[0], evt.packageId)
                    // }
                    const decoded = await processor.coder.decodeEvent(evt);
                    await handler(decoded || evt, ctx);
                    processResults.push(ctx.stopAndGetResult());
                }
                return mergeProcessResults(processResults);
            },
            filters: _filters,
            fetchConfig: _fetchConfig
        });
        return this;
    }
    onEntryFunctionCall(handler, filter, fetchConfig) {
        let _filters = [];
        const _fetchConfig = MoveFetchConfig.fromPartial({ ...DEFAULT_FETCH_CONFIG, ...fetchConfig });
        if (Array.isArray(filter)) {
            _filters = filter;
        }
        else {
            _filters.push(filter);
        }
        const processor = this;
        const allFunctionType = new Set(_filters.map((f) => f.function));
        this.callHandlers.push({
            handler: async function (data) {
                if (!data.transaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'call is null');
                }
                const tx = data.transaction;
                const ctx = new SuiContext(processor.moduleName, processor.config.network, processor.config.address, data.timestamp || new Date(0), data.slot, tx, 0, processor.config.baseLabels);
                if (tx) {
                    const calls = getMoveCalls(tx);
                    const txKind = tx.transaction?.data?.transaction;
                    if (!txKind) {
                        throw new ServerError(Status.INVALID_ARGUMENT, 'Unexpected getTransactionKind get empty');
                    }
                    // getProgrammableTransaction(txKind)
                    const programmableTx = txKind.kind === 'ProgrammableTransaction' ? txKind : undefined;
                    // TODO potential pass index
                    for (const call of calls) {
                        const functionType = [call.module, call.function].join(SPLITTER);
                        if (!allFunctionType.has(functionType)) {
                            continue;
                        }
                        // TODO maybe do in parallel
                        const decoded = await processor.coder.decodeFunctionPayload(call, programmableTx?.inputs || []);
                        await handler(decoded, ctx);
                    }
                }
                return ctx.stopAndGetResult();
            },
            filters: _filters,
            fetchConfig: _fetchConfig
        });
        return this;
    }
    onEvent(handler, fetchConfig) {
        this.onMoveEvent(handler, { type: '' }, fetchConfig);
        return this;
    }
    onTransactionBlock(handler, filter, fetchConfig) {
        const _fetchConfig = MoveFetchConfig.fromPartial({ ...DEFAULT_FETCH_CONFIG, ...fetchConfig });
        const processor = this;
        this.callHandlers.push({
            handler: async function (data) {
                if (!data.transaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'transaction is null');
                }
                const tx = data.transaction;
                const ctx = new SuiContext(processor.moduleName, processor.config.network, processor.config.address, data.timestamp || new Date(0), data.slot, tx, 0, processor.config.baseLabels);
                if (tx) {
                    await handler(tx, ctx);
                }
                return ctx.stopAndGetResult();
            },
            filters: [{ ...filter, function: '' }],
            fetchConfig: _fetchConfig
        });
        return this;
    }
    onObjectChange(handler, type) {
        if (this.config.network === SuiNetwork.TEST_NET) {
            throw new ServerError(Status.INVALID_ARGUMENT, 'object change not supported in testnet');
        }
        const processor = this;
        this.objectChangeHandlers.push({
            handler: async function (data) {
                const ctx = new SuiObjectChangeContext(processor.config.network, processor.config.address, data.timestamp || new Date(0), data.slot, data.txDigest, processor.config.baseLabels);
                await handler(data.changes, ctx);
                return ctx.stopAndGetResult();
            },
            type
        });
        return this;
    }
}
export class SuiModulesProcessor extends SuiBaseProcessor {
    static bind(options) {
        return new SuiModulesProcessor('*', options);
    }
}
export class SuiGlobalProcessor extends SuiBaseProcessor {
    static bind(options) {
        return new SuiGlobalProcessor('*', { ...options, address: '*' });
    }
    onTransactionBlock(handler, filter, fetchConfig) {
        // TODO enable more strict check
        // if (!filter.publicKeyPrefix || filter.publicKeyPrefix.length < 2) {
        //   throw new ServerError(Status.INVALID_ARGUMENT, 'restriction too low for global processor')
        // }
        return super.onTransactionBlock(handler, filter, fetchConfig);
    }
    onObjectChange(handler, type) {
        return super.onObjectChange(handler, type);
    }
}
//# sourceMappingURL=sui-processor.js.map