import { TypeDescriptor } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/sui";
import { CallFilter, MoveFetchConfig } from "@sentio/sdk/move";
import { SuiBindOptions, SuiBaseProcessor, TypedFunctionPayload, SuiContext } from "@sentio/sdk/sui";
import * as _0x1 from "./0x1.js";
export declare namespace address { }
export declare class authenticator_state extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): authenticator_state;
    onEventActiveJwk(func: (event: authenticator_state.ActiveJwkInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): authenticator_state;
    onEventJWK(func: (event: authenticator_state.JWKInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): authenticator_state;
    onEventJwkId(func: (event: authenticator_state.JwkIdInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): authenticator_state;
}
export declare namespace authenticator_state {
    interface ActiveJwk {
        jwk_id: authenticator_state.JwkId;
        jwk: authenticator_state.JWK;
        epoch: bigint;
    }
    namespace ActiveJwk {
        const TYPE_QNAME = "0x2::authenticator_state::ActiveJwk";
        function type(): TypeDescriptor<ActiveJwk>;
    }
    interface ActiveJwkInstance extends TypedEventInstance<ActiveJwk> {
        data_decoded: ActiveJwk;
        type_arguments: [];
    }
    interface AuthenticatorState {
        id: object_.UID;
        version: bigint;
    }
    namespace AuthenticatorState {
        const TYPE_QNAME = "0x2::authenticator_state::AuthenticatorState";
        function type(): TypeDescriptor<AuthenticatorState>;
    }
    interface AuthenticatorStateInner {
        version: bigint;
        active_jwks: authenticator_state.ActiveJwk[];
    }
    namespace AuthenticatorStateInner {
        const TYPE_QNAME = "0x2::authenticator_state::AuthenticatorStateInner";
        function type(): TypeDescriptor<AuthenticatorStateInner>;
    }
    interface JWK {
        kty: string;
        e: string;
        n: string;
        alg: string;
    }
    namespace JWK {
        const TYPE_QNAME = "0x2::authenticator_state::JWK";
        function type(): TypeDescriptor<JWK>;
    }
    interface JWKInstance extends TypedEventInstance<JWK> {
        data_decoded: JWK;
        type_arguments: [];
    }
    interface JwkId {
        iss: string;
        kid: string;
    }
    namespace JwkId {
        const TYPE_QNAME = "0x2::authenticator_state::JwkId";
        function type(): TypeDescriptor<JwkId>;
    }
    interface JwkIdInstance extends TypedEventInstance<JwkId> {
        data_decoded: JwkId;
        type_arguments: [];
    }
}
export declare namespace bag {
    interface Bag {
        id: object_.UID;
        size: bigint;
    }
    namespace Bag {
        const TYPE_QNAME = "0x2::bag::Bag";
        function type(): TypeDescriptor<Bag>;
    }
}
export declare namespace balance {
    type Balance<T> = bigint;
    namespace Balance {
        const TYPE_QNAME = "0x2::balance::Balance";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Balance<T0>>;
    }
    interface Supply<T0> {
        value: bigint;
    }
    namespace Supply {
        const TYPE_QNAME = "0x2::balance::Supply";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Supply<T0>>;
    }
}
export declare class bcs extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): bcs;
    onEventBCS(func: (event: bcs.BCSInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): bcs;
}
export declare namespace bcs {
    interface BCS {
        bytes: number[];
    }
    namespace BCS {
        const TYPE_QNAME = "0x2::bcs::BCS";
        function type(): TypeDescriptor<BCS>;
    }
    interface BCSInstance extends TypedEventInstance<BCS> {
        data_decoded: BCS;
        type_arguments: [];
    }
}
export declare namespace bls12381 {
    interface G1 {
        dummy_field: Boolean;
    }
    namespace G1 {
        const TYPE_QNAME = "0x2::bls12381::G1";
        function type(): TypeDescriptor<G1>;
    }
    interface G2 {
        dummy_field: Boolean;
    }
    namespace G2 {
        const TYPE_QNAME = "0x2::bls12381::G2";
        function type(): TypeDescriptor<G2>;
    }
    interface GT {
        dummy_field: Boolean;
    }
    namespace GT {
        const TYPE_QNAME = "0x2::bls12381::GT";
        function type(): TypeDescriptor<GT>;
    }
    interface Scalar {
        dummy_field: Boolean;
    }
    namespace Scalar {
        const TYPE_QNAME = "0x2::bls12381::Scalar";
        function type(): TypeDescriptor<Scalar>;
    }
}
export declare namespace borrow {
    interface Borrow {
        ref: string;
        obj: object_.ID;
    }
    namespace Borrow {
        const TYPE_QNAME = "0x2::borrow::Borrow";
        function type(): TypeDescriptor<Borrow>;
    }
    interface Referent<T0> {
        id: string;
        value: _0x1.option.Option<T0>;
    }
    namespace Referent {
        const TYPE_QNAME = "0x2::borrow::Referent";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Referent<T0>>;
    }
}
export declare namespace clock {
    interface Clock {
        id: object_.UID;
        timestamp_ms: bigint;
    }
    namespace Clock {
        const TYPE_QNAME = "0x2::clock::Clock";
        function type(): TypeDescriptor<Clock>;
    }
}
export declare class coin extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): coin;
    onEntryBurn(func: (call: coin.BurnPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEntryJoin(func: (call: coin.JoinPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEntryMintAndTransfer(func: (call: coin.MintAndTransferPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEntryUpdateDescription(func: (call: coin.UpdateDescriptionPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEntryUpdateIconUrl(func: (call: coin.UpdateIconUrlPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEntryUpdateName(func: (call: coin.UpdateNamePayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEntryUpdateSymbol(func: (call: coin.UpdateSymbolPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEventCurrencyCreated(func: (event: coin.CurrencyCreatedInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): coin;
}
export declare namespace coin {
    type Coin<T> = string;
    namespace Coin {
        const TYPE_QNAME = "0x2::coin::Coin";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Coin<T0>>;
    }
    interface CoinMetadata<T0> {
        id: object_.UID;
        decimals: number;
        name: string;
        symbol: _0x1.ascii.String;
        description: string;
        icon_url: _0x1.option.Option<url.Url>;
    }
    namespace CoinMetadata {
        const TYPE_QNAME = "0x2::coin::CoinMetadata";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinMetadata<T0>>;
    }
    interface CurrencyCreated<T0> {
        decimals: number;
    }
    namespace CurrencyCreated {
        const TYPE_QNAME = "0x2::coin::CurrencyCreated";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CurrencyCreated<T0>>;
    }
    interface CurrencyCreatedInstance extends TypedEventInstance<CurrencyCreated<any>> {
        data_decoded: CurrencyCreated<any>;
        type_arguments: [string];
    }
    interface DenyCap<T0> {
        id: object_.UID;
    }
    namespace DenyCap {
        const TYPE_QNAME = "0x2::coin::DenyCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<DenyCap<T0>>;
    }
    interface DenyCapV2<T0> {
        id: object_.UID;
        allow_global_pause: Boolean;
    }
    namespace DenyCapV2 {
        const TYPE_QNAME = "0x2::coin::DenyCapV2";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<DenyCapV2<T0>>;
    }
    interface RegulatedCoinMetadata<T0> {
        id: object_.UID;
        coin_metadata_object: object_.ID;
        deny_cap_object: object_.ID;
    }
    namespace RegulatedCoinMetadata {
        const TYPE_QNAME = "0x2::coin::RegulatedCoinMetadata";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<RegulatedCoinMetadata<T0>>;
    }
    interface TreasuryCap<T0> {
        id: object_.UID;
        total_supply: balance.Supply<T0>;
    }
    namespace TreasuryCap {
        const TYPE_QNAME = "0x2::coin::TreasuryCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TreasuryCap<T0>>;
    }
    interface BurnPayload<T0 = any> extends TypedFunctionPayload<[string, coin.Coin<T0>]> {
        arguments_decoded: [string, coin.Coin<T0>];
        type_arguments: [string];
    }
    interface JoinPayload<T0 = any> extends TypedFunctionPayload<[string, coin.Coin<T0>]> {
        arguments_decoded: [string, coin.Coin<T0>];
        type_arguments: [string];
    }
    interface MintAndTransferPayload<T0 = any> extends TypedFunctionPayload<[string, bigint, string, string]> {
        arguments_decoded: [string, bigint, string, string];
        type_arguments: [string];
    }
    interface UpdateDescriptionPayload<T0 = any> extends TypedFunctionPayload<[string, string, string]> {
        arguments_decoded: [string, string, string];
        type_arguments: [string];
    }
    interface UpdateIconUrlPayload<T0 = any> extends TypedFunctionPayload<[string, string, _0x1.ascii.String]> {
        arguments_decoded: [string, string, _0x1.ascii.String];
        type_arguments: [string];
    }
    interface UpdateNamePayload<T0 = any> extends TypedFunctionPayload<[string, string, string]> {
        arguments_decoded: [string, string, string];
        type_arguments: [string];
    }
    interface UpdateSymbolPayload<T0 = any> extends TypedFunctionPayload<[string, string, _0x1.ascii.String]> {
        arguments_decoded: [string, string, _0x1.ascii.String];
        type_arguments: [string];
    }
}
export declare namespace config {
    interface Config<T0> {
        id: object_.UID;
    }
    namespace Config {
        const TYPE_QNAME = "0x2::config::Config";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Config<T0>>;
    }
    interface Setting<T0> {
        data: _0x1.option.Option<config.SettingData<T0>>;
    }
    namespace Setting {
        const TYPE_QNAME = "0x2::config::Setting";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Setting<T0>>;
    }
    interface SettingData<T0> {
        newer_value_epoch: bigint;
        newer_value: _0x1.option.Option<T0>;
        older_value_opt: _0x1.option.Option<T0>;
    }
    namespace SettingData {
        const TYPE_QNAME = "0x2::config::SettingData";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<SettingData<T0>>;
    }
}
export declare class deny_list extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): deny_list;
    onEventAddressKey(func: (event: deny_list.AddressKeyInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): deny_list;
    onEventConfigKey(func: (event: deny_list.ConfigKeyInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): deny_list;
    onEventGlobalPauseKey(func: (event: deny_list.GlobalPauseKeyInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): deny_list;
    onEventPerTypeConfigCreated(func: (event: deny_list.PerTypeConfigCreatedInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): deny_list;
}
export declare namespace deny_list {
    interface AddressKey {
        pos0: string;
    }
    namespace AddressKey {
        const TYPE_QNAME = "0x2::deny_list::AddressKey";
        function type(): TypeDescriptor<AddressKey>;
    }
    interface AddressKeyInstance extends TypedEventInstance<AddressKey> {
        data_decoded: AddressKey;
        type_arguments: [];
    }
    interface ConfigKey {
        per_type_index: bigint;
        per_type_key: number[];
    }
    namespace ConfigKey {
        const TYPE_QNAME = "0x2::deny_list::ConfigKey";
        function type(): TypeDescriptor<ConfigKey>;
    }
    interface ConfigKeyInstance extends TypedEventInstance<ConfigKey> {
        data_decoded: ConfigKey;
        type_arguments: [];
    }
    interface ConfigWriteCap {
        dummy_field: Boolean;
    }
    namespace ConfigWriteCap {
        const TYPE_QNAME = "0x2::deny_list::ConfigWriteCap";
        function type(): TypeDescriptor<ConfigWriteCap>;
    }
    interface DenyList {
        id: object_.UID;
        lists: bag.Bag;
    }
    namespace DenyList {
        const TYPE_QNAME = "0x2::deny_list::DenyList";
        function type(): TypeDescriptor<DenyList>;
    }
    interface GlobalPauseKey {
        dummy_field: Boolean;
    }
    namespace GlobalPauseKey {
        const TYPE_QNAME = "0x2::deny_list::GlobalPauseKey";
        function type(): TypeDescriptor<GlobalPauseKey>;
    }
    interface GlobalPauseKeyInstance extends TypedEventInstance<GlobalPauseKey> {
        data_decoded: GlobalPauseKey;
        type_arguments: [];
    }
    interface PerTypeConfigCreated {
        key: deny_list.ConfigKey;
        config_id: object_.ID;
    }
    namespace PerTypeConfigCreated {
        const TYPE_QNAME = "0x2::deny_list::PerTypeConfigCreated";
        function type(): TypeDescriptor<PerTypeConfigCreated>;
    }
    interface PerTypeConfigCreatedInstance extends TypedEventInstance<PerTypeConfigCreated> {
        data_decoded: PerTypeConfigCreated;
        type_arguments: [];
    }
    interface PerTypeList {
        id: object_.UID;
        denied_count: table.Table<string, bigint>;
        denied_addresses: table.Table<number[], vec_set.VecSet<string>>;
    }
    namespace PerTypeList {
        const TYPE_QNAME = "0x2::deny_list::PerTypeList";
        function type(): TypeDescriptor<PerTypeList>;
    }
}
export declare class display extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): display;
    onEntryAdd(func: (call: display.AddPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): display;
    onEntryAddMultiple(func: (call: display.AddMultiplePayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): display;
    onEntryCreateAndKeep(func: (call: display.CreateAndKeepPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): display;
    onEntryEdit(func: (call: display.EditPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): display;
    onEntryRemove(func: (call: display.RemovePayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): display;
    onEntryUpdateVersion(func: (call: display.UpdateVersionPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): display;
    onEventDisplayCreated(func: (event: display.DisplayCreatedInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): display;
    onEventVersionUpdated(func: (event: display.VersionUpdatedInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): display;
}
export declare namespace display {
    interface Display<T0> {
        id: object_.UID;
        fields: vec_map.VecMap<string, string>;
        version: number;
    }
    namespace Display {
        const TYPE_QNAME = "0x2::display::Display";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Display<T0>>;
    }
    interface DisplayCreated<T0> {
        id: object_.ID;
    }
    namespace DisplayCreated {
        const TYPE_QNAME = "0x2::display::DisplayCreated";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<DisplayCreated<T0>>;
    }
    interface DisplayCreatedInstance extends TypedEventInstance<DisplayCreated<any>> {
        data_decoded: DisplayCreated<any>;
        type_arguments: [string];
    }
    interface VersionUpdated<T0> {
        id: object_.ID;
        version: number;
        fields: vec_map.VecMap<string, string>;
    }
    namespace VersionUpdated {
        const TYPE_QNAME = "0x2::display::VersionUpdated";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<VersionUpdated<T0>>;
    }
    interface VersionUpdatedInstance extends TypedEventInstance<VersionUpdated<any>> {
        data_decoded: VersionUpdated<any>;
        type_arguments: [string];
    }
    interface AddPayload<T0 = any> extends TypedFunctionPayload<[string, string, string]> {
        arguments_decoded: [string, string, string];
        type_arguments: [string];
    }
    interface AddMultiplePayload<T0 = any> extends TypedFunctionPayload<[string, string[], string[]]> {
        arguments_decoded: [string, string[], string[]];
        type_arguments: [string];
    }
    interface CreateAndKeepPayload<T0 = any> extends TypedFunctionPayload<[string, string]> {
        arguments_decoded: [string, string];
        type_arguments: [string];
    }
    interface EditPayload<T0 = any> extends TypedFunctionPayload<[string, string, string]> {
        arguments_decoded: [string, string, string];
        type_arguments: [string];
    }
    interface RemovePayload<T0 = any> extends TypedFunctionPayload<[string, string]> {
        arguments_decoded: [string, string];
        type_arguments: [string];
    }
    interface UpdateVersionPayload<T0 = any> extends TypedFunctionPayload<[string]> {
        arguments_decoded: [string];
        type_arguments: [string];
    }
}
export declare namespace dynamic_field {
    interface Field<T0, T1> {
        id: object_.UID;
        name: T0;
        value: T1;
    }
    namespace Field {
        const TYPE_QNAME = "0x2::dynamic_field::Field";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Field<T0, T1>>;
    }
}
export declare class dynamic_object_field extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): dynamic_object_field;
    onEventWrapper(func: (event: dynamic_object_field.WrapperInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): dynamic_object_field;
}
export declare namespace dynamic_object_field {
    interface Wrapper<T0> {
        name: T0;
    }
    namespace Wrapper {
        const TYPE_QNAME = "0x2::dynamic_object_field::Wrapper";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Wrapper<T0>>;
    }
    interface WrapperInstance extends TypedEventInstance<Wrapper<any>> {
        data_decoded: Wrapper<any>;
        type_arguments: [string];
    }
}
export declare namespace ecdsa_k1 { }
export declare namespace ecdsa_r1 { }
export declare namespace ecvrf { }
export declare namespace ed25519 { }
export declare namespace event { }
export declare class groth16 extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): groth16;
    onEventCurve(func: (event: groth16.CurveInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): groth16;
    onEventPreparedVerifyingKey(func: (event: groth16.PreparedVerifyingKeyInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): groth16;
    onEventProofPoints(func: (event: groth16.ProofPointsInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): groth16;
    onEventPublicProofInputs(func: (event: groth16.PublicProofInputsInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): groth16;
}
export declare namespace groth16 {
    interface Curve {
        id: number;
    }
    namespace Curve {
        const TYPE_QNAME = "0x2::groth16::Curve";
        function type(): TypeDescriptor<Curve>;
    }
    interface CurveInstance extends TypedEventInstance<Curve> {
        data_decoded: Curve;
        type_arguments: [];
    }
    interface PreparedVerifyingKey {
        vk_gamma_abc_g1_bytes: number[];
        alpha_g1_beta_g2_bytes: number[];
        gamma_g2_neg_pc_bytes: number[];
        delta_g2_neg_pc_bytes: number[];
    }
    namespace PreparedVerifyingKey {
        const TYPE_QNAME = "0x2::groth16::PreparedVerifyingKey";
        function type(): TypeDescriptor<PreparedVerifyingKey>;
    }
    interface PreparedVerifyingKeyInstance extends TypedEventInstance<PreparedVerifyingKey> {
        data_decoded: PreparedVerifyingKey;
        type_arguments: [];
    }
    interface ProofPoints {
        bytes: number[];
    }
    namespace ProofPoints {
        const TYPE_QNAME = "0x2::groth16::ProofPoints";
        function type(): TypeDescriptor<ProofPoints>;
    }
    interface ProofPointsInstance extends TypedEventInstance<ProofPoints> {
        data_decoded: ProofPoints;
        type_arguments: [];
    }
    interface PublicProofInputs {
        bytes: number[];
    }
    namespace PublicProofInputs {
        const TYPE_QNAME = "0x2::groth16::PublicProofInputs";
        function type(): TypeDescriptor<PublicProofInputs>;
    }
    interface PublicProofInputsInstance extends TypedEventInstance<PublicProofInputs> {
        data_decoded: PublicProofInputs;
        type_arguments: [];
    }
}
export declare class group_ops extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): group_ops;
    onEventElement(func: (event: group_ops.ElementInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): group_ops;
}
export declare namespace group_ops {
    interface Element<T0> {
        bytes: number[];
    }
    namespace Element {
        const TYPE_QNAME = "0x2::group_ops::Element";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Element<T0>>;
    }
    interface ElementInstance extends TypedEventInstance<Element<any>> {
        data_decoded: Element<any>;
        type_arguments: [string];
    }
}
export declare namespace hash { }
export declare namespace hex { }
export declare namespace hmac { }
export declare class kiosk extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): kiosk;
    onEntryDefault(func: (call: kiosk.DefaultPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): kiosk;
    onEventItem(func: (event: kiosk.ItemInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): kiosk;
    onEventItemDelisted(func: (event: kiosk.ItemDelistedInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): kiosk;
    onEventItemListed(func: (event: kiosk.ItemListedInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): kiosk;
    onEventItemPurchased(func: (event: kiosk.ItemPurchasedInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): kiosk;
    onEventListing(func: (event: kiosk.ListingInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): kiosk;
    onEventLock(func: (event: kiosk.LockInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): kiosk;
}
export declare namespace kiosk {
    interface Borrow {
        kiosk_id: object_.ID;
        item_id: object_.ID;
    }
    namespace Borrow {
        const TYPE_QNAME = "0x2::kiosk::Borrow";
        function type(): TypeDescriptor<Borrow>;
    }
    interface Item {
        id: object_.ID;
    }
    namespace Item {
        const TYPE_QNAME = "0x2::kiosk::Item";
        function type(): TypeDescriptor<Item>;
    }
    interface ItemInstance extends TypedEventInstance<Item> {
        data_decoded: Item;
        type_arguments: [];
    }
    interface ItemDelisted<T0> {
        kiosk: object_.ID;
        id: object_.ID;
    }
    namespace ItemDelisted {
        const TYPE_QNAME = "0x2::kiosk::ItemDelisted";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<ItemDelisted<T0>>;
    }
    interface ItemDelistedInstance extends TypedEventInstance<ItemDelisted<any>> {
        data_decoded: ItemDelisted<any>;
        type_arguments: [string];
    }
    interface ItemListed<T0> {
        kiosk: object_.ID;
        id: object_.ID;
        price: bigint;
    }
    namespace ItemListed {
        const TYPE_QNAME = "0x2::kiosk::ItemListed";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<ItemListed<T0>>;
    }
    interface ItemListedInstance extends TypedEventInstance<ItemListed<any>> {
        data_decoded: ItemListed<any>;
        type_arguments: [string];
    }
    interface ItemPurchased<T0> {
        kiosk: object_.ID;
        id: object_.ID;
        price: bigint;
    }
    namespace ItemPurchased {
        const TYPE_QNAME = "0x2::kiosk::ItemPurchased";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<ItemPurchased<T0>>;
    }
    interface ItemPurchasedInstance extends TypedEventInstance<ItemPurchased<any>> {
        data_decoded: ItemPurchased<any>;
        type_arguments: [string];
    }
    interface Kiosk {
        id: object_.UID;
        profits: balance.Balance<sui.SUI>;
        owner: string;
        item_count: number;
        allow_extensions: Boolean;
    }
    namespace Kiosk {
        const TYPE_QNAME = "0x2::kiosk::Kiosk";
        function type(): TypeDescriptor<Kiosk>;
    }
    interface KioskOwnerCap {
        id: object_.UID;
        for: object_.ID;
    }
    namespace KioskOwnerCap {
        const TYPE_QNAME = "0x2::kiosk::KioskOwnerCap";
        function type(): TypeDescriptor<KioskOwnerCap>;
    }
    interface Listing {
        id: object_.ID;
        is_exclusive: Boolean;
    }
    namespace Listing {
        const TYPE_QNAME = "0x2::kiosk::Listing";
        function type(): TypeDescriptor<Listing>;
    }
    interface ListingInstance extends TypedEventInstance<Listing> {
        data_decoded: Listing;
        type_arguments: [];
    }
    interface Lock {
        id: object_.ID;
    }
    namespace Lock {
        const TYPE_QNAME = "0x2::kiosk::Lock";
        function type(): TypeDescriptor<Lock>;
    }
    interface LockInstance extends TypedEventInstance<Lock> {
        data_decoded: Lock;
        type_arguments: [];
    }
    interface PurchaseCap<T0> {
        id: object_.UID;
        kiosk_id: object_.ID;
        item_id: object_.ID;
        min_price: bigint;
    }
    namespace PurchaseCap {
        const TYPE_QNAME = "0x2::kiosk::PurchaseCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<PurchaseCap<T0>>;
    }
    interface DefaultPayload extends TypedFunctionPayload<[string]> {
        arguments_decoded: [string];
        type_arguments: [];
    }
}
export declare class kiosk_extension extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): kiosk_extension;
    onEventExtensionKey(func: (event: kiosk_extension.ExtensionKeyInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): kiosk_extension;
}
export declare namespace kiosk_extension {
    interface Extension {
        storage: bag.Bag;
        permissions: bigint;
        is_enabled: Boolean;
    }
    namespace Extension {
        const TYPE_QNAME = "0x2::kiosk_extension::Extension";
        function type(): TypeDescriptor<Extension>;
    }
    interface ExtensionKey<T0> {
        dummy_field: Boolean;
    }
    namespace ExtensionKey {
        const TYPE_QNAME = "0x2::kiosk_extension::ExtensionKey";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<ExtensionKey<T0>>;
    }
    interface ExtensionKeyInstance extends TypedEventInstance<ExtensionKey<any>> {
        data_decoded: ExtensionKey<any>;
        type_arguments: [string];
    }
}
export declare namespace linked_table {
    interface LinkedTable<T0, T1> {
        id: object_.UID;
        size: bigint;
        head: _0x1.option.Option<T0>;
        tail: _0x1.option.Option<T0>;
    }
    namespace LinkedTable {
        const TYPE_QNAME = "0x2::linked_table::LinkedTable";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<LinkedTable<T0, T1>>;
    }
    interface Node<T0, T1> {
        prev: _0x1.option.Option<T0>;
        next: _0x1.option.Option<T0>;
        value: T1;
    }
    namespace Node {
        const TYPE_QNAME = "0x2::linked_table::Node";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Node<T0, T1>>;
    }
}
export declare namespace math { }
export declare namespace object_ {
    type ID = string;
    namespace ID {
        const TYPE_QNAME = "0x2::object::ID";
        function type(): TypeDescriptor<ID>;
    }
    interface UID {
        id: object_.ID;
    }
    namespace UID {
        const TYPE_QNAME = "0x2::object::UID";
        function type(): TypeDescriptor<UID>;
    }
}
export declare namespace object_bag {
    interface ObjectBag {
        id: object_.UID;
        size: bigint;
    }
    namespace ObjectBag {
        const TYPE_QNAME = "0x2::object_bag::ObjectBag";
        function type(): TypeDescriptor<ObjectBag>;
    }
}
export declare namespace object_table {
    interface ObjectTable<T0, T1> {
        id: object_.UID;
        size: bigint;
    }
    namespace ObjectTable {
        const TYPE_QNAME = "0x2::object_table::ObjectTable";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<ObjectTable<T0, T1>>;
    }
}
export declare class package_ extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): package_;
    onEntryMakeImmutable(func: (call: package_.MakeImmutablePayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): package_;
    onEntryOnlyAdditiveUpgrades(func: (call: package_.OnlyAdditiveUpgradesPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): package_;
    onEntryOnlyDepUpgrades(func: (call: package_.OnlyDepUpgradesPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): package_;
}
export declare namespace package_ {
    interface Publisher {
        id: object_.UID;
        package: _0x1.ascii.String;
        module_name: _0x1.ascii.String;
    }
    namespace Publisher {
        const TYPE_QNAME = "0x2::package::Publisher";
        function type(): TypeDescriptor<Publisher>;
    }
    interface UpgradeCap {
        id: object_.UID;
        package: object_.ID;
        version: bigint;
        policy: number;
    }
    namespace UpgradeCap {
        const TYPE_QNAME = "0x2::package::UpgradeCap";
        function type(): TypeDescriptor<UpgradeCap>;
    }
    interface UpgradeReceipt {
        cap: object_.ID;
        package: object_.ID;
    }
    namespace UpgradeReceipt {
        const TYPE_QNAME = "0x2::package::UpgradeReceipt";
        function type(): TypeDescriptor<UpgradeReceipt>;
    }
    interface UpgradeTicket {
        cap: object_.ID;
        package: object_.ID;
        policy: number;
        digest: number[];
    }
    namespace UpgradeTicket {
        const TYPE_QNAME = "0x2::package::UpgradeTicket";
        function type(): TypeDescriptor<UpgradeTicket>;
    }
    interface MakeImmutablePayload extends TypedFunctionPayload<[package_.UpgradeCap]> {
        arguments_decoded: [package_.UpgradeCap];
        type_arguments: [];
    }
    interface OnlyAdditiveUpgradesPayload extends TypedFunctionPayload<[string]> {
        arguments_decoded: [string];
        type_arguments: [];
    }
    interface OnlyDepUpgradesPayload extends TypedFunctionPayload<[string]> {
        arguments_decoded: [string];
        type_arguments: [];
    }
}
export declare class pay extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): pay;
    onEntryDivideAndKeep(func: (call: pay.DivideAndKeepPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): pay;
    onEntryJoin(func: (call: pay.JoinPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): pay;
    onEntryJoinVec(func: (call: pay.JoinVecPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): pay;
    onEntryJoinVecAndTransfer(func: (call: pay.JoinVecAndTransferPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): pay;
    onEntrySplit(func: (call: pay.SplitPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): pay;
    onEntrySplitAndTransfer(func: (call: pay.SplitAndTransferPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): pay;
    onEntrySplitVec(func: (call: pay.SplitVecPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): pay;
}
export declare namespace pay {
    interface DivideAndKeepPayload<T0 = any> extends TypedFunctionPayload<[string, bigint, string]> {
        arguments_decoded: [string, bigint, string];
        type_arguments: [string];
    }
    interface JoinPayload<T0 = any> extends TypedFunctionPayload<[string, coin.Coin<T0>]> {
        arguments_decoded: [string, coin.Coin<T0>];
        type_arguments: [string];
    }
    interface JoinVecPayload<T0 = any> extends TypedFunctionPayload<[string, coin.Coin<T0>[]]> {
        arguments_decoded: [string, coin.Coin<T0>[]];
        type_arguments: [string];
    }
    interface JoinVecAndTransferPayload<T0 = any> extends TypedFunctionPayload<[coin.Coin<T0>[], string]> {
        arguments_decoded: [coin.Coin<T0>[], string];
        type_arguments: [string];
    }
    interface SplitPayload<T0 = any> extends TypedFunctionPayload<[string, bigint, string]> {
        arguments_decoded: [string, bigint, string];
        type_arguments: [string];
    }
    interface SplitAndTransferPayload<T0 = any> extends TypedFunctionPayload<[string, bigint, string, string]> {
        arguments_decoded: [string, bigint, string, string];
        type_arguments: [string];
    }
    interface SplitVecPayload<T0 = any> extends TypedFunctionPayload<[string, bigint[], string]> {
        arguments_decoded: [string, bigint[], string];
        type_arguments: [string];
    }
}
export declare namespace poseidon { }
export declare namespace priority_queue {
    interface Entry<T0> {
        priority: bigint;
        value: T0;
    }
    namespace Entry {
        const TYPE_QNAME = "0x2::priority_queue::Entry";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Entry<T0>>;
    }
    interface PriorityQueue<T0> {
        entries: priority_queue.Entry<T0>[];
    }
    namespace PriorityQueue {
        const TYPE_QNAME = "0x2::priority_queue::PriorityQueue";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<PriorityQueue<T0>>;
    }
}
export declare namespace prover { }
export declare namespace random {
    interface Random {
        id: object_.UID;
        inner: versioned.Versioned;
    }
    namespace Random {
        const TYPE_QNAME = "0x2::random::Random";
        function type(): TypeDescriptor<Random>;
    }
    interface RandomGenerator {
        seed: number[];
        counter: number;
        buffer: number[];
    }
    namespace RandomGenerator {
        const TYPE_QNAME = "0x2::random::RandomGenerator";
        function type(): TypeDescriptor<RandomGenerator>;
    }
    interface RandomInner {
        version: bigint;
        epoch: bigint;
        randomness_round: bigint;
        random_bytes: number[];
    }
    namespace RandomInner {
        const TYPE_QNAME = "0x2::random::RandomInner";
        function type(): TypeDescriptor<RandomInner>;
    }
}
export declare class sui extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): sui;
    onEntryTransfer(func: (call: sui.TransferPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): sui;
}
export declare namespace sui {
    interface SUI {
        dummy_field: Boolean;
    }
    namespace SUI {
        const TYPE_QNAME = "0x2::sui::SUI";
        function type(): TypeDescriptor<SUI>;
    }
    interface TransferPayload extends TypedFunctionPayload<[coin.Coin<sui.SUI>, string]> {
        arguments_decoded: [coin.Coin<sui.SUI>, string];
        type_arguments: [];
    }
}
export declare namespace table {
    interface Table<T0, T1> {
        id: object_.UID;
        size: bigint;
    }
    namespace Table {
        const TYPE_QNAME = "0x2::table::Table";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Table<T0, T1>>;
    }
}
export declare namespace table_vec {
    interface TableVec<T0> {
        contents: table.Table<bigint, T0>;
    }
    namespace TableVec {
        const TYPE_QNAME = "0x2::table_vec::TableVec";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TableVec<T0>>;
    }
}
export declare class token extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): token;
    onEventRuleKey(func: (event: token.RuleKeyInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): token;
    onEventTokenPolicyCreated(func: (event: token.TokenPolicyCreatedInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): token;
}
export declare namespace token {
    interface ActionRequest<T0> {
        name: string;
        amount: bigint;
        sender: string;
        recipient: _0x1.option.Option<string>;
        spent_balance: _0x1.option.Option<balance.Balance<T0>>;
        approvals: vec_set.VecSet<_0x1.type_name.TypeName>;
    }
    namespace ActionRequest {
        const TYPE_QNAME = "0x2::token::ActionRequest";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<ActionRequest<T0>>;
    }
    interface RuleKey<T0> {
        is_protected: Boolean;
    }
    namespace RuleKey {
        const TYPE_QNAME = "0x2::token::RuleKey";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<RuleKey<T0>>;
    }
    interface RuleKeyInstance extends TypedEventInstance<RuleKey<any>> {
        data_decoded: RuleKey<any>;
        type_arguments: [string];
    }
    interface Token<T0> {
        id: object_.UID;
        balance: balance.Balance<T0>;
    }
    namespace Token {
        const TYPE_QNAME = "0x2::token::Token";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Token<T0>>;
    }
    interface TokenPolicy<T0> {
        id: object_.UID;
        spent_balance: balance.Balance<T0>;
        rules: vec_map.VecMap<string, vec_set.VecSet<_0x1.type_name.TypeName>>;
    }
    namespace TokenPolicy {
        const TYPE_QNAME = "0x2::token::TokenPolicy";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TokenPolicy<T0>>;
    }
    interface TokenPolicyCap<T0> {
        id: object_.UID;
        for: object_.ID;
    }
    namespace TokenPolicyCap {
        const TYPE_QNAME = "0x2::token::TokenPolicyCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TokenPolicyCap<T0>>;
    }
    interface TokenPolicyCreated<T0> {
        id: object_.ID;
        is_mutable: Boolean;
    }
    namespace TokenPolicyCreated {
        const TYPE_QNAME = "0x2::token::TokenPolicyCreated";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TokenPolicyCreated<T0>>;
    }
    interface TokenPolicyCreatedInstance extends TypedEventInstance<TokenPolicyCreated<any>> {
        data_decoded: TokenPolicyCreated<any>;
        type_arguments: [string];
    }
}
export declare namespace transfer {
    interface Receiving<T0> {
        id: object_.ID;
        version: bigint;
    }
    namespace Receiving {
        const TYPE_QNAME = "0x2::transfer::Receiving";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Receiving<T0>>;
    }
}
export declare class transfer_policy extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): transfer_policy;
    onEntryDefault(func: (call: transfer_policy.DefaultPayload, ctx: SuiContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): transfer_policy;
    onEventRuleKey(func: (event: transfer_policy.RuleKeyInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): transfer_policy;
    onEventTransferPolicyCreated(func: (event: transfer_policy.TransferPolicyCreatedInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): transfer_policy;
    onEventTransferPolicyDestroyed(func: (event: transfer_policy.TransferPolicyDestroyedInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): transfer_policy;
}
export declare namespace transfer_policy {
    interface RuleKey<T0> {
        dummy_field: Boolean;
    }
    namespace RuleKey {
        const TYPE_QNAME = "0x2::transfer_policy::RuleKey";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<RuleKey<T0>>;
    }
    interface RuleKeyInstance extends TypedEventInstance<RuleKey<any>> {
        data_decoded: RuleKey<any>;
        type_arguments: [string];
    }
    interface TransferPolicy<T0> {
        id: object_.UID;
        balance: balance.Balance<sui.SUI>;
        rules: vec_set.VecSet<_0x1.type_name.TypeName>;
    }
    namespace TransferPolicy {
        const TYPE_QNAME = "0x2::transfer_policy::TransferPolicy";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TransferPolicy<T0>>;
    }
    interface TransferPolicyCap<T0> {
        id: object_.UID;
        policy_id: object_.ID;
    }
    namespace TransferPolicyCap {
        const TYPE_QNAME = "0x2::transfer_policy::TransferPolicyCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TransferPolicyCap<T0>>;
    }
    interface TransferPolicyCreated<T0> {
        id: object_.ID;
    }
    namespace TransferPolicyCreated {
        const TYPE_QNAME = "0x2::transfer_policy::TransferPolicyCreated";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TransferPolicyCreated<T0>>;
    }
    interface TransferPolicyCreatedInstance extends TypedEventInstance<TransferPolicyCreated<any>> {
        data_decoded: TransferPolicyCreated<any>;
        type_arguments: [string];
    }
    interface TransferPolicyDestroyed<T0> {
        id: object_.ID;
    }
    namespace TransferPolicyDestroyed {
        const TYPE_QNAME = "0x2::transfer_policy::TransferPolicyDestroyed";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TransferPolicyDestroyed<T0>>;
    }
    interface TransferPolicyDestroyedInstance extends TypedEventInstance<TransferPolicyDestroyed<any>> {
        data_decoded: TransferPolicyDestroyed<any>;
        type_arguments: [string];
    }
    interface TransferRequest<T0> {
        item: object_.ID;
        paid: bigint;
        from: object_.ID;
        receipts: vec_set.VecSet<_0x1.type_name.TypeName>;
    }
    namespace TransferRequest {
        const TYPE_QNAME = "0x2::transfer_policy::TransferRequest";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<TransferRequest<T0>>;
    }
    interface DefaultPayload<T0 = any> extends TypedFunctionPayload<[string, string]> {
        arguments_decoded: [string, string];
        type_arguments: [string];
    }
}
export declare namespace tx_context {
    interface TxContext {
        sender: string;
        tx_hash: number[];
        epoch: bigint;
        epoch_timestamp_ms: bigint;
        ids_created: bigint;
    }
    namespace TxContext {
        const TYPE_QNAME = "0x2::tx_context::TxContext";
        function type(): TypeDescriptor<TxContext>;
    }
}
export declare namespace types { }
export declare class url extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): url;
    onEventUrl(func: (event: url.UrlInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): url;
}
export declare namespace url {
    interface Url {
        url: _0x1.ascii.String;
    }
    namespace Url {
        const TYPE_QNAME = "0x2::url::Url";
        function type(): TypeDescriptor<Url>;
    }
    interface UrlInstance extends TypedEventInstance<Url> {
        data_decoded: Url;
        type_arguments: [];
    }
}
export declare namespace vdf { }
export declare class vec_map extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): vec_map;
    onEventEntry(func: (event: vec_map.EntryInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vec_map;
    onEventVecMap(func: (event: vec_map.VecMapInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vec_map;
}
export declare namespace vec_map {
    interface Entry<T0, T1> {
        key: T0;
        value: T1;
    }
    namespace Entry {
        const TYPE_QNAME = "0x2::vec_map::Entry";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Entry<T0, T1>>;
    }
    interface EntryInstance extends TypedEventInstance<Entry<any, any>> {
        data_decoded: Entry<any, any>;
        type_arguments: [string, string];
    }
    interface VecMap<T0, T1> {
        contents: vec_map.Entry<T0, T1>[];
    }
    namespace VecMap {
        const TYPE_QNAME = "0x2::vec_map::VecMap";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<VecMap<T0, T1>>;
    }
    interface VecMapInstance extends TypedEventInstance<VecMap<any, any>> {
        data_decoded: VecMap<any, any>;
        type_arguments: [string, string];
    }
}
export declare class vec_set extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): vec_set;
    onEventVecSet(func: (event: vec_set.VecSetInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vec_set;
}
export declare namespace vec_set {
    interface VecSet<T0> {
        contents: T0[] | string;
    }
    namespace VecSet {
        const TYPE_QNAME = "0x2::vec_set::VecSet";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<VecSet<T0>>;
    }
    interface VecSetInstance extends TypedEventInstance<VecSet<any>> {
        data_decoded: VecSet<any>;
        type_arguments: [string];
    }
}
export declare namespace versioned {
    interface VersionChangeCap {
        versioned_id: object_.ID;
        old_version: bigint;
    }
    namespace VersionChangeCap {
        const TYPE_QNAME = "0x2::versioned::VersionChangeCap";
        function type(): TypeDescriptor<VersionChangeCap>;
    }
    interface Versioned {
        id: object_.UID;
        version: bigint;
    }
    namespace Versioned {
        const TYPE_QNAME = "0x2::versioned::Versioned";
        function type(): TypeDescriptor<Versioned>;
    }
}
export declare namespace zklogin_verified_id {
    interface VerifiedID {
        id: object_.UID;
        owner: string;
        key_claim_name: string;
        key_claim_value: string;
        issuer: string;
        audience: string;
    }
    namespace VerifiedID {
        const TYPE_QNAME = "0x2::zklogin_verified_id::VerifiedID";
        function type(): TypeDescriptor<VerifiedID>;
    }
}
export declare namespace zklogin_verified_issuer {
    interface VerifiedIssuer {
        id: object_.UID;
        owner: string;
        issuer: string;
    }
    namespace VerifiedIssuer {
        const TYPE_QNAME = "0x2::zklogin_verified_issuer::VerifiedIssuer";
        function type(): TypeDescriptor<VerifiedIssuer>;
    }
}
export declare function loadAllTypes(coder: MoveCoder): void;
//# sourceMappingURL=0x2.d.ts.map