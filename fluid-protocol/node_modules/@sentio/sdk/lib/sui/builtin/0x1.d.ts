import { TypeDescriptor } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/sui";
import { MoveFetchConfig } from "@sentio/sdk/move";
import { SuiBindOptions, SuiBaseProcessor, SuiContext } from "@sentio/sdk/sui";
export declare namespace address { }
export declare namespace ascii {
    type Char = string;
    namespace Char {
        const TYPE_QNAME = "0x1::ascii::Char";
        function type(): TypeDescriptor<Char>;
    }
    type String = string;
    namespace String {
        const TYPE_QNAME = "0x1::ascii::String";
        function type(): TypeDescriptor<String>;
    }
}
export declare namespace bcs { }
export declare class bit_vector extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): bit_vector;
    onEventBitVector(func: (event: bit_vector.BitVectorInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): bit_vector;
}
export declare namespace bit_vector {
    interface BitVector {
        length: bigint;
        bit_field: Boolean[];
    }
    namespace BitVector {
        const TYPE_QNAME = "0x1::bit_vector::BitVector";
        function type(): TypeDescriptor<BitVector>;
    }
    interface BitVectorInstance extends TypedEventInstance<BitVector> {
        data_decoded: BitVector;
        type_arguments: [];
    }
}
export declare namespace debug { }
export declare class fixed_point32 extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): fixed_point32;
    onEventFixedPoint32(func: (event: fixed_point32.FixedPoint32Instance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fixed_point32;
}
export declare namespace fixed_point32 {
    interface FixedPoint32 {
        value: bigint;
    }
    namespace FixedPoint32 {
        const TYPE_QNAME = "0x1::fixed_point32::FixedPoint32";
        function type(): TypeDescriptor<FixedPoint32>;
    }
    interface FixedPoint32Instance extends TypedEventInstance<FixedPoint32> {
        data_decoded: FixedPoint32;
        type_arguments: [];
    }
}
export declare namespace hash { }
export declare namespace macros { }
export declare namespace option {
    type Option<T> = T | undefined;
    namespace Option {
        const TYPE_QNAME = "0x1::option::Option";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Option<T0>>;
    }
}
export declare class string_ extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): string_;
    onEventString(func: (event: string_.StringInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): string_;
}
export declare namespace string_ {
    interface String {
        bytes: number[];
    }
    namespace String {
        const TYPE_QNAME = "0x1::string::String";
        function type(): TypeDescriptor<String>;
    }
    interface StringInstance extends TypedEventInstance<String> {
        data_decoded: String;
        type_arguments: [];
    }
}
export declare class type_name extends SuiBaseProcessor {
    constructor(options: SuiBindOptions);
    static DEFAULT_OPTIONS: SuiBindOptions;
    static bind(options?: Partial<SuiBindOptions>): type_name;
    onEventTypeName(func: (event: type_name.TypeNameInstance, ctx: SuiContext) => void, fetchConfig?: Partial<MoveFetchConfig>): type_name;
}
export declare namespace type_name {
    interface TypeName {
        name: ascii.String;
    }
    namespace TypeName {
        const TYPE_QNAME = "0x1::type_name::TypeName";
        function type(): TypeDescriptor<TypeName>;
    }
    interface TypeNameInstance extends TypedEventInstance<TypeName> {
        data_decoded: TypeName;
        type_arguments: [];
    }
}
export declare namespace u128 { }
export declare namespace u16 { }
export declare namespace u256 { }
export declare namespace u32 { }
export declare namespace u64 { }
export declare namespace u8 { }
export declare namespace vector { }
export declare function loadAllTypes(coder: MoveCoder): void;
//# sourceMappingURL=0x1.d.ts.map