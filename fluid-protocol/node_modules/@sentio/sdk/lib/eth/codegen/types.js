export function getFullSignatureAsSymbolForFunction(fn) {
    return `${fn.name}_${fn.inputs
        .map((e) => {
        if (e.type.type === 'array') {
            return e.type.itemType.originalType + '_array';
        }
        else {
            return e.type.originalType;
        }
    })
        .join('_')}`;
}
function formatType(type) {
    if (type.type === 'array') {
        return formatType(type.itemType) + `[${type.size || ''}]`;
    }
    else if (type.type === 'tuple') {
        return '(' + type.components.map((s) => formatType(s.type)).join(',') + ')';
    }
    else {
        return type.originalType;
    }
}
// TODO contribute upstream
export function getFullSignatureForEventPatched(event) {
    return `${event.name}(${event.inputs
        .map((e) => {
        return formatType(e.type);
    })
        .join(',')})`;
}
// TODO check existed func
export function getFullSignatureForFunction(fn) {
    return `${fn.name}(${fn.inputs
        .map((e) => {
        return formatType(e.type);
    })
        .join(',')})`;
}
export function getFullSignatureWithOutputForFn(fn) {
    return `${fn.name}(${fn.inputs.map((i) => getArgumentForSignature(i)).join(', ')}) ${fn.stateMutability != 'nonpayable' ? fn.stateMutability + ' ' : ''}returns (${fn.outputs
        .map((i) => getOutputArgumentForSignature(i))
        .filter((s) => s != '')
        .join(', ')})`;
}
function getOutputArgumentForSignature(argument) {
    if (argument.type.type == 'void') {
        return '';
    }
    return getArgumentForSignature(argument);
}
function getArgumentForSignature(argument) {
    if (argument.type.originalType === 'tuple') {
        return getTypeWithName(`(${argument.type.components.map((i) => getArgumentForSignature(i)).join(', ')})`, argument.name);
    }
    else if (argument.type.originalType.startsWith('tuple')) {
        const arr = argument.type;
        return getTypeWithName(`${getArgumentForSignature({
            name: '',
            type: arr.itemType
        })}[${arr.size?.toString() || ''}]`, argument.name);
    }
    else {
        return getTypeWithName(argument.type.originalType, argument.name);
    }
}
function getTypeWithName(type, name) {
    return (name ?? '').length > 0 ? `${type} ${name}` : type;
}
//# sourceMappingURL=types.js.map