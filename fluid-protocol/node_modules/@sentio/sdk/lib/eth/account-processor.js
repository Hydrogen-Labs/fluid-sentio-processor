import { ERC20__factory, ERC721__factory } from './builtin/internal/index.js';
import { AddressType, EthFetchConfig, PreprocessResult, ProcessResult } from '@sentio/protos';
import { ERC20Processor } from './builtin/erc20.js';
import { ERC721Processor } from './builtin/erc721.js';
import { AccountContext } from './context.js';
import { defaultPreprocessHandler } from './base-processor.js';
import { AccountProcessorState } from './account-processor-state.js';
import { fixEmptyKey, formatEthData } from './eth.js';
import { EthChainId } from '@sentio/chain';
import { ServerError, Status } from 'nice-grpc';
const ERC20_INTERFACE = ERC20__factory.createInterface();
const ERC721_INTERFACE = ERC721__factory.createInterface();
export class AccountProcessor {
    config;
    eventHandlers = [];
    static bind(config) {
        const processor = new AccountProcessor(config);
        AccountProcessorState.INSTANCE.addValue(processor);
        return processor;
    }
    constructor(config) {
        this.config = {
            ...config,
            network: config.network || EthChainId.ETHEREUM
        };
    }
    getChainId() {
        return this.config.network;
    }
    /**
     * Register custom handler function to process erc20 transfer event to this account
     * @param handler custom handler function
     * @param tokensAddresses all the erc20 token address to watch
     * @param fetchConfig
     * @param preprocessHandler
     */
    onERC20TransferIn(handler, tokensAddresses = [], fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onERC20(handler, tokensAddresses, (address) => ERC721Processor.filters.Transfer(null, this.config.address), fetchConfig, preprocessHandler);
    }
    /**
     * Register custom handler function to process erc20 transfer event from this account
     * @param handler custom handler function
     * @param tokensAddresses all the erc20 token address to watch
     * @param fetchConfig
     * @param preprocessHandler
     */
    onERC20TransferOut(handler, tokensAddresses = [], fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onERC20(handler, tokensAddresses, (address) => ERC20Processor.filters.Transfer(this.config.address), fetchConfig, preprocessHandler);
    }
    /**
     * Register custom handler function to process erc20 mint for this account
     * @param handler custom handler function
     * @param tokensAddresses all the erc20 token address to watch
     * @param fetchConfig
     * @param preprocessHandler
     */
    onERC20Minted(handler, tokensAddresses = [], fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onERC20(handler, tokensAddresses, (address) => ERC20Processor.filters.Transfer('0x0000000000000000000000000000000000000000', this.config.address), fetchConfig, preprocessHandler);
    }
    onERC20(handler, tokensAddresses = [], defaultFilter, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onERC(handler, tokensAddresses, defaultFilter, AddressType.ERC20, fetchConfig, preprocessHandler);
    }
    /**
     * Register custom handler function to process ERC721 transfer event to this account
     * @param handler custom handler function
     * @param collections all the ERC721 token address to watch, if not provided then watch all ERC721
     * @param fetchConfig
     * @param preprocessHandler
     */
    onERC721TransferIn(handler, collections, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onERC721(handler, collections, (address) => ERC721Processor.filters.Transfer(null, this.config.address), fetchConfig, preprocessHandler);
    }
    /**
     * Register custom handler function to process ERC721 transfer event from this account
     * @param handler custom handler function
     * @param collections all the ERC721 token address to watch, if not provided then watch all ERC721
     * @param fetchConfig
     * @param preprocessHandler
     */
    onERC721TransferOut(handler, collections, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onERC721(handler, collections, (address) => ERC721Processor.filters.Transfer(this.config.address), fetchConfig, preprocessHandler);
    }
    /**
     * Register custom handler function to process ERC721 mint for this account
     * @param handler custom handler function
     * @param collections all the ERC721 token address to watch, if not provided then watch all ERC721
     * @param fetchConfig
     * @param preprocessHandler
     */
    onERC721Minted(handler, collections = [], fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onERC721(handler, collections, (address) => ERC721Processor.filters.Transfer('0x0000000000000000000000000000000000000000', this.config.address), fetchConfig, preprocessHandler);
    }
    onERC721(handler, collections, defaultFilter, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onERC(handler, collections, defaultFilter, AddressType.ERC721, fetchConfig, preprocessHandler);
    }
    onERC(handler, contractAddresses, defaultFilter, addressType, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        const filters = [];
        for (const token of contractAddresses) {
            const filter = defaultFilter(this.config.address);
            filter.address = token;
            filters.push(filter);
        }
        if (!filters.length) {
            const filter = defaultFilter(this.config.address);
            filter.address = undefined;
            filter.addressType = addressType;
            filters.push(filter);
        }
        return this.onEvent(handler, filters, fetchConfig, preprocessHandler);
    }
    onEvent(handler, filter, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        const chainId = this.getChainId();
        let _filters = [];
        if (Array.isArray(filter)) {
            _filters = filter;
        }
        else {
            _filters.push(filter);
        }
        // let hasVaildConfig = false
        // for (const filter of _filters) {
        //   if (filter.address) {
        //     hasVaildConfig = true
        //     break
        //   }
        //   if (filter.topics && filter.topics.length) {
        //     hasVaildConfig = true
        //     break
        //   }
        // }
        //
        // if (!hasVaildConfig) {
        //   throw Error('no valid config has been found for this account')
        // }
        const config = this.config;
        this.eventHandlers.push({
            filters: _filters,
            fetchConfig: EthFetchConfig.fromPartial(fetchConfig || {}),
            handler: async function (data) {
                const { log, block, transaction, transactionReceipt } = formatEthData(data);
                if (!log) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Log is empty');
                }
                // const log = data.log as { topics: Array<string>; data: string }
                const ctx = new AccountContext(chainId, config.address, data.timestamp, data.block, log, undefined, transaction, transactionReceipt);
                const logParam = log;
                const parsed = ERC20_INTERFACE.parseLog(logParam);
                if (parsed) {
                    const event = { ...log, name: parsed.name, args: fixEmptyKey(parsed) };
                    await handler(event, ctx);
                    return ctx.stopAndGetResult();
                }
                return ProcessResult.fromPartial({});
            },
            preprocessHandler: async function (data, preprocessStore) {
                const { log, block, transaction, transactionReceipt } = formatEthData(data);
                if (!log) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Log is empty');
                }
                // const log = data.log as { topics: Array<string>; data: string }
                const ctx = new AccountContext(chainId, config.address, data.timestamp, data.block, log, undefined, transaction, transactionReceipt);
                const logParam = log;
                const parsed = ERC20_INTERFACE.parseLog(logParam);
                if (parsed) {
                    const event = { ...log, name: parsed.name, args: fixEmptyKey(parsed) };
                    return preprocessHandler(event, ctx, preprocessStore);
                }
                return PreprocessResult.fromPartial({});
            }
        });
        return this;
    }
}
//# sourceMappingURL=account-processor.js.map