import { ContractContext, GlobalContext } from './context.js';
import { EthFetchConfig, PreprocessResult, ProcessResult } from '@sentio/protos';
import { ServerError, Status } from 'nice-grpc';
import { fixEmptyKey, formatEthData } from './eth.js';
import sha3 from 'js-sha3';
import { ListStateStorage } from '@sentio/runtime';
import { EthChainId } from '@sentio/chain';
export const defaultPreprocessHandler = () => ({ ethCallParams: [] });
export class EventsHandler {
    filters;
    handler;
    preprocessHandler;
    fetchConfig;
}
export class TraceHandler {
    signatures;
    handler;
    preprocessHandler;
    fetchConfig;
}
export class BlockHandler {
    blockInterval;
    timeIntervalInMinutes;
    handler;
    preprocessHandler;
    fetchConfig;
}
export class TransactionHandler {
    handler;
    preprocessHandler;
    fetchConfig;
}
class BindInternalOptions {
    address;
    network;
    name;
    startBlock;
    endBlock;
    baseLabels;
}
export class GlobalProcessorState extends ListStateStorage {
    static INSTANCE = new GlobalProcessorState();
}
export class GlobalProcessor {
    config;
    blockHandlers = [];
    transactionHandler = [];
    traceHandlers = [];
    static bind(config) {
        const processor = new GlobalProcessor(config);
        GlobalProcessorState.INSTANCE.addValue(processor);
        return processor;
    }
    constructor(config) {
        this.config = {
            address: '*',
            name: config.name || 'Global',
            network: config.network || EthChainId.ETHEREUM,
            startBlock: 0n
        };
        if (config.startBlock) {
            this.config.startBlock = BigInt(config.startBlock);
        }
        if (config.endBlock) {
            this.config.endBlock = BigInt(config.endBlock);
        }
    }
    onBlockInterval(handler, blockInterval = 250, backfillBlockInterval = 1000, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onInterval(handler, undefined, {
            recentInterval: blockInterval,
            backfillInterval: backfillBlockInterval
        }, fetchConfig, preprocessHandler);
    }
    onTimeInterval(handler, timeIntervalInMinutes = 60, backfillTimeIntervalInMinutes = 240, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onInterval(handler, { recentInterval: timeIntervalInMinutes, backfillInterval: backfillTimeIntervalInMinutes }, undefined, fetchConfig, preprocessHandler);
    }
    getChainId() {
        return this.config.network;
    }
    onInterval(handler, timeInterval, blockInterval, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        const chainId = this.getChainId();
        if (timeInterval) {
            if (timeInterval.backfillInterval < timeInterval.recentInterval) {
                timeInterval.backfillInterval = timeInterval.recentInterval;
            }
        }
        const processor = this;
        this.blockHandlers.push({
            handler: async function (data) {
                const { block } = formatEthData(data);
                if (!block) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Block is empty');
                }
                const ctx = new GlobalContext(chainId, '*', new Date(block.timestamp * 1000), block, undefined, undefined, undefined, undefined, processor.config.baseLabels);
                await handler(block, ctx);
                return ctx.stopAndGetResult();
            },
            preprocessHandler: async function (data, preprocessStore) {
                const { block } = formatEthData(data);
                if (!block) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Block is empty');
                }
                const ctx = new GlobalContext(chainId, '*', new Date(block.timestamp * 1000), block, undefined, undefined, undefined, undefined, processor.config.baseLabels);
                return preprocessHandler(block, ctx, preprocessStore);
            },
            timeIntervalInMinutes: timeInterval,
            blockInterval: blockInterval,
            fetchConfig: EthFetchConfig.fromPartial(fetchConfig || {})
        });
        return this;
    }
    onTransaction(handler, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        const chainId = this.getChainId();
        const processor = this;
        this.transactionHandler.push({
            handler: async function (data) {
                const { trace, block, transaction, transactionReceipt } = formatEthData(data);
                if (!transaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'transaction is empty');
                }
                let to = transaction.to;
                if (to === trace?.action.from) {
                    to = '*';
                }
                const ctx = new GlobalContext(chainId, to || '*', data.timestamp, block, undefined, trace, transaction, transactionReceipt, processor.config.baseLabels);
                await handler(transaction, ctx);
                return ctx.stopAndGetResult();
            },
            preprocessHandler: async function (data, preprocessStore) {
                const { trace, block, transaction, transactionReceipt } = formatEthData(data);
                if (!transaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'transaction is empty');
                }
                let to = transaction.to;
                if (to === trace?.action.from) {
                    to = '*';
                }
                const ctx = new GlobalContext(chainId, to || '*', data.timestamp, block, undefined, trace, transaction, transactionReceipt, processor.config.baseLabels);
                return preprocessHandler(transaction, ctx, preprocessStore);
            },
            fetchConfig: EthFetchConfig.fromPartial(fetchConfig || {})
        });
        return this;
    }
    onTrace(signatures, handler, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        const chainId = this.getChainId();
        if (typeof signatures === 'string') {
            signatures = [signatures];
        }
        for (const signature of signatures) {
            if (signature.length <= 2) {
                throw new Error('Invalid signature length, must start with 0x');
            }
        }
        const processor = this;
        this.traceHandlers.push({
            signatures,
            fetchConfig: EthFetchConfig.fromPartial(fetchConfig || {}),
            handler: async function (data) {
                const { trace, block, transaction, transactionReceipt } = formatEthData(data);
                if (!trace) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'trace is null');
                }
                const ctx = new GlobalContext(chainId, trace.action.to || '*', data.timestamp, block, undefined, trace, transaction, transactionReceipt, processor.config.baseLabels);
                await handler(trace, ctx);
                return ctx.stopAndGetResult();
            },
            preprocessHandler: async function (data, preprocessStore) {
                const { trace, block, transaction, transactionReceipt } = formatEthData(data);
                if (!trace) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'trace is null');
                }
                const ctx = new GlobalContext(chainId, trace.action.to || '*', data.timestamp, block, undefined, trace, transaction, transactionReceipt, processor.config.baseLabels);
                return preprocessHandler(trace, ctx, preprocessStore);
            }
        });
        return this;
    }
}
export class BaseProcessor {
    blockHandlers = [];
    eventHandlers = [];
    traceHandlers = [];
    config;
    constructor(config) {
        this.config = {
            address: config.address,
            name: config.name || '',
            network: config.network || EthChainId.ETHEREUM,
            startBlock: 0n,
            baseLabels: config.baseLabels
        };
        if (config.startBlock) {
            this.config.startBlock = BigInt(config.startBlock);
        }
        if (config.endBlock) {
            this.config.endBlock = BigInt(config.endBlock);
        }
    }
    getChainId() {
        return this.config.network;
    }
    onEvent(handler, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        const _filters = [];
        const tmpContract = this.CreateBoundContractView();
        for (const fragment of tmpContract.rawContract.interface.fragments) {
            if (fragment.type === 'event') {
                const filter = tmpContract.rawContract.filters[fragment.format()];
                _filters.push(filter());
            }
        }
        return this.onEthEvent(handler, _filters, fetchConfig, preprocessHandler);
    }
    onEthEvent(handler, filter, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        const chainId = this.getChainId();
        let _filters = [];
        if (Array.isArray(filter)) {
            _filters = filter;
        }
        else {
            _filters.push(filter);
        }
        const contractName = this.config.name;
        const processor = this;
        this.eventHandlers.push({
            filters: _filters,
            fetchConfig: EthFetchConfig.fromPartial(fetchConfig || {}),
            handler: async function (data, preparedData) {
                const { log, block, transaction, transactionReceipt } = formatEthData(data);
                if (!log) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Log is empty');
                }
                let contractView;
                try {
                    contractView = processor.CreateBoundContractView();
                }
                catch (e) {
                    throw e;
                    // console.log(e)
                }
                if (processor.config.address === '*') {
                    contractView.address = log.address;
                }
                const ctx = new ContractContext(contractName, contractView, chainId, data.timestamp, block, log, undefined, transaction, transactionReceipt, processor.config.baseLabels, preparedData);
                const logParam = log;
                let parsed = null;
                try {
                    parsed = contractView.rawContract.interface.parseLog(logParam);
                }
                catch (e) {
                    // RangeError data out-of-bounds
                    if (e instanceof Error) {
                        if (e.message.includes('data out-of-bounds')) {
                            console.error("Can't decode", log, 'may because of incompatible ABIs, e.g. string vs indexed string', e);
                            return ProcessResult.fromPartial({});
                        }
                    }
                    throw e;
                }
                if (parsed) {
                    const event = { ...log, name: parsed.name, args: fixEmptyKey(parsed) };
                    await handler(event, ctx);
                    return ctx.stopAndGetResult();
                }
                return ProcessResult.fromPartial({});
            },
            preprocessHandler: async function (data, preprocessStore) {
                const { log, block, transaction, transactionReceipt } = formatEthData(data);
                if (!log) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Log is empty');
                }
                let contractView;
                try {
                    contractView = processor.CreateBoundContractView();
                }
                catch (e) {
                    throw e;
                    // console.log(e)
                }
                if (processor.config.address === '*') {
                    contractView.address = log.address;
                }
                const ctx = new ContractContext(contractName, contractView, chainId, data.timestamp, block, log, undefined, transaction, transactionReceipt, processor.config.baseLabels);
                const logParam = log;
                let parsed = null;
                try {
                    parsed = contractView.rawContract.interface.parseLog(logParam);
                }
                catch (e) {
                    // RangeError data out-of-bounds
                    if (e instanceof Error) {
                        if (e.message.includes('data out-of-bounds')) {
                            console.error("Can't decode", log, 'may because of incompatible ABIs, e.g. string vs indexed string', e);
                            return PreprocessResult.fromPartial({});
                        }
                    }
                    throw e;
                }
                if (parsed) {
                    const event = { ...log, name: parsed.name, args: fixEmptyKey(parsed) };
                    return preprocessHandler(event, ctx, preprocessStore);
                }
                return PreprocessResult.fromPartial({});
            }
        });
        return this;
    }
    onBlockInterval(handler, blockInterval = 250, backfillBlockInterval = 1000, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onInterval(handler, undefined, {
            recentInterval: blockInterval,
            backfillInterval: backfillBlockInterval
        }, fetchConfig, preprocessHandler);
    }
    onTimeInterval(handler, timeIntervalInMinutes = 60, backfillTimeIntervalInMinutes = 240, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        return this.onInterval(handler, { recentInterval: timeIntervalInMinutes, backfillInterval: backfillTimeIntervalInMinutes }, undefined, fetchConfig, preprocessHandler);
    }
    onInterval(handler, timeInterval, blockInterval, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        const chainId = this.getChainId();
        const processor = this;
        const contractName = this.config.name;
        this.blockHandlers.push({
            handler: async function (data, preparedData) {
                const { block } = formatEthData(data);
                if (!block) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Block is empty');
                }
                const contractView = processor.CreateBoundContractView();
                const ctx = new ContractContext(contractName, contractView, chainId, new Date(block.timestamp * 1000), block, undefined, undefined, undefined, undefined, processor.config.baseLabels, preparedData);
                await handler(block, ctx);
                return ctx.stopAndGetResult();
            },
            preprocessHandler: async function (data, preprocessStore) {
                const { block } = formatEthData(data);
                if (!block) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Block is empty');
                }
                const contractView = processor.CreateBoundContractView();
                const ctx = new ContractContext(contractName, contractView, chainId, new Date(block.timestamp * 1000), block, undefined, undefined, undefined, undefined, processor.config.baseLabels);
                return preprocessHandler(block, ctx, preprocessStore);
            },
            timeIntervalInMinutes: timeInterval,
            blockInterval: blockInterval,
            fetchConfig: EthFetchConfig.fromPartial(fetchConfig || {})
        });
        return this;
    }
    onEthTrace(signatures, handler, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        const chainId = this.getChainId();
        const contractName = this.config.name;
        const processor = this;
        if (typeof signatures === 'string') {
            signatures = [signatures];
        }
        this.traceHandlers.push({
            signatures,
            fetchConfig: EthFetchConfig.fromPartial(fetchConfig || {}),
            handler: async function (data, preparedData) {
                const contractView = processor.CreateBoundContractView();
                const contractInterface = contractView.rawContract.interface;
                const { trace, block, transaction, transactionReceipt } = formatEthData(data);
                const sighash = trace?.action.input?.slice(0, 10);
                if (!sighash) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'trace has no sighash');
                }
                const fragment = contractInterface.getFunction(sighash);
                if (!trace || !fragment) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'trace is null');
                }
                const typedTrace = trace;
                typedTrace.name = fragment.name;
                typedTrace.functionSignature = fragment.format();
                // const trace = data.trace as Trace
                if (!trace?.action.input) {
                    return ProcessResult.fromPartial({});
                }
                const traceData = '0x' + trace.action.input.slice(10);
                try {
                    typedTrace.args = contractInterface.getAbiCoder().decode(fragment.inputs, traceData, true);
                }
                catch (e) {
                    if (!trace.error) {
                        throw e;
                    }
                    console.error('Failed to decode successful trace', e);
                }
                const ctx = new ContractContext(contractName, contractView, chainId, data.timestamp, block, undefined, trace, transaction, transactionReceipt, processor.config.baseLabels, preparedData);
                await handler(typedTrace, ctx);
                return ctx.stopAndGetResult();
            },
            preprocessHandler: async function (data, preprocessStore) {
                const contractView = processor.CreateBoundContractView();
                const contractInterface = contractView.rawContract.interface;
                const { trace, block, transaction, transactionReceipt } = formatEthData(data);
                const sighash = trace?.action.input?.slice(0, 10);
                if (!sighash) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'trace has no sighash');
                }
                const fragment = contractInterface.getFunction(sighash);
                if (!trace || !fragment) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'trace is null');
                }
                const typedTrace = trace;
                typedTrace.name = fragment.name;
                typedTrace.functionSignature = fragment.format();
                // const trace = data.trace as Trace
                if (!trace?.action.input) {
                    return PreprocessResult.fromPartial({});
                }
                const traceData = '0x' + trace.action.input.slice(10);
                try {
                    typedTrace.args = contractInterface.getAbiCoder().decode(fragment.inputs, traceData, true);
                }
                catch (e) {
                    if (!trace.error) {
                        throw e;
                    }
                    console.error('Failed to decode successful trace', e);
                }
                const ctx = new ContractContext(contractName, contractView, chainId, data.timestamp, block, undefined, trace, transaction, transactionReceipt, processor.config.baseLabels);
                return preprocessHandler(typedTrace, ctx, preprocessStore);
            }
        });
        return this;
    }
    onTrace(handler, fetchConfig, preprocessHandler = defaultPreprocessHandler) {
        const tmpContract = this.CreateBoundContractView();
        const sighashes = [];
        for (const fragment of tmpContract.rawContract.interface.fragments) {
            if (fragment.type === 'function') {
                const signature = fragment.format();
                const test = new TextEncoder().encode(signature);
                const sighash = '0x' + sha3.keccak_256(test).substring(0, 8);
                sighashes.push(sighash);
            }
        }
        return this.onEthTrace(sighashes, handler, fetchConfig, preprocessHandler);
    }
}
//# sourceMappingURL=base-processor.js.map