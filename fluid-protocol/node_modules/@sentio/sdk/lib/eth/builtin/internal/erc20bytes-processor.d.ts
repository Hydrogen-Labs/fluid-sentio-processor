import { BigNumberish, Overrides } from "ethers";
import { BindOptions, BaseProcessor, BaseProcessorTemplate, BoundContractView, ContractContext, ContractView, EthChainId, TypedCallTrace, EthContext, EthFetchConfig, PreprocessResult } from "@sentio/sdk/eth";
import { EthCallParam, EthCallContext, PreparedData } from "@sentio/protos";
import { ERC20Bytes, ApprovalEvent, ApprovalEventFilter, TransferEvent, TransferEventFilter } from "./ERC20Bytes.js";
export interface NameCallObject {
}
export type NameCallTrace = TypedCallTrace<[], NameCallObject>;
export interface ApproveCallObject {
    spender: string;
    value: bigint;
}
export type ApproveCallTrace = TypedCallTrace<[
    string,
    bigint
], ApproveCallObject>;
export interface TotalSupplyCallObject {
}
export type TotalSupplyCallTrace = TypedCallTrace<[], TotalSupplyCallObject>;
export interface TransferFromCallObject {
    from: string;
    to: string;
    value: bigint;
}
export type TransferFromCallTrace = TypedCallTrace<[
    string,
    string,
    bigint
], TransferFromCallObject>;
export interface DecimalsCallObject {
}
export type DecimalsCallTrace = TypedCallTrace<[], DecimalsCallObject>;
export interface BalanceOfCallObject {
    who: string;
}
export type BalanceOfCallTrace = TypedCallTrace<[string], BalanceOfCallObject>;
export interface SymbolCallObject {
}
export type SymbolCallTrace = TypedCallTrace<[], SymbolCallObject>;
export interface TransferCallObject {
    to: string;
    value: bigint;
}
export type TransferCallTrace = TypedCallTrace<[
    string,
    bigint
], TransferCallObject>;
export interface AllowanceCallObject {
    owner: string;
    spender: string;
}
export type AllowanceCallTrace = TypedCallTrace<[
    string,
    string
], AllowanceCallObject>;
export declare class ERC20BytesContractView extends ContractView<ERC20Bytes> {
    constructor(contract: ERC20Bytes);
    name(overrides?: Overrides, preparedData?: PreparedData, ethCallContext?: EthCallContext): Promise<string>;
    totalSupply(overrides?: Overrides, preparedData?: PreparedData, ethCallContext?: EthCallContext): Promise<bigint>;
    decimals(overrides?: Overrides, preparedData?: PreparedData, ethCallContext?: EthCallContext): Promise<bigint>;
    balanceOf(who: string, overrides?: Overrides, preparedData?: PreparedData, ethCallContext?: EthCallContext): Promise<bigint>;
    symbol(overrides?: Overrides, preparedData?: PreparedData, ethCallContext?: EthCallContext): Promise<string>;
    allowance(owner: string, spender: string, overrides?: Overrides, preparedData?: PreparedData, ethCallContext?: EthCallContext): Promise<bigint>;
    callStatic: {
        contract: ERC20Bytes;
        approve(spender: string, value: BigNumberish, overrides?: Overrides, preparedData?: PreparedData, ethCallContext?: EthCallContext): Promise<boolean>;
        transferFrom(from: string, to: string, value: BigNumberish, overrides?: Overrides, preparedData?: PreparedData, ethCallContext?: EthCallContext): Promise<boolean>;
        transfer(to: string, value: BigNumberish, overrides?: Overrides, preparedData?: PreparedData, ethCallContext?: EthCallContext): Promise<boolean>;
    };
    encodeCall: {
        name(ethCallContext: EthCallContext): EthCallParam;
        approve(spender: string, value: BigNumberish, ethCallContext: EthCallContext): EthCallParam;
        totalSupply(ethCallContext: EthCallContext): EthCallParam;
        transferFrom(from: string, to: string, value: BigNumberish, ethCallContext: EthCallContext): EthCallParam;
        decimals(ethCallContext: EthCallContext): EthCallParam;
        balanceOf(who: string, ethCallContext: EthCallContext): EthCallParam;
        symbol(ethCallContext: EthCallContext): EthCallParam;
        transfer(to: string, value: BigNumberish, ethCallContext: EthCallContext): EthCallParam;
        allowance(owner: string, spender: string, ethCallContext: EthCallContext): EthCallParam;
    };
}
export declare class ERC20BytesBoundContractView extends BoundContractView<ERC20Bytes, ERC20BytesContractView> {
    name(overrides?: Overrides): Promise<string>;
    totalSupply(overrides?: Overrides): Promise<bigint>;
    decimals(overrides?: Overrides): Promise<bigint>;
    balanceOf(who: string, overrides?: Overrides): Promise<bigint>;
    symbol(overrides?: Overrides): Promise<string>;
    allowance(owner: string, spender: string, overrides?: Overrides): Promise<bigint>;
    callStatic: {
        view: ERC20BytesContractView;
        context: EthContext;
        approve(spender: string, value: BigNumberish, overrides?: Overrides): Promise<boolean>;
        transferFrom(from: string, to: string, value: BigNumberish, overrides?: Overrides): Promise<boolean>;
        transfer(to: string, value: BigNumberish, overrides?: Overrides): Promise<boolean>;
    };
    encodeCall: {
        view: ERC20BytesContractView;
        context: EthContext;
        name(overrides?: Overrides): EthCallParam;
        approve(spender: string, value: BigNumberish, overrides?: Overrides): EthCallParam;
        totalSupply(overrides?: Overrides): EthCallParam;
        transferFrom(from: string, to: string, value: BigNumberish, overrides?: Overrides): EthCallParam;
        decimals(overrides?: Overrides): EthCallParam;
        balanceOf(who: string, overrides?: Overrides): EthCallParam;
        symbol(overrides?: Overrides): EthCallParam;
        transfer(to: string, value: BigNumberish, overrides?: Overrides): EthCallParam;
        allowance(owner: string, spender: string, overrides?: Overrides): EthCallParam;
    };
}
export type ERC20BytesContext = ContractContext<ERC20Bytes, ERC20BytesBoundContractView>;
export declare class ERC20BytesProcessor extends BaseProcessor<ERC20Bytes, ERC20BytesBoundContractView> {
    onEventApproval(handler: (event: ApprovalEvent, ctx: ERC20BytesContext) => void, filter?: ApprovalEventFilter | ApprovalEventFilter[], fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (event: ApprovalEvent, ctx: ERC20BytesContext, preprocessStore: {
        [k: string]: any;
    }) => Promise<PreprocessResult>): this;
    onEventTransfer(handler: (event: TransferEvent, ctx: ERC20BytesContext) => void, filter?: TransferEventFilter | TransferEventFilter[], fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (event: TransferEvent, ctx: ERC20BytesContext, preprocessStore: {
        [k: string]: any;
    }) => Promise<PreprocessResult>): this;
    onCallName(handler: (call: NameCallTrace, ctx: ERC20BytesContext) => void, fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (call: NameCallTrace, ctx: ERC20BytesContext) => Promise<PreprocessResult>): this;
    onCallApprove(handler: (call: ApproveCallTrace, ctx: ERC20BytesContext) => void, fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (call: ApproveCallTrace, ctx: ERC20BytesContext) => Promise<PreprocessResult>): this;
    onCallTotalSupply(handler: (call: TotalSupplyCallTrace, ctx: ERC20BytesContext) => void, fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (call: TotalSupplyCallTrace, ctx: ERC20BytesContext) => Promise<PreprocessResult>): this;
    onCallTransferFrom(handler: (call: TransferFromCallTrace, ctx: ERC20BytesContext) => void, fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (call: TransferFromCallTrace, ctx: ERC20BytesContext) => Promise<PreprocessResult>): this;
    onCallDecimals(handler: (call: DecimalsCallTrace, ctx: ERC20BytesContext) => void, fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (call: DecimalsCallTrace, ctx: ERC20BytesContext) => Promise<PreprocessResult>): this;
    onCallBalanceOf(handler: (call: BalanceOfCallTrace, ctx: ERC20BytesContext) => void, fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (call: BalanceOfCallTrace, ctx: ERC20BytesContext) => Promise<PreprocessResult>): this;
    onCallSymbol(handler: (call: SymbolCallTrace, ctx: ERC20BytesContext) => void, fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (call: SymbolCallTrace, ctx: ERC20BytesContext) => Promise<PreprocessResult>): this;
    onCallTransfer(handler: (call: TransferCallTrace, ctx: ERC20BytesContext) => void, fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (call: TransferCallTrace, ctx: ERC20BytesContext) => Promise<PreprocessResult>): this;
    onCallAllowance(handler: (call: AllowanceCallTrace, ctx: ERC20BytesContext) => void, fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (call: AllowanceCallTrace, ctx: ERC20BytesContext) => Promise<PreprocessResult>): this;
    static filters: {
        Approval(owner?: string | null, spender?: string | null, value?: null): ApprovalEventFilter;
        Transfer(from?: string | null, to?: string | null, value?: null): TransferEventFilter;
    };
    protected CreateBoundContractView(): ERC20BytesBoundContractView;
    static bind(options: BindOptions): ERC20BytesProcessor;
}
export declare class ERC20BytesProcessorTemplate extends BaseProcessorTemplate<ERC20Bytes, ERC20BytesBoundContractView> {
    bindInternal(options: BindOptions): ERC20BytesProcessor;
    onEventApproval(handler: (event: ApprovalEvent, ctx: ERC20BytesContext) => void, filter?: ApprovalEventFilter | ApprovalEventFilter[], fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (event: ApprovalEvent, ctx: ERC20BytesContext, preprocessStore: {
        [k: string]: any;
    }) => Promise<PreprocessResult>): this;
    onEventTransfer(handler: (event: TransferEvent, ctx: ERC20BytesContext) => void, filter?: TransferEventFilter | TransferEventFilter[], fetchConfig?: Partial<EthFetchConfig>, preprocessHandler?: (event: TransferEvent, ctx: ERC20BytesContext, preprocessStore: {
        [k: string]: any;
    }) => Promise<PreprocessResult>): this;
}
export declare function getERC20BytesContract(chainId: EthChainId, address: string): ERC20BytesContractView;
export declare function getERC20BytesContractOnContext(context: EthContext, address: string): ERC20BytesBoundContractView;
//# sourceMappingURL=erc20bytes-processor.d.ts.map