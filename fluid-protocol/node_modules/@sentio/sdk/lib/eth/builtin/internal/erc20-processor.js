/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { Interface } from "ethers";
import { addContractByABI, getContractByABI, addProcessor, getProcessor, getProvider, transformEtherError, BaseProcessor, BaseProcessorTemplate, BoundContractView, ContractView, DummyProvider, } from "@sentio/sdk/eth";
import { ERC20__factory } from "./index.js";
const templateContract = ERC20__factory.connect("0x0", DummyProvider);
const iface = new Interface([
    "function allowance(address owner, address spender) view returns (uint256)",
    "function approve(address spender, uint256 amount) returns (bool)",
    "function balanceOf(address account) view returns (uint256)",
    "function burn(uint256 amount) returns ()",
    "function burnFrom(address account, uint256 amount) returns ()",
    "function decimals() view returns (uint8)",
    "function decreaseAllowance(address spender, uint256 subtractedValue) returns (bool)",
    "function increaseAllowance(address spender, uint256 addedValue) returns (bool)",
    "function locker() view returns (address)",
    "function name() view returns (string)",
    "function owner() view returns (address)",
    "function renounceOwnership() returns ()",
    "function setLocker(address _locker) returns ()",
    "function symbol() view returns (string)",
    "function totalSupply() view returns (uint256)",
    "function transfer(address recipient, uint256 amount) returns (bool)",
    "function transferFrom(address sender, address recipient, uint256 amount) returns (bool)",
    "function transferOwnership(address newOwner) returns ()",
]);
export class ERC20ContractView extends ContractView {
    constructor(contract) {
        super(contract);
        this.callStatic.contract = contract;
    }
    async allowance(owner, spender, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("allowance(address,address)")(owner, spender, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async balanceOf(account, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("balanceOf(address)")(account, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async decimals(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("decimals()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async locker(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("locker()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async name(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("name()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async owner(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("owner()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async symbol(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("symbol()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async totalSupply(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("totalSupply()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    callStatic = {
        contract: this.contract,
        async approve(spender, amount, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("approve(address,uint256)")
                    .staticCall(spender, amount, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async burn(amount, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("burn(uint256)")
                    .staticCall(amount, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async burnFrom(account, amount, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("burnFrom(address,uint256)")
                    .staticCall(account, amount, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async decreaseAllowance(spender, subtractedValue, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("decreaseAllowance(address,uint256)")
                    .staticCall(spender, subtractedValue, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async increaseAllowance(spender, addedValue, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("increaseAllowance(address,uint256)")
                    .staticCall(spender, addedValue, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async renounceOwnership(overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("renounceOwnership()")
                    .staticCall(overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async setLocker(_locker, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("setLocker(address)")
                    .staticCall(_locker, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async transfer(recipient, amount, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("transfer(address,uint256)")
                    .staticCall(recipient, amount, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async transferFrom(sender, recipient, amount, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("transferFrom(address,address,uint256)")
                    .staticCall(sender, recipient, amount, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async transferOwnership(newOwner, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("transferOwnership(address)")
                    .staticCall(newOwner, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
    };
    encodeCall = {
        allowance(owner, spender, ethCallContext) {
            try {
                const iface = new Interface(["function allowance(address,address)"]);
                const calldata = iface.encodeFunctionData("allowance", [
                    owner,
                    spender,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        approve(spender, amount, ethCallContext) {
            try {
                const iface = new Interface(["function approve(address,uint256)"]);
                const calldata = iface.encodeFunctionData("approve", [spender, amount]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        balanceOf(account, ethCallContext) {
            try {
                const iface = new Interface(["function balanceOf(address)"]);
                const calldata = iface.encodeFunctionData("balanceOf", [account]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        burn(amount, ethCallContext) {
            try {
                const iface = new Interface(["function burn(uint256)"]);
                const calldata = iface.encodeFunctionData("burn", [amount]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        burnFrom(account, amount, ethCallContext) {
            try {
                const iface = new Interface(["function burnFrom(address,uint256)"]);
                const calldata = iface.encodeFunctionData("burnFrom", [
                    account,
                    amount,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        decimals(ethCallContext) {
            try {
                const iface = new Interface(["function decimals()"]);
                const calldata = iface.encodeFunctionData("decimals", []);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        decreaseAllowance(spender, subtractedValue, ethCallContext) {
            try {
                const iface = new Interface([
                    "function decreaseAllowance(address,uint256)",
                ]);
                const calldata = iface.encodeFunctionData("decreaseAllowance", [
                    spender,
                    subtractedValue,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        increaseAllowance(spender, addedValue, ethCallContext) {
            try {
                const iface = new Interface([
                    "function increaseAllowance(address,uint256)",
                ]);
                const calldata = iface.encodeFunctionData("increaseAllowance", [
                    spender,
                    addedValue,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        locker(ethCallContext) {
            try {
                const iface = new Interface(["function locker()"]);
                const calldata = iface.encodeFunctionData("locker", []);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        name(ethCallContext) {
            try {
                const iface = new Interface(["function name()"]);
                const calldata = iface.encodeFunctionData("name", []);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        owner(ethCallContext) {
            try {
                const iface = new Interface(["function owner()"]);
                const calldata = iface.encodeFunctionData("owner", []);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        renounceOwnership(ethCallContext) {
            try {
                const iface = new Interface(["function renounceOwnership()"]);
                const calldata = iface.encodeFunctionData("renounceOwnership", []);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        setLocker(_locker, ethCallContext) {
            try {
                const iface = new Interface(["function setLocker(address)"]);
                const calldata = iface.encodeFunctionData("setLocker", [_locker]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        symbol(ethCallContext) {
            try {
                const iface = new Interface(["function symbol()"]);
                const calldata = iface.encodeFunctionData("symbol", []);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        totalSupply(ethCallContext) {
            try {
                const iface = new Interface(["function totalSupply()"]);
                const calldata = iface.encodeFunctionData("totalSupply", []);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        transfer(recipient, amount, ethCallContext) {
            try {
                const iface = new Interface(["function transfer(address,uint256)"]);
                const calldata = iface.encodeFunctionData("transfer", [
                    recipient,
                    amount,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        transferFrom(sender, recipient, amount, ethCallContext) {
            try {
                const iface = new Interface([
                    "function transferFrom(address,address,uint256)",
                ]);
                const calldata = iface.encodeFunctionData("transferFrom", [
                    sender,
                    recipient,
                    amount,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        transferOwnership(newOwner, ethCallContext) {
            try {
                const iface = new Interface(["function transferOwnership(address)"]);
                const calldata = iface.encodeFunctionData("transferOwnership", [
                    newOwner,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
    };
}
export class ERC20BoundContractView extends BoundContractView {
    async allowance(owner, spender, overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.allowance(owner, spender, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async balanceOf(account, overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.balanceOf(account, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async decimals(overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.decimals({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async locker(overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.locker({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async name(overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.name({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async owner(overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.owner({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async symbol(overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.symbol({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async totalSupply(overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.totalSupply({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    callStatic = {
        view: this.view,
        context: this.context,
        async approve(spender, amount, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.approve(spender, amount, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async burn(amount, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.burn(amount, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async burnFrom(account, amount, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.burnFrom(account, amount, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async decreaseAllowance(spender, subtractedValue, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.decreaseAllowance(spender, subtractedValue, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async increaseAllowance(spender, addedValue, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.increaseAllowance(spender, addedValue, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async renounceOwnership(overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.renounceOwnership({
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async setLocker(_locker, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.setLocker(_locker, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async transfer(recipient, amount, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.transfer(recipient, amount, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async transferFrom(sender, recipient, amount, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.transferFrom(sender, recipient, amount, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async transferOwnership(newOwner, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.transferOwnership(newOwner, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
    };
    encodeCall = {
        view: this.view,
        context: this.context,
        allowance(owner, spender, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.allowance(owner, spender, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        approve(spender, amount, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.approve(spender, amount, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        balanceOf(account, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.balanceOf(account, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        burn(amount, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.burn(amount, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        burnFrom(account, amount, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.burnFrom(account, amount, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        decimals(overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.decimals({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        decreaseAllowance(spender, subtractedValue, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.decreaseAllowance(spender, subtractedValue, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        increaseAllowance(spender, addedValue, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.increaseAllowance(spender, addedValue, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        locker(overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.locker({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        name(overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.name({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        owner(overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.owner({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        renounceOwnership(overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.renounceOwnership({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        setLocker(_locker, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.setLocker(_locker, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        symbol(overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.symbol({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        totalSupply(overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.totalSupply({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        transfer(recipient, amount, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.transfer(recipient, amount, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        transferFrom(sender, recipient, amount, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.transferFrom(sender, recipient, amount, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        transferOwnership(newOwner, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.transferOwnership(newOwner, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
    };
}
export class ERC20Processor extends BaseProcessor {
    onEventApproval(handler, filter, fetchConfig, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["Approval(address,address,uint256)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, fetchConfig, preprocessHandler);
    }
    onEventOwnershipTransferred(handler, filter, fetchConfig, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["OwnershipTransferred(address,address)"](null, null);
        }
        return super.onEthEvent(handler, filter, fetchConfig, preprocessHandler);
    }
    onEventTransfer(handler, filter, fetchConfig, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["Transfer(address,address,uint256)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, fetchConfig, preprocessHandler);
    }
    onCallAllowance(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0xdd62ed3e", handler, fetchConfig, preprocessHandler);
    }
    onCallApprove(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x095ea7b3", handler, fetchConfig, preprocessHandler);
    }
    onCallBalanceOf(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x70a08231", handler, fetchConfig, preprocessHandler);
    }
    onCallBurn(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x42966c68", handler, fetchConfig, preprocessHandler);
    }
    onCallBurnFrom(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x79cc6790", handler, fetchConfig, preprocessHandler);
    }
    onCallDecimals(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x313ce567", handler, fetchConfig, preprocessHandler);
    }
    onCallDecreaseAllowance(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0xa457c2d7", handler, fetchConfig, preprocessHandler);
    }
    onCallIncreaseAllowance(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x39509351", handler, fetchConfig, preprocessHandler);
    }
    onCallLocker(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0xd7b96d4e", handler, fetchConfig, preprocessHandler);
    }
    onCallName(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x06fdde03", handler, fetchConfig, preprocessHandler);
    }
    onCallOwner(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x8da5cb5b", handler, fetchConfig, preprocessHandler);
    }
    onCallRenounceOwnership(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x715018a6", handler, fetchConfig, preprocessHandler);
    }
    onCallSetLocker(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x171060ec", handler, fetchConfig, preprocessHandler);
    }
    onCallSymbol(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x95d89b41", handler, fetchConfig, preprocessHandler);
    }
    onCallTotalSupply(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x18160ddd", handler, fetchConfig, preprocessHandler);
    }
    onCallTransfer(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0xa9059cbb", handler, fetchConfig, preprocessHandler);
    }
    onCallTransferFrom(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x23b872dd", handler, fetchConfig, preprocessHandler);
    }
    onCallTransferOwnership(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0xf2fde38b", handler, fetchConfig, preprocessHandler);
    }
    static filters = {
        Approval(owner, spender, value) {
            return templateContract.filters["Approval(address,address,uint256)"](owner, spender, value);
        },
        OwnershipTransferred(previousOwner, newOwner) {
            return templateContract.filters["OwnershipTransferred(address,address)"](previousOwner, newOwner);
        },
        Transfer(from, to, value) {
            return templateContract.filters["Transfer(address,address,uint256)"](from, to, value);
        },
    };
    CreateBoundContractView() {
        const view = getERC20Contract(this.config.network, this.config.address);
        return new ERC20BoundContractView(this.config.address, view);
    }
    static bind(options) {
        if (!options.name) {
            options.name = "ERC20";
        }
        let processor = getProcessor(options);
        if (!processor) {
            processor = new ERC20Processor(options);
            addProcessor(options, processor);
        }
        return processor;
    }
}
export class ERC20ProcessorTemplate extends BaseProcessorTemplate {
    bindInternal(options) {
        if (!options.name) {
            options.name = "ERC20";
        }
        let processor = getProcessor(options);
        if (!processor) {
            processor = new ERC20Processor(options);
            addProcessor(options, processor);
        }
        return processor;
    }
    onEventApproval(handler, filter, fetchConfig, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["Approval(address,address,uint256)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, fetchConfig, preprocessHandler);
    }
    onEventOwnershipTransferred(handler, filter, fetchConfig, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["OwnershipTransferred(address,address)"](null, null);
        }
        return super.onEthEvent(handler, filter, fetchConfig, preprocessHandler);
    }
    onEventTransfer(handler, filter, fetchConfig, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["Transfer(address,address,uint256)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, fetchConfig, preprocessHandler);
    }
}
export function getERC20Contract(chainId, address) {
    let contract = getContractByABI("ERC20", address, chainId);
    if (!contract) {
        const rawContract = ERC20__factory.connect(address, getProvider(chainId));
        contract = new ERC20ContractView(rawContract);
        addContractByABI("ERC20", address, chainId, contract);
    }
    return contract;
}
export function getERC20ContractOnContext(context, address) {
    const view = getERC20Contract(context.getChainId(), address);
    const boundView = new ERC20BoundContractView(address, view);
    boundView.context = context;
    if (boundView.callStatic) {
        boundView.callStatic.context = context;
    }
    return boundView;
}
//# sourceMappingURL=erc20-processor.js.map