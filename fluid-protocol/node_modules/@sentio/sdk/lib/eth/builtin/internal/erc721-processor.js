/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { Interface } from "ethers";
import { addContractByABI, getContractByABI, addProcessor, getProcessor, getProvider, transformEtherError, BaseProcessor, BaseProcessorTemplate, BoundContractView, ContractView, DummyProvider, } from "@sentio/sdk/eth";
import { ERC721__factory } from "./index.js";
const templateContract = ERC721__factory.connect("0x0", DummyProvider);
const iface = new Interface([
    "function approve(address to, uint256 tokenId) returns ()",
    "function totalSupply() view returns (uint256)",
    "function balanceOf(address owner) view returns (uint256 balance)",
    "function getApproved(uint256 tokenId) view returns (address operator)",
    "function isApprovedForAll(address owner, address operator) view returns (bool)",
    "function name() view returns (string)",
    "function ownerOf(uint256 tokenId) view returns (address owner)",
    "function safeTransferFrom(address from, address to, uint256 tokenId) returns ()",
    "function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns ()",
    "function setApprovalForAll(address operator, bool _approved) returns ()",
    "function supportsInterface(bytes4 interfaceId) view returns (bool)",
    "function symbol() view returns (string)",
    "function tokenURI(uint256 tokenId) view returns (string)",
    "function transferFrom(address from, address to, uint256 tokenId) returns ()",
]);
export class ERC721ContractView extends ContractView {
    constructor(contract) {
        super(contract);
        this.callStatic.contract = contract;
    }
    async totalSupply(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("totalSupply()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async balanceOf(owner, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("balanceOf(address)")(owner, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async getApproved(tokenId, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("getApproved(uint256)")(tokenId, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async isApprovedForAll(owner, operator, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("isApprovedForAll(address,address)")(owner, operator, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async name(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("name()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async ownerOf(tokenId, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("ownerOf(uint256)")(tokenId, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async supportsInterface(interfaceId, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("supportsInterface(bytes4)")(interfaceId, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async symbol(overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("symbol()")(overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    async tokenURI(tokenId, overrides, preparedData, ethCallContext) {
        try {
            return await this.contract.getFunction("tokenURI(uint256)")(tokenId, overrides || {});
        }
        catch (e) {
            const stack = new Error().stack;
            throw transformEtherError(e, undefined, stack);
        }
    }
    callStatic = {
        contract: this.contract,
        async approve(to, tokenId, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("approve(address,uint256)")
                    .staticCall(to, tokenId, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async safeTransferFrom_address_address_uint256(from, to, tokenId, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("safeTransferFrom(address,address,uint256)")
                    .staticCall(from, to, tokenId, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async safeTransferFrom_address_address_uint256_bytes(from, to, tokenId, data, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("safeTransferFrom(address,address,uint256,bytes)")
                    .staticCall(from, to, tokenId, data, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async setApprovalForAll(operator, _approved, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("setApprovalForAll(address,bool)")
                    .staticCall(operator, _approved, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        async transferFrom(from, to, tokenId, overrides, preparedData, ethCallContext) {
            try {
                return await this.contract
                    .getFunction("transferFrom(address,address,uint256)")
                    .staticCall(from, to, tokenId, overrides || {});
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
    };
    encodeCall = {
        approve(to, tokenId, ethCallContext) {
            try {
                const iface = new Interface(["function approve(address,uint256)"]);
                const calldata = iface.encodeFunctionData("approve", [to, tokenId]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        totalSupply(ethCallContext) {
            try {
                const iface = new Interface(["function totalSupply()"]);
                const calldata = iface.encodeFunctionData("totalSupply", []);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        balanceOf(owner, ethCallContext) {
            try {
                const iface = new Interface(["function balanceOf(address)"]);
                const calldata = iface.encodeFunctionData("balanceOf", [owner]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        getApproved(tokenId, ethCallContext) {
            try {
                const iface = new Interface(["function getApproved(uint256)"]);
                const calldata = iface.encodeFunctionData("getApproved", [tokenId]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        isApprovedForAll(owner, operator, ethCallContext) {
            try {
                const iface = new Interface([
                    "function isApprovedForAll(address,address)",
                ]);
                const calldata = iface.encodeFunctionData("isApprovedForAll", [
                    owner,
                    operator,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        name(ethCallContext) {
            try {
                const iface = new Interface(["function name()"]);
                const calldata = iface.encodeFunctionData("name", []);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        ownerOf(tokenId, ethCallContext) {
            try {
                const iface = new Interface(["function ownerOf(uint256)"]);
                const calldata = iface.encodeFunctionData("ownerOf", [tokenId]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        safeTransferFrom_address_address_uint256(from, to, tokenId, ethCallContext) {
            try {
                const iface = new Interface([
                    "function safeTransferFrom(address,address,uint256)",
                ]);
                const calldata = iface.encodeFunctionData("safeTransferFrom", [
                    from,
                    to,
                    tokenId,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        safeTransferFrom_address_address_uint256_bytes(from, to, tokenId, data, ethCallContext) {
            try {
                const iface = new Interface([
                    "function safeTransferFrom(address,address,uint256,bytes)",
                ]);
                const calldata = iface.encodeFunctionData("safeTransferFrom", [
                    from,
                    to,
                    tokenId,
                    data,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        setApprovalForAll(operator, _approved, ethCallContext) {
            try {
                const iface = new Interface([
                    "function setApprovalForAll(address,bool)",
                ]);
                const calldata = iface.encodeFunctionData("setApprovalForAll", [
                    operator,
                    _approved,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        supportsInterface(interfaceId, ethCallContext) {
            try {
                const iface = new Interface(["function supportsInterface(bytes4)"]);
                const calldata = iface.encodeFunctionData("supportsInterface", [
                    interfaceId,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        symbol(ethCallContext) {
            try {
                const iface = new Interface(["function symbol()"]);
                const calldata = iface.encodeFunctionData("symbol", []);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        tokenURI(tokenId, ethCallContext) {
            try {
                const iface = new Interface(["function tokenURI(uint256)"]);
                const calldata = iface.encodeFunctionData("tokenURI", [tokenId]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
        transferFrom(from, to, tokenId, ethCallContext) {
            try {
                const iface = new Interface([
                    "function transferFrom(address,address,uint256)",
                ]);
                const calldata = iface.encodeFunctionData("transferFrom", [
                    from,
                    to,
                    tokenId,
                ]);
                return {
                    context: ethCallContext,
                    calldata,
                };
            }
            catch (e) {
                const stack = new Error().stack;
                throw transformEtherError(e, undefined, stack);
            }
        },
    };
}
export class ERC721BoundContractView extends BoundContractView {
    async totalSupply(overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.totalSupply({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async balanceOf(owner, overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.balanceOf(owner, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async getApproved(tokenId, overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.getApproved(tokenId, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async isApprovedForAll(owner, operator, overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.isApprovedForAll(owner, operator, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async name(overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.name({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async ownerOf(tokenId, overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.ownerOf(tokenId, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async supportsInterface(interfaceId, overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.supportsInterface(interfaceId, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async symbol(overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.symbol({
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    async tokenURI(tokenId, overrides) {
        const ethCallContext = {
            chainId: this.context.chainId,
            blockTag: "0x" + this.context.blockNumber.toString(16),
            address: this.context.address,
        };
        return await this.view.tokenURI(tokenId, {
            blockTag: this.context.blockNumber,
            ...overrides,
        }, this.context.preparedData, ethCallContext);
    }
    callStatic = {
        view: this.view,
        context: this.context,
        async approve(to, tokenId, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.approve(to, tokenId, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async safeTransferFrom_address_address_uint256(from, to, tokenId, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.safeTransferFrom_address_address_uint256(from, to, tokenId, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async safeTransferFrom_address_address_uint256_bytes(from, to, tokenId, data, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.safeTransferFrom_address_address_uint256_bytes(from, to, tokenId, data, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async setApprovalForAll(operator, _approved, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.setApprovalForAll(operator, _approved, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
        async transferFrom(from, to, tokenId, overrides) {
            const ethCallContext = {
                chainId: this.context.chainId,
                blockTag: "0x" + this.context.blockNumber.toString(16),
                address: this.context.address,
            };
            return await this.view.callStatic.transferFrom(from, to, tokenId, {
                blockTag: this.context.blockNumber,
                ...overrides,
            }, this.context.preparedData, ethCallContext);
        },
    };
    encodeCall = {
        view: this.view,
        context: this.context,
        approve(to, tokenId, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.approve(to, tokenId, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        totalSupply(overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.totalSupply({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        balanceOf(owner, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.balanceOf(owner, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        getApproved(tokenId, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.getApproved(tokenId, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        isApprovedForAll(owner, operator, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.isApprovedForAll(owner, operator, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        name(overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.name({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        ownerOf(tokenId, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.ownerOf(tokenId, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        safeTransferFrom_address_address_uint256(from, to, tokenId, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.safeTransferFrom_address_address_uint256(from, to, tokenId, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        safeTransferFrom_address_address_uint256_bytes(from, to, tokenId, data, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.safeTransferFrom_address_address_uint256_bytes(from, to, tokenId, data, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        setApprovalForAll(operator, _approved, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.setApprovalForAll(operator, _approved, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        supportsInterface(interfaceId, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.supportsInterface(interfaceId, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        symbol(overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.symbol({
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        tokenURI(tokenId, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.tokenURI(tokenId, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
        transferFrom(from, to, tokenId, overrides) {
            let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
            if (overrides?.blockTag) {
                blockTagWithOverride =
                    typeof overrides.blockTag == "string"
                        ? overrides.blockTag
                        : "0x" + overrides.blockTag.toString(16);
            }
            return this.view.encodeCall.transferFrom(from, to, tokenId, {
                chainId: this.context.chainId.toString(),
                address: this.context.address,
                blockTag: blockTagWithOverride,
            });
        },
    };
}
export class ERC721Processor extends BaseProcessor {
    onEventApproval(handler, filter, fetchConfig, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["Approval(address,address,uint256)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, fetchConfig, preprocessHandler);
    }
    onEventApprovalForAll(handler, filter, fetchConfig, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["ApprovalForAll(address,address,bool)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, fetchConfig, preprocessHandler);
    }
    onEventTransfer(handler, filter, fetchConfig, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["Transfer(address,address,uint256)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, fetchConfig, preprocessHandler);
    }
    onCallApprove(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x095ea7b3", handler, fetchConfig, preprocessHandler);
    }
    onCallTotalSupply(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x18160ddd", handler, fetchConfig, preprocessHandler);
    }
    onCallBalanceOf(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x70a08231", handler, fetchConfig, preprocessHandler);
    }
    onCallGetApproved(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x081812fc", handler, fetchConfig, preprocessHandler);
    }
    onCallIsApprovedForAll(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0xe985e9c5", handler, fetchConfig, preprocessHandler);
    }
    onCallName(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x06fdde03", handler, fetchConfig, preprocessHandler);
    }
    onCallOwnerOf(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x6352211e", handler, fetchConfig, preprocessHandler);
    }
    onCallSafeTransferFrom_address_address_uint256(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x42842e0e", handler, fetchConfig, preprocessHandler);
    }
    onCallSafeTransferFrom_address_address_uint256_bytes(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0xb88d4fde", handler, fetchConfig, preprocessHandler);
    }
    onCallSetApprovalForAll(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0xa22cb465", handler, fetchConfig, preprocessHandler);
    }
    onCallSupportsInterface(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x01ffc9a7", handler, fetchConfig, preprocessHandler);
    }
    onCallSymbol(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x95d89b41", handler, fetchConfig, preprocessHandler);
    }
    onCallTokenURI(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0xc87b56dd", handler, fetchConfig, preprocessHandler);
    }
    onCallTransferFrom(handler, fetchConfig, preprocessHandler) {
        return super.onEthTrace("0x23b872dd", handler, fetchConfig, preprocessHandler);
    }
    static filters = {
        Approval(owner, approved, tokenId) {
            return templateContract.filters["Approval(address,address,uint256)"](owner, approved, tokenId);
        },
        ApprovalForAll(owner, operator, approved) {
            return templateContract.filters["ApprovalForAll(address,address,bool)"](owner, operator, approved);
        },
        Transfer(from, to, tokenId) {
            return templateContract.filters["Transfer(address,address,uint256)"](from, to, tokenId);
        },
    };
    CreateBoundContractView() {
        const view = getERC721Contract(this.config.network, this.config.address);
        return new ERC721BoundContractView(this.config.address, view);
    }
    static bind(options) {
        if (!options.name) {
            options.name = "ERC721";
        }
        let processor = getProcessor(options);
        if (!processor) {
            processor = new ERC721Processor(options);
            addProcessor(options, processor);
        }
        return processor;
    }
}
export class ERC721ProcessorTemplate extends BaseProcessorTemplate {
    bindInternal(options) {
        if (!options.name) {
            options.name = "ERC721";
        }
        let processor = getProcessor(options);
        if (!processor) {
            processor = new ERC721Processor(options);
            addProcessor(options, processor);
        }
        return processor;
    }
    onEventApproval(handler, filter, fetchConfig, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["Approval(address,address,uint256)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, fetchConfig, preprocessHandler);
    }
    onEventApprovalForAll(handler, filter, fetchConfig, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["ApprovalForAll(address,address,bool)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, fetchConfig, preprocessHandler);
    }
    onEventTransfer(handler, filter, fetchConfig, preprocessHandler) {
        if (!filter) {
            filter = templateContract.filters["Transfer(address,address,uint256)"](null, null, null);
        }
        return super.onEthEvent(handler, filter, fetchConfig, preprocessHandler);
    }
}
export function getERC721Contract(chainId, address) {
    let contract = getContractByABI("ERC721", address, chainId);
    if (!contract) {
        const rawContract = ERC721__factory.connect(address, getProvider(chainId));
        contract = new ERC721ContractView(rawContract);
        addContractByABI("ERC721", address, chainId, contract);
    }
    return contract;
}
export function getERC721ContractOnContext(context, address) {
    const view = getERC721Contract(context.getChainId(), address);
    const boundView = new ERC721BoundContractView(address, view);
    boundView.context = context;
    if (boundView.callStatic) {
        boundView.callStatic.context = context;
    }
    return boundView;
}
//# sourceMappingURL=erc721-processor.js.map