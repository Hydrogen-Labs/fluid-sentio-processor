import { ListStateStorage } from '@sentio/runtime';
import { BTCBlockContext, BTCContext } from './types.js';
import { ServerError, Status } from 'nice-grpc';
export class BTCProcessorState extends ListStateStorage {
    static INSTANCE = new BTCProcessorState();
}
export class BTCProcessor {
    config;
    callHandlers = [];
    blockHandlers = [];
    constructor(config) {
        this.config = config;
    }
    static bind(config) {
        const processor = new BTCProcessor(config);
        BTCProcessorState.INSTANCE.addValue(processor);
        return processor;
    }
    onTransaction(handler, filter) {
        const callHandler = {
            handler: async (call) => {
                const tx = call.transaction;
                const ctx = new BTCContext(this.config.chainId, this.config.name ?? this.config.address ?? '', tx, this.config.address ?? tx.vout?.[0]?.scriptPubKey?.address);
                await handler(tx, ctx);
                return ctx.stopAndGetResult();
            },
            filter
        };
        this.callHandlers.push(callHandler);
        return this;
    }
    onInterval(handler, timeInterval, blockInterval, fetchConfig) {
        if (timeInterval) {
            if (timeInterval.backfillInterval < timeInterval.recentInterval) {
                timeInterval.backfillInterval = timeInterval.recentInterval;
            }
        }
        const processor = this;
        this.blockHandlers.push({
            blockInterval,
            timeIntervalInMinutes: timeInterval,
            handler: async function (data) {
                const header = data.block;
                if (!header) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Block is empty');
                }
                const block = {
                    ...header
                };
                if (fetchConfig?.getTransactions) {
                    block.tx = header.rawtx?.map((tx) => tx);
                }
                const ctx = new BTCBlockContext(processor.config.chainId, processor.config.name ?? processor.config.address ?? '', block, processor.config.address);
                await handler(block, ctx);
                return ctx.stopAndGetResult();
            },
            fetchConfig
        });
        return this;
    }
    onBlockInterval(handler, blockInterval = 250, backfillBlockInterval = 1000, fetchConfig) {
        return this.onInterval(handler, undefined, {
            recentInterval: blockInterval,
            backfillInterval: backfillBlockInterval
        }, fetchConfig);
    }
    onTimeInterval(handler, timeIntervalInMinutes = 60, backfillTimeIntervalInMinutes = 240, fetchConfig) {
        return this.onInterval(handler, { recentInterval: timeIntervalInMinutes, backfillInterval: backfillTimeIntervalInMinutes }, undefined, fetchConfig);
    }
}
//# sourceMappingURL=btc-processor.js.map