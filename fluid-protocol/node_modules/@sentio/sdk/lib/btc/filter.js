import { BTCTransactionFilter_Condition, BTCTransactionFilter_Filter, BTCTransactionFilter_Filters, BTCTransactionFilter_VinFilter, BTCTransactionFilter_VOutFilter } from '@sentio/protos';
import { serializeRichValue } from '../store/util.js';
import { BigDecimal } from '@sentio/bigdecimal';
function toVinFilter(inputFilter) {
    if (inputFilter) {
        const ret = BTCTransactionFilter_VinFilter.create();
        const filters = [];
        const vouts = [];
        const txs = [];
        for (const f of Array.isArray(inputFilter) ? inputFilter : [inputFilter]) {
            const { preVOut, preTransaction, ...rest } = f;
            filters.push(rest);
            if (preVOut) {
                vouts.push(preVOut);
            }
            if (preTransaction) {
                txs.push(preTransaction);
            }
        }
        ret.filters = BTCTransactionFilter_Filters.create({
            filters: convertFilters(filters)
        });
        if (vouts.length > 0) {
            const voutFilters = convertFilters(vouts);
            if (voutFilters && voutFilters.length > 0) {
                ret.preVOut = voutFilters[0];
            }
        }
        if (txs.length > 0) {
            ret.preTransaction = filters2Proto(txs)?.[0];
        }
        return ret;
    }
    return undefined;
}
function toVOutFilter(outputFilter) {
    if (outputFilter) {
        const ret = BTCTransactionFilter_VOutFilter.create();
        const filters = Array.isArray(outputFilter) ? outputFilter : [outputFilter];
        ret.filters = BTCTransactionFilter_Filters.create({
            filters: convertFilters(filters)
        });
        return ret;
    }
    return undefined;
}
export function filters2Proto(filter) {
    const filters = Array.isArray(filter) ? filter : [filter];
    return filters.map((f) => {
        return {
            filter: convertFilters(f.filter),
            inputFilter: toVinFilter(f.inputFilter),
            outputFilter: toVOutFilter(f.outputFilter)
        };
    });
}
function toCondition(value) {
    const ret = BTCTransactionFilter_Condition.create();
    if (value instanceof Date) {
        ret.eq = serializeRichValue(value);
    }
    if (typeof value === 'number') {
        ret.eq = serializeRichValue(value);
    }
    if (typeof value === 'string') {
        ret.eq = serializeRichValue(value);
    }
    if (value instanceof BigDecimal) {
        ret.eq = serializeRichValue(value);
    }
    if (typeof value === 'bigint') {
        ret.eq = serializeRichValue(value);
    }
    if (typeof value === 'boolean') {
        ret.eq = serializeRichValue(value);
    }
    if (Array.isArray(value)) {
        ret.in = { values: value.map((v) => serializeRichValue(v)) };
    }
    for (const [k, v] of Object.entries(value)) {
        switch (k) {
            case 'prefix':
            case 'contains':
            case 'notContains':
                ret[k] = v.toString();
                break;
            case 'length':
                ret['lengthEq'] = v;
                break;
            case 'lengthGt':
            case 'lengthLt':
                ret[k] = v;
                break;
            case 'hasAny':
            case 'hasAll':
            case 'in':
                ret[k] = { values: v.map((v) => serializeRichValue(v)) };
                break;
            case 'eq':
            case 'gt':
            case 'gte':
            case 'lt':
            case 'lte':
            case 'ne':
                ret[k] = serializeRichValue(v);
                break;
            default:
                throw new Error('Unknown condition op: ' + k);
        }
    }
    return ret;
}
function convertFilters(filters) {
    if (filters && filters.length > 0) {
        const ret = [];
        for (const filter of filters) {
            const f = BTCTransactionFilter_Filter.create();
            for (const [key, value] of Object.entries(filter)) {
                f.conditions[key] = toCondition(value);
            }
            ret.push(f);
        }
        return ret;
    }
    return [];
}
//# sourceMappingURL=filter.js.map