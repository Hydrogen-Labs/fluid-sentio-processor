import { ListStateStorage } from '@sentio/runtime';
import { BlockHandler, BTCBlock, BTCBlockContext, BTCContext, BTCOnIntervalFetchConfig, Transaction } from './types.js';
import { Data_BTCTransaction, HandleInterval, ProcessResult } from '@sentio/protos';
import { TransactionFilters } from './filter.js';
import { PromiseOrVoid } from '../core/index.js';
export declare class BTCProcessorState extends ListStateStorage<BTCProcessor> {
    static INSTANCE: BTCProcessorState;
}
export declare class BTCProcessor {
    readonly config: BTCProcessorConfig;
    callHandlers: CallHandler<Data_BTCTransaction>[];
    blockHandlers: BlockHandler[];
    constructor(config: BTCProcessorConfig);
    static bind(config: BTCProcessorConfig): BTCProcessor;
    onTransaction(handler: (transaction: Transaction, ctx: BTCContext) => void | Promise<void>, filter?: TransactionFilters): this;
    onInterval(handler: (block: BTCBlock, ctx: BTCBlockContext) => PromiseOrVoid, timeInterval: HandleInterval | undefined, blockInterval: HandleInterval | undefined, fetchConfig?: BTCOnIntervalFetchConfig): this;
    onBlockInterval(handler: (block: BTCBlock, ctx: BTCBlockContext) => PromiseOrVoid, blockInterval?: number, backfillBlockInterval?: number, fetchConfig?: BTCOnIntervalFetchConfig): this;
    onTimeInterval(handler: (block: BTCBlock, ctx: BTCBlockContext) => PromiseOrVoid, timeIntervalInMinutes?: number, backfillTimeIntervalInMinutes?: number, fetchConfig?: BTCOnIntervalFetchConfig): this;
}
interface BTCProcessorConfig {
    chainId: string;
    name?: string;
    address?: string;
    startBlock?: bigint;
    endBlock?: bigint;
}
export type CallHandler<T> = {
    handler: (call: T) => Promise<ProcessResult>;
    filter?: TransactionFilters;
};
export {};
//# sourceMappingURL=btc-processor.d.ts.map