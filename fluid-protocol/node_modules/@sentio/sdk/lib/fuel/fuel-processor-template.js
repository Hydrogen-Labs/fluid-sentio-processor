import { ListStateStorage } from '@sentio/runtime';
import { TemplateInstanceState } from '../core/template.js';
import { DEFAULT_FUEL_FETCH_CONFIG } from './transaction.js';
import { getOptionsSignature } from './fuel-processor.js';
export class FuelProcessorTemplateProcessorState extends ListStateStorage {
    static INSTANCE = new FuelProcessorTemplateProcessorState();
}
export class FuelBaseProcessorTemplate {
    id;
    binds = new Set();
    blockHandlers = [];
    logHandlers = [];
    transactionHandlers = [];
    constructor() {
        this.id = FuelProcessorTemplateProcessorState.INSTANCE.getValues().length;
        FuelProcessorTemplateProcessorState.INSTANCE.addValue(this);
    }
    /**
     * Bind template using {@param options}, using {@param ctx}'s network value if not provided in the option
     * @param options
     * @param ctx
     */
    bind(options, ctx) {
        const sig = getOptionsSignature({
            address: options.address,
            chainId: ctx.chainId
        });
        if (this.binds.has(sig)) {
            console.log(`Same address can be bind to one template only once, ignore duplicate bind: ${sig}`);
            return;
        }
        this.binds.add(sig);
        const processor = this.bindInternal({ ...options, chainId: ctx.chainId });
        for (const eh of this.logHandlers) {
            processor.onLog(eh.logIdFilter, eh.handler);
        }
        for (const bh of this.blockHandlers) {
            processor.onInterval(bh.handler, bh.timeIntervalInMinutes, bh.blockInterval);
        }
        for (const th of this.transactionHandlers) {
            processor.onTransaction(th.handler);
        }
        const instance = {
            templateId: this.id,
            contract: {
                address: options.address,
                name: options.name || '',
                chainId: ctx.chainId,
                abi: ''
            },
            startBlock: BigInt(options.startBlock || 0),
            endBlock: BigInt(options.endBlock || 0),
            baseLabels: {}
            // baseLabels: options.baseLabels
        };
        TemplateInstanceState.INSTANCE.addValue(instance);
        ctx.update({
            states: {
                configUpdated: true
            }
        });
    }
    onLog(logIdFilter, handler
    // fetchConfig?: Partial<FuelFetchConfig>
    ) {
        this.logHandlers.push({
            logIdFilter,
            handler
            // fetchConfig: { ...fetchConfig}
        });
        return this;
    }
    onBlockInterval(handler, blockInterval = 1000, backfillBlockInterval = 4000
    // fetchConfig?: Partial<FuelFetchConfig>
    ) {
        return this.onInterval(handler, undefined, {
            recentInterval: blockInterval,
            backfillInterval: backfillBlockInterval
        }
        // fetchConfig
        );
    }
    onTimeInterval(handler, timeIntervalInMinutes = 60, backfillBlockInterval = 240
    // fetchConfig?: Partial<FuelFetchConfig>
    ) {
        return this.onInterval(handler, { recentInterval: timeIntervalInMinutes, backfillInterval: backfillBlockInterval }, undefined
        // fetchConfig
        );
    }
    onInterval(handler, timeInterval, blockInterval
    // fetchConfig?: FuelFetchConfig
    ) {
        this.blockHandlers.push({
            handler,
            timeIntervalInMinutes: timeInterval,
            blockInterval
            // fetchConfig: { ...fetchConfig }
        });
        return this;
    }
    onTransaction(handler, config = DEFAULT_FUEL_FETCH_CONFIG) {
        this.transactionHandlers.push({
            handler,
            fetchConfig: config
        });
        return this;
    }
}
//# sourceMappingURL=fuel-processor-template.js.map