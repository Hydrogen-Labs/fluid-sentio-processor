import { FuelCall, FuelContext, FuelContractContext } from './context.js';
import { bn, Contract, Interface } from 'fuels';
import { getProvider } from './network.js';
import { decodeFuelTransactionWithAbi, DEFAULT_FUEL_FETCH_CONFIG } from './transaction.js';
import { FuelProcessorState } from './types.js';
import { mergeProcessResults } from '@sentio/runtime';
import { ServerError, Status } from 'nice-grpc';
export class FuelProcessor {
    config;
    callHandlers = [];
    blockHandlers = [];
    provider;
    contract;
    static bind(config) {
        const processor = new FuelProcessor(config);
        addFuelProcessor(config, processor);
        return processor;
    }
    constructor(config) {
        this.config = config;
    }
    latestGasPrice;
    async configure() {
        this.provider = await getProvider(this.config.chainId);
        this.provider.getLatestGasPrice = async () => {
            // avoid flood the endpoint, cache the latest gas price
            if (this.latestGasPrice) {
                return bn(this.latestGasPrice);
            }
            const { latestGasPrice } = await this.provider.operations.getLatestGasPrice();
            this.latestGasPrice = latestGasPrice?.gasPrice;
            return bn(latestGasPrice.gasPrice);
        };
        this.contract = new Contract(this.config.address, this.config.abi, this.provider);
    }
    onTransaction(handler, config = DEFAULT_FUEL_FETCH_CONFIG) {
        const callHandler = {
            handler: async (call) => {
                const abiMap = this.config.abi
                    ? {
                        [this.config.address]: this.config.abi
                    }
                    : {};
                const tx = await decodeFuelTransactionWithAbi(call.transaction, abiMap, this.provider);
                const ctx = new FuelContractContext(this.config.chainId, this.contract, this.config.address, this.config.name ?? this.config.address, call.timestamp || new Date(0), tx, null);
                await handler(tx, ctx);
                return ctx.stopAndGetResult();
            },
            fetchConfig: {
                filters: [],
                ...config
            }
        };
        this.callHandlers.push(callHandler);
        return this;
    }
    // hide onCall for now
    onCall(nameFilter, handler, config = DEFAULT_FUEL_FETCH_CONFIG) {
        const names = new Set(Array.isArray(nameFilter) ? nameFilter : [nameFilter]);
        if (!this.config.abi) {
            throw new Error('ABI must be provided to use onCall');
        }
        const abi = this.config.abi;
        const filters = {};
        const abiInterface = new Interface(abi);
        for (const name of names) {
            try {
                const func = abiInterface.functions[name];
                const filter = bn(func.selector, 'hex').toString();
                filters[func.name] = {
                    function: filter,
                    includeFailed: !!config.includeFailed
                };
            }
            catch (e) {
                console.error(e);
            }
        }
        const callHandler = {
            handler: async (call) => {
                try {
                    // const contract = new Contract(this.config.address, abi, this.provider)
                    const gqlTransaction = call.transaction;
                    const tx = await decodeFuelTransactionWithAbi(gqlTransaction, { [this.config.address]: abi }, this.provider);
                    const ctx = new FuelContext(this.config.chainId, this.config.address, this.config.name ?? this.config.address, call.timestamp || new Date(0), tx, null);
                    for (const op of tx.operations) {
                        for (const call of op.calls || []) {
                            if (names.has(call.functionName)) {
                                const fn = this.contract.functions[call.functionName];
                                const args = Object.values(call.argumentsProvided || {});
                                const scope = fn(...args);
                                const invocationResult = new FuelCall(scope, tx, false, call.argumentsProvided, tx.logs);
                                await handler(invocationResult, ctx);
                            }
                        }
                    }
                    return ctx.stopAndGetResult();
                }
                catch (e) {
                    console.error(e);
                    return {
                        gauges: [],
                        counters: [],
                        events: [],
                        exports: [],
                        states: {
                            configUpdated: false
                        }
                    };
                }
            },
            fetchConfig: {
                filters: Object.values(filters)
            }
        };
        this.callHandlers.push(callHandler);
        return this;
    }
    onLog(logIdFilter, handler) {
        const logIds = new Set(Array.isArray(logIdFilter) ? logIdFilter : [logIdFilter]);
        const callHandler = {
            handler: async (call) => {
                try {
                    const gqlTransaction = call.transaction;
                    const tx = await decodeFuelTransactionWithAbi(gqlTransaction, { [this.config.address]: this.config.abi }, this.provider);
                    const results = [];
                    const logs = (tx.logs || []).filter((log) => logIds.has(log.logId));
                    for (const log of logs) {
                        const ctx = new FuelContractContext(this.config.chainId, this.contract, this.config.address, this.config.name ?? this.config.address, call.timestamp || new Date(0), tx, null);
                        ctx.setLogIndex(log.receiptIndex);
                        await handler(log, ctx);
                        results.push(ctx.stopAndGetResult());
                    }
                    return mergeProcessResults(results);
                }
                catch (e) {
                    console.error(e);
                    return {
                        gauges: [],
                        counters: [],
                        events: [],
                        exports: [],
                        states: {
                            configUpdated: false
                        }
                    };
                }
            },
            logConfig: {
                logIds: Array.from(logIds)
            }
        };
        this.callHandlers.push(callHandler);
        return this;
    }
    onInterval(handler, timeInterval, blockInterval
    // fetchConfig: Partial<FuelFetchConfig> | undefined
    ) {
        if (timeInterval) {
            if (timeInterval.backfillInterval < timeInterval.recentInterval) {
                timeInterval.backfillInterval = timeInterval.recentInterval;
            }
        }
        const processor = this;
        this.blockHandlers.push({
            blockInterval,
            timeIntervalInMinutes: timeInterval,
            handler: async function (data) {
                const header = data.block;
                if (!header) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'Block is empty');
                }
                const block = {
                    id: header.id,
                    height: bn(header.height),
                    time: header.time,
                    header: {
                        applicationHash: header.applicationHash,
                        daHeight: bn(header.daHeight),
                        eventInboxRoot: header.eventInboxRoot,
                        messageOutboxRoot: header.messageOutboxRoot,
                        prevRoot: header.prevRoot,
                        stateTransitionBytecodeVersion: header.stateTransitionBytecodeVersion,
                        transactionsCount: header.transactionsCount,
                        transactionsRoot: header.transactionsRoot
                    }
                };
                const ctx = new FuelContractContext(processor.config.chainId, processor.contract, processor.config.address, processor.config.name ?? processor.config.address, data.timestamp || new Date(0), null, block);
                await handler(block, ctx);
                return ctx.stopAndGetResult();
            }
        });
        return this;
    }
    onBlockInterval(handler, blockInterval = 250, backfillBlockInterval = 1000
    // fetchConfig?: Partial<FuelFetchConfig>
    ) {
        return this.onInterval(handler, undefined, {
            recentInterval: blockInterval,
            backfillInterval: backfillBlockInterval
        }
        // fetchConfig,
        );
    }
    onTimeInterval(handler, timeIntervalInMinutes = 60, backfillTimeIntervalInMinutes = 240
    // fetchConfig?: Partial<FuelFetchConfig>,
    ) {
        return this.onInterval(handler, { recentInterval: timeIntervalInMinutes, backfillInterval: backfillTimeIntervalInMinutes }, undefined
        // fetchConfig
        );
    }
}
export function getOptionsSignature(opts) {
    const sig = [opts.address];
    if (opts.chainId) {
        sig.push(opts.chainId);
    }
    if (opts.name) {
        sig.push(opts.name);
    }
    if (opts.startBlock) {
        sig.push(opts.startBlock.toString());
    }
    if (opts.endBlock) {
        sig.push(opts.endBlock.toString());
    }
    return sig.join('_');
}
// Dedup processor that bind multiple times
export function getFuelProcessor(opts) {
    const sig = getOptionsSignature(opts);
    return FuelProcessorState.INSTANCE.getValue(sig);
}
export function addFuelProcessor(opts, processor) {
    const sig = getOptionsSignature(opts);
    FuelProcessorState.INSTANCE.getOrSetValue(sig, processor);
}
//# sourceMappingURL=fuel-processor.js.map