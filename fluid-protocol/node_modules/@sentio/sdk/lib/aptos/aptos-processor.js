import { defaultMoveCoder } from './index.js';
import { AptosNetwork } from './network.js';
import { AptosContext, AptosResourcesContext } from './context.js';
import { ListStateStorage, mergeProcessResults } from '@sentio/runtime';
import { MoveFetchConfig } from '@sentio/protos';
import { ServerError, Status } from 'nice-grpc';
import { accountTypeString, parseMoveType } from '../move/index.js';
const DEFAULT_FETCH_CONFIG = {
    resourceChanges: false,
    allEvents: true,
    inputs: false,
    // for backward compatibility
    supportMultisigFunc: true
};
export const DEFAULT_RESOURCE_FETCH_CONFIG = {
    owned: true
};
class ResourceHandlder {
    type;
    versionInterval;
    timeIntervalInMinutes;
    handler;
    fetchConfig;
}
export class AptosProcessorState extends ListStateStorage {
    static INSTANCE = new AptosProcessorState();
}
export class AptosBaseProcessor {
    moduleName;
    config;
    eventHandlers = [];
    callHandlers = [];
    resourceHandlers = [];
    coder;
    constructor(moduleName, options) {
        this.moduleName = moduleName;
        this.config = configure(options);
        AptosProcessorState.INSTANCE.addValue(this);
        this.coder = defaultMoveCoder(this.config.network);
        // this.loadTypes(this.coder)
    }
    onMoveEvent(handler, filter, fetchConfig) {
        let _filters = [];
        const _fetchConfig = MoveFetchConfig.fromPartial({ ...DEFAULT_FETCH_CONFIG, ...fetchConfig });
        if (Array.isArray(filter)) {
            _filters = filter;
        }
        else {
            _filters.push(filter);
        }
        // const moduleName = this.moduleName
        const processor = this;
        const allEventType = new Set(_filters.map((f) => accountTypeString(processor.config.address) + '::' + f.type));
        this.eventHandlers.push({
            handler: async function (data) {
                if (!data.transaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'event is null');
                }
                const txn = data.transaction;
                if (!txn.events.length) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'no event in the transactions');
                }
                const processResults = [];
                for (const [idx, evt] of txn.events.entries()) {
                    const typeQname = parseMoveType(evt.type).qname;
                    if (!allEventType.has(typeQname)) {
                        continue;
                    }
                    const ctx = new AptosContext(processor.moduleName, processor.config.network, processor.config.address, BigInt(txn.version), txn, idx, processor.config.baseLabels);
                    const decoded = await processor.coder.decodeEvent(evt);
                    await handler(decoded || evt, ctx);
                    processResults.push(ctx.stopAndGetResult());
                }
                return mergeProcessResults(processResults);
            },
            filters: _filters,
            fetchConfig: _fetchConfig
        });
        return this;
    }
    onEntryFunctionCall(handler, filter, fetchConfig) {
        let _filters = [];
        const _fetchConfig = MoveFetchConfig.fromPartial({ ...DEFAULT_FETCH_CONFIG, ...fetchConfig });
        if (Array.isArray(filter)) {
            _filters = filter;
        }
        else {
            _filters.push(filter);
        }
        // const address = this.config.address
        // const moduleName = this.moduleName
        const processor = this;
        this.callHandlers.push({
            handler: async function (data) {
                if (!data.transaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'call is null');
                }
                const tx = data.transaction;
                const ctx = new AptosContext(processor.moduleName, processor.config.network, processor.config.address, BigInt(tx.version), tx, 0, processor.config.baseLabels);
                if (tx) {
                    let payload = tx.payload;
                    if (payload.type === 'multisig_payload') {
                        payload = payload.transaction_payload ?? payload;
                    }
                    const decoded = await processor.coder.decodeFunctionPayload(payload);
                    await handler(decoded, ctx);
                }
                return ctx.stopAndGetResult();
            },
            filters: _filters,
            fetchConfig: _fetchConfig
        });
        return this;
    }
    onTransaction(handler, includedFailed = false, fetchConfig) {
        const _fetchConfig = MoveFetchConfig.fromPartial({ ...DEFAULT_FETCH_CONFIG, ...fetchConfig });
        const processor = this;
        this.callHandlers.push({
            handler: async function (data) {
                if (!data.transaction) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'call is null');
                }
                const call = data.transaction;
                const ctx = new AptosContext(processor.moduleName, processor.config.network, processor.config.address, BigInt(data.transaction.version), call, 0, processor.config.baseLabels);
                await handler(call, ctx);
                return ctx.stopAndGetResult();
            },
            filters: [{ function: '', includeFailed: includedFailed }],
            fetchConfig: _fetchConfig
        });
        return this;
    }
    onEvent(handler, fetchConfig) {
        this.onMoveEvent(handler, { type: '' }, fetchConfig);
        return this;
    }
    onResourceChange(handler, type) {
        const processor = this;
        this.resourceHandlers.push({
            handler: async function (data) {
                if (!data.resources || !data.version) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'resource is null');
                }
                const resources = data.resources;
                const timestamp = Number(data.timestampMicros);
                const ctx = new AptosResourcesContext(processor.config.network, processor.config.address, data.version, timestamp, processor.config.baseLabels);
                await handler(resources, ctx);
                return ctx.stopAndGetResult();
            },
            type
        });
        return this;
    }
    getChainId() {
        return this.config.network;
    }
}
export class AptosModulesProcessor extends AptosBaseProcessor {
    constructor(options) {
        super('*', options);
    }
    static bind(options) {
        return new AptosModulesProcessor(options);
    }
}
export class AptosResourceProcessorState extends ListStateStorage {
    static INSTANCE = new AptosResourceProcessorState();
}
export class AptosResourcesProcessor {
    config;
    resourcesHandlers = [];
    static bind(options) {
        return new AptosResourcesProcessor(options);
    }
    constructor(options) {
        this.config = configure(options);
        AptosResourceProcessorState.INSTANCE.addValue(this);
    }
    getChainId() {
        return this.config.network;
    }
    onInterval(handler, timeInterval, versionInterval, type, fetchConfig) {
        const processor = this;
        this.resourcesHandlers.push({
            handler: async function (data) {
                if (data.timestampMicros > Number.MAX_SAFE_INTEGER) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'timestamp is too large');
                }
                const timestamp = Number(data.timestampMicros);
                const ctx = new AptosResourcesContext(processor.config.network, processor.config.address, data.version, timestamp, processor.config.baseLabels);
                await handler(data.resources, ctx);
                return ctx.stopAndGetResult();
            },
            timeIntervalInMinutes: timeInterval,
            versionInterval: versionInterval,
            type: type,
            fetchConfig: { ...DEFAULT_RESOURCE_FETCH_CONFIG, ...fetchConfig }
        });
        return this;
    }
    onTimeInterval(handler, timeIntervalInMinutes = 60, backfillTimeIntervalInMinutes = 240, type, fetchConfig) {
        return this.onInterval(handler, {
            recentInterval: timeIntervalInMinutes,
            backfillInterval: backfillTimeIntervalInMinutes
        }, undefined, type, fetchConfig);
    }
    onVersionInterval(handler, versionInterval = 100000, backfillVersionInterval = 400000, typePrefix, fetchConfig) {
        return this.onInterval(handler, undefined, { recentInterval: versionInterval, backfillInterval: backfillVersionInterval }, typePrefix, fetchConfig);
    }
    onResourceChange(handler, typeOrPrefix) {
        const processor = this;
        this.resourcesHandlers.push({
            fetchConfig: DEFAULT_RESOURCE_FETCH_CONFIG,
            handler: async function (data) {
                const timestamp = Number(data.timestampMicros);
                if (!data.resources || !data.version) {
                    throw new ServerError(Status.INVALID_ARGUMENT, 'resource is null');
                }
                const resources = data.resources;
                const ctx = new AptosResourcesContext(processor.config.network, processor.config.address, data.version, timestamp, processor.config.baseLabels);
                await handler(resources, ctx);
                return ctx.stopAndGetResult();
            },
            type: typeOrPrefix
        });
        return this;
    }
}
function configure(options) {
    let startVersion = 0n;
    if (options.startVersion !== undefined) {
        if (typeof options.startVersion === 'number') {
            startVersion = BigInt(options.startVersion);
        }
        else {
            startVersion = options.startVersion;
        }
    }
    return {
        startVersion: startVersion,
        address: options.address === '*' ? '*' : accountTypeString(options.address), // aptos don't use address string in api, so only use type string
        network: options.network || AptosNetwork.MAIN_NET,
        baseLabels: options.baseLabels
    };
}
//# sourceMappingURL=aptos-processor.js.map