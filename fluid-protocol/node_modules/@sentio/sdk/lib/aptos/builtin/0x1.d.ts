import { TypeDescriptor } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/aptos";
import { CallFilter, MoveFetchConfig } from "@sentio/sdk/move";
import { AptosBindOptions, AptosBaseProcessor, TypedFunctionPayload, AptosContext } from "@sentio/sdk/aptos";
import { MoveAddressType } from "@aptos-labs/ts-sdk";
export declare class acl extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): acl;
    onEventACL(func: (event: acl.ACLInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): acl;
}
export declare namespace acl {
    interface ACL {
        list: MoveAddressType[];
    }
    namespace ACL {
        const TYPE_QNAME = "0x1::acl::ACL";
        function type(): TypeDescriptor<ACL>;
    }
    interface ACLInstance extends TypedEventInstance<ACL> {
        data_decoded: ACL;
        type_arguments: [];
    }
}
export declare class any_ extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): any_;
    onEventAny(func: (event: any_.AnyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): any_;
}
export declare namespace any_ {
    interface Any {
        type_name: string;
        data: string;
    }
    namespace Any {
        const TYPE_QNAME = "0x1::any::Any";
        function type(): TypeDescriptor<Any>;
    }
    interface AnyInstance extends TypedEventInstance<Any> {
        data_decoded: Any;
        type_arguments: [];
    }
}
export declare namespace bcs { }
export declare class dkg extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): dkg;
    onEventDKGSessionMetadata(func: (event: dkg.DKGSessionMetadataInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): dkg;
    onEventDKGSessionState(func: (event: dkg.DKGSessionStateInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): dkg;
    onEventDKGStartEvent(func: (event: dkg.DKGStartEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): dkg;
}
export declare namespace dkg {
    interface DKGSessionMetadata {
        dealer_epoch: bigint;
        randomness_config: randomness_config.RandomnessConfig;
        dealer_validator_set: validator_consensus_info.ValidatorConsensusInfo[];
        target_validator_set: validator_consensus_info.ValidatorConsensusInfo[];
    }
    namespace DKGSessionMetadata {
        const TYPE_QNAME = "0x1::dkg::DKGSessionMetadata";
        function type(): TypeDescriptor<DKGSessionMetadata>;
    }
    interface DKGSessionMetadataInstance extends TypedEventInstance<DKGSessionMetadata> {
        data_decoded: DKGSessionMetadata;
        type_arguments: [];
    }
    interface DKGSessionState {
        metadata: dkg.DKGSessionMetadata;
        start_time_us: bigint;
        transcript: string;
    }
    namespace DKGSessionState {
        const TYPE_QNAME = "0x1::dkg::DKGSessionState";
        function type(): TypeDescriptor<DKGSessionState>;
    }
    interface DKGSessionStateInstance extends TypedEventInstance<DKGSessionState> {
        data_decoded: DKGSessionState;
        type_arguments: [];
    }
    interface DKGStartEvent {
        session_metadata: dkg.DKGSessionMetadata;
        start_time_us: bigint;
    }
    namespace DKGStartEvent {
        const TYPE_QNAME = "0x1::dkg::DKGStartEvent";
        function type(): TypeDescriptor<DKGStartEvent>;
    }
    interface DKGStartEventInstance extends TypedEventInstance<DKGStartEvent> {
        data_decoded: DKGStartEvent;
        type_arguments: [];
    }
    interface DKGState {
        last_completed: option.Option<dkg.DKGSessionState>;
        in_progress: option.Option<dkg.DKGSessionState>;
    }
    namespace DKGState {
        const TYPE_QNAME = "0x1::dkg::DKGState";
        function type(): TypeDescriptor<DKGState>;
    }
}
export declare class code extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): code;
    onEntryPublishPackageTxn(func: (call: code.PublishPackageTxnPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): code;
    onEventModuleMetadata(func: (event: code.ModuleMetadataInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): code;
    onEventPackageDep(func: (event: code.PackageDepInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): code;
    onEventPackageMetadata(func: (event: code.PackageMetadataInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): code;
    onEventPackageRegistry(func: (event: code.PackageRegistryInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): code;
    onEventPublishPackage(func: (event: code.PublishPackageInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): code;
    onEventUpgradePolicy(func: (event: code.UpgradePolicyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): code;
}
export declare namespace code {
    interface AllowedDep {
        account: MoveAddressType;
        module_name: string;
    }
    namespace AllowedDep {
        const TYPE_QNAME = "0x1::code::AllowedDep";
        function type(): TypeDescriptor<AllowedDep>;
    }
    interface ModuleMetadata {
        name: string;
        source: string;
        source_map: string;
        extension: option.Option<copyable_any.Any>;
    }
    namespace ModuleMetadata {
        const TYPE_QNAME = "0x1::code::ModuleMetadata";
        function type(): TypeDescriptor<ModuleMetadata>;
    }
    interface ModuleMetadataInstance extends TypedEventInstance<ModuleMetadata> {
        data_decoded: ModuleMetadata;
        type_arguments: [];
    }
    interface PackageDep {
        account: MoveAddressType;
        package_name: string;
    }
    namespace PackageDep {
        const TYPE_QNAME = "0x1::code::PackageDep";
        function type(): TypeDescriptor<PackageDep>;
    }
    interface PackageDepInstance extends TypedEventInstance<PackageDep> {
        data_decoded: PackageDep;
        type_arguments: [];
    }
    interface PackageMetadata {
        name: string;
        upgrade_policy: code.UpgradePolicy;
        upgrade_number: bigint;
        source_digest: string;
        manifest: string;
        modules: code.ModuleMetadata[];
        deps: code.PackageDep[];
        extension: option.Option<copyable_any.Any>;
    }
    namespace PackageMetadata {
        const TYPE_QNAME = "0x1::code::PackageMetadata";
        function type(): TypeDescriptor<PackageMetadata>;
    }
    interface PackageMetadataInstance extends TypedEventInstance<PackageMetadata> {
        data_decoded: PackageMetadata;
        type_arguments: [];
    }
    interface PackageRegistry {
        packages: code.PackageMetadata[];
    }
    namespace PackageRegistry {
        const TYPE_QNAME = "0x1::code::PackageRegistry";
        function type(): TypeDescriptor<PackageRegistry>;
    }
    interface PackageRegistryInstance extends TypedEventInstance<PackageRegistry> {
        data_decoded: PackageRegistry;
        type_arguments: [];
    }
    interface PublishPackage {
        code_address: MoveAddressType;
        is_upgrade: Boolean;
    }
    namespace PublishPackage {
        const TYPE_QNAME = "0x1::code::PublishPackage";
        function type(): TypeDescriptor<PublishPackage>;
    }
    interface PublishPackageInstance extends TypedEventInstance<PublishPackage> {
        data_decoded: PublishPackage;
        type_arguments: [];
    }
    interface UpgradePolicy {
        policy: number;
    }
    namespace UpgradePolicy {
        const TYPE_QNAME = "0x1::code::UpgradePolicy";
        function type(): TypeDescriptor<UpgradePolicy>;
    }
    interface UpgradePolicyInstance extends TypedEventInstance<UpgradePolicy> {
        data_decoded: UpgradePolicy;
        type_arguments: [];
    }
    interface PublishPackageTxnPayload extends TypedFunctionPayload<[string, string[]]> {
        arguments_decoded: [string, string[]];
        type_arguments: [];
    }
}
export declare class coin extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): coin;
    onEntryCreateCoinConversionMap(func: (call: coin.CreateCoinConversionMapPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEntryCreatePairing(func: (call: coin.CreatePairingPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEntryFreezeCoinStore(func: (call: coin.FreezeCoinStorePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEntryMigrateToFungibleStore(func: (call: coin.MigrateToFungibleStorePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEntryTransfer(func: (call: coin.TransferPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEntryUnfreezeCoinStore(func: (call: coin.UnfreezeCoinStorePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEntryUpgradeSupply(func: (call: coin.UpgradeSupplyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEventCoinDeposit(func: (event: coin.CoinDepositInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEventCoinEventHandleDeletion(func: (event: coin.CoinEventHandleDeletionInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEventCoinWithdraw(func: (event: coin.CoinWithdrawInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEventDeposit(func: (event: coin.DepositInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEventDepositEvent(func: (event: coin.DepositEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEventPairCreation(func: (event: coin.PairCreationInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEventWithdraw(func: (event: coin.WithdrawInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): coin;
    onEventWithdrawEvent(func: (event: coin.WithdrawEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): coin;
}
export declare namespace coin {
    interface AggregatableCoin<T0> {
        value: aggregator.Aggregator;
    }
    namespace AggregatableCoin {
        const TYPE_QNAME = "0x1::coin::AggregatableCoin";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<AggregatableCoin<T0>>;
    }
    interface BurnCapability<T0> {
        dummy_field: Boolean;
    }
    namespace BurnCapability {
        const TYPE_QNAME = "0x1::coin::BurnCapability";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<BurnCapability<T0>>;
    }
    interface BurnRefReceipt {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace BurnRefReceipt {
        const TYPE_QNAME = "0x1::coin::BurnRefReceipt";
        function type(): TypeDescriptor<BurnRefReceipt>;
    }
    interface Coin<T0> {
        value: bigint;
    }
    namespace Coin {
        const TYPE_QNAME = "0x1::coin::Coin";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Coin<T0>>;
    }
    interface CoinConversionMap {
        coin_to_fungible_asset_map: table.Table<type_info.TypeInfo, object_.Object<fungible_asset.Metadata>>;
    }
    namespace CoinConversionMap {
        const TYPE_QNAME = "0x1::coin::CoinConversionMap";
        function type(): TypeDescriptor<CoinConversionMap>;
    }
    interface CoinDeposit {
        coin_type: string;
        account: MoveAddressType;
        amount: bigint;
    }
    namespace CoinDeposit {
        const TYPE_QNAME = "0x1::coin::CoinDeposit";
        function type(): TypeDescriptor<CoinDeposit>;
    }
    interface CoinDepositInstance extends TypedEventInstance<CoinDeposit> {
        data_decoded: CoinDeposit;
        type_arguments: [];
    }
    interface CoinEventHandleDeletion {
        event_handle_creation_address: MoveAddressType;
        deleted_deposit_event_handle_creation_number: bigint;
        deleted_withdraw_event_handle_creation_number: bigint;
    }
    namespace CoinEventHandleDeletion {
        const TYPE_QNAME = "0x1::coin::CoinEventHandleDeletion";
        function type(): TypeDescriptor<CoinEventHandleDeletion>;
    }
    interface CoinEventHandleDeletionInstance extends TypedEventInstance<CoinEventHandleDeletion> {
        data_decoded: CoinEventHandleDeletion;
        type_arguments: [];
    }
    interface CoinInfo<T0> {
        name: string;
        symbol: string;
        decimals: number;
        supply: option.Option<optional_aggregator.OptionalAggregator>;
    }
    namespace CoinInfo {
        const TYPE_QNAME = "0x1::coin::CoinInfo";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinInfo<T0>>;
    }
    interface CoinStore<T0> {
        coin: coin.Coin<T0>;
        frozen: Boolean;
        deposit_events: event.EventHandle<coin.DepositEvent>;
        withdraw_events: event.EventHandle<coin.WithdrawEvent>;
    }
    namespace CoinStore {
        const TYPE_QNAME = "0x1::coin::CoinStore";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CoinStore<T0>>;
    }
    interface CoinWithdraw {
        coin_type: string;
        account: MoveAddressType;
        amount: bigint;
    }
    namespace CoinWithdraw {
        const TYPE_QNAME = "0x1::coin::CoinWithdraw";
        function type(): TypeDescriptor<CoinWithdraw>;
    }
    interface CoinWithdrawInstance extends TypedEventInstance<CoinWithdraw> {
        data_decoded: CoinWithdraw;
        type_arguments: [];
    }
    interface Deposit<T0> {
        account: MoveAddressType;
        amount: bigint;
    }
    namespace Deposit {
        const TYPE_QNAME = "0x1::coin::Deposit";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Deposit<T0>>;
    }
    interface DepositInstance extends TypedEventInstance<Deposit<any>> {
        data_decoded: Deposit<any>;
        type_arguments: [string];
    }
    interface DepositEvent {
        amount: bigint;
    }
    namespace DepositEvent {
        const TYPE_QNAME = "0x1::coin::DepositEvent";
        function type(): TypeDescriptor<DepositEvent>;
    }
    interface DepositEventInstance extends TypedEventInstance<DepositEvent> {
        data_decoded: DepositEvent;
        type_arguments: [];
    }
    interface FreezeCapability<T0> {
        dummy_field: Boolean;
    }
    namespace FreezeCapability {
        const TYPE_QNAME = "0x1::coin::FreezeCapability";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<FreezeCapability<T0>>;
    }
    interface MigrationFlag {
        dummy_field: Boolean;
    }
    namespace MigrationFlag {
        const TYPE_QNAME = "0x1::coin::MigrationFlag";
        function type(): TypeDescriptor<MigrationFlag>;
    }
    interface MintCapability<T0> {
        dummy_field: Boolean;
    }
    namespace MintCapability {
        const TYPE_QNAME = "0x1::coin::MintCapability";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<MintCapability<T0>>;
    }
    interface MintRefReceipt {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace MintRefReceipt {
        const TYPE_QNAME = "0x1::coin::MintRefReceipt";
        function type(): TypeDescriptor<MintRefReceipt>;
    }
    interface PairCreation {
        coin_type: type_info.TypeInfo;
        fungible_asset_metadata_address: MoveAddressType;
    }
    namespace PairCreation {
        const TYPE_QNAME = "0x1::coin::PairCreation";
        function type(): TypeDescriptor<PairCreation>;
    }
    interface PairCreationInstance extends TypedEventInstance<PairCreation> {
        data_decoded: PairCreation;
        type_arguments: [];
    }
    interface PairedCoinType {
        type: type_info.TypeInfo;
    }
    namespace PairedCoinType {
        const TYPE_QNAME = "0x1::coin::PairedCoinType";
        function type(): TypeDescriptor<PairedCoinType>;
    }
    interface PairedFungibleAssetRefs {
        mint_ref_opt: option.Option<fungible_asset.MintRef>;
        transfer_ref_opt: option.Option<fungible_asset.TransferRef>;
        burn_ref_opt: option.Option<fungible_asset.BurnRef>;
    }
    namespace PairedFungibleAssetRefs {
        const TYPE_QNAME = "0x1::coin::PairedFungibleAssetRefs";
        function type(): TypeDescriptor<PairedFungibleAssetRefs>;
    }
    interface SupplyConfig {
        allow_upgrades: Boolean;
    }
    namespace SupplyConfig {
        const TYPE_QNAME = "0x1::coin::SupplyConfig";
        function type(): TypeDescriptor<SupplyConfig>;
    }
    interface TransferRefReceipt {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace TransferRefReceipt {
        const TYPE_QNAME = "0x1::coin::TransferRefReceipt";
        function type(): TypeDescriptor<TransferRefReceipt>;
    }
    interface Withdraw<T0> {
        account: MoveAddressType;
        amount: bigint;
    }
    namespace Withdraw {
        const TYPE_QNAME = "0x1::coin::Withdraw";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Withdraw<T0>>;
    }
    interface WithdrawInstance extends TypedEventInstance<Withdraw<any>> {
        data_decoded: Withdraw<any>;
        type_arguments: [string];
    }
    interface WithdrawEvent {
        amount: bigint;
    }
    namespace WithdrawEvent {
        const TYPE_QNAME = "0x1::coin::WithdrawEvent";
        function type(): TypeDescriptor<WithdrawEvent>;
    }
    interface WithdrawEventInstance extends TypedEventInstance<WithdrawEvent> {
        data_decoded: WithdrawEvent;
        type_arguments: [];
    }
    interface CreateCoinConversionMapPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface CreatePairingPayload<T0 = any> extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [string];
    }
    interface FreezeCoinStorePayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [string];
    }
    interface MigrateToFungibleStorePayload<T0 = any> extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [string];
    }
    interface TransferPayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [string];
    }
    interface UnfreezeCoinStorePayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [string];
    }
    interface UpgradeSupplyPayload<T0 = any> extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [string];
    }
}
export declare class guid extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): guid;
    onEventGUID(func: (event: guid.GUIDInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): guid;
    onEventID(func: (event: guid.IDInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): guid;
}
export declare namespace guid {
    interface GUID {
        id: guid.ID;
    }
    namespace GUID {
        const TYPE_QNAME = "0x1::guid::GUID";
        function type(): TypeDescriptor<GUID>;
    }
    interface GUIDInstance extends TypedEventInstance<GUID> {
        data_decoded: GUID;
        type_arguments: [];
    }
    interface ID {
        creation_num: bigint;
        addr: MoveAddressType;
    }
    namespace ID {
        const TYPE_QNAME = "0x1::guid::ID";
        function type(): TypeDescriptor<ID>;
    }
    interface IDInstance extends TypedEventInstance<ID> {
        data_decoded: ID;
        type_arguments: [];
    }
}
export declare namespace hash { }
export declare class jwks extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): jwks;
    onEventAllProvidersJWKs(func: (event: jwks.AllProvidersJWKsInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventJWK(func: (event: jwks.JWKInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventOIDCProvider(func: (event: jwks.OIDCProviderInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventObservedJWKs(func: (event: jwks.ObservedJWKsInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventObservedJWKsUpdated(func: (event: jwks.ObservedJWKsUpdatedInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventPatch(func: (event: jwks.PatchInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventPatchRemoveAll(func: (event: jwks.PatchRemoveAllInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventPatchRemoveIssuer(func: (event: jwks.PatchRemoveIssuerInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventPatchRemoveJWK(func: (event: jwks.PatchRemoveJWKInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventPatchUpsertJWK(func: (event: jwks.PatchUpsertJWKInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventProviderJWKs(func: (event: jwks.ProviderJWKsInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventRSA_JWK(func: (event: jwks.RSA_JWKInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventSupportedOIDCProviders(func: (event: jwks.SupportedOIDCProvidersInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
    onEventUnsupportedJWK(func: (event: jwks.UnsupportedJWKInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwks;
}
export declare namespace jwks {
    interface AllProvidersJWKs {
        entries: jwks.ProviderJWKs[];
    }
    namespace AllProvidersJWKs {
        const TYPE_QNAME = "0x1::jwks::AllProvidersJWKs";
        function type(): TypeDescriptor<AllProvidersJWKs>;
    }
    interface AllProvidersJWKsInstance extends TypedEventInstance<AllProvidersJWKs> {
        data_decoded: AllProvidersJWKs;
        type_arguments: [];
    }
    interface JWK {
        variant: copyable_any.Any;
    }
    namespace JWK {
        const TYPE_QNAME = "0x1::jwks::JWK";
        function type(): TypeDescriptor<JWK>;
    }
    interface JWKInstance extends TypedEventInstance<JWK> {
        data_decoded: JWK;
        type_arguments: [];
    }
    interface OIDCProvider {
        name: string;
        config_url: string;
    }
    namespace OIDCProvider {
        const TYPE_QNAME = "0x1::jwks::OIDCProvider";
        function type(): TypeDescriptor<OIDCProvider>;
    }
    interface OIDCProviderInstance extends TypedEventInstance<OIDCProvider> {
        data_decoded: OIDCProvider;
        type_arguments: [];
    }
    interface ObservedJWKs {
        jwks: jwks.AllProvidersJWKs;
    }
    namespace ObservedJWKs {
        const TYPE_QNAME = "0x1::jwks::ObservedJWKs";
        function type(): TypeDescriptor<ObservedJWKs>;
    }
    interface ObservedJWKsInstance extends TypedEventInstance<ObservedJWKs> {
        data_decoded: ObservedJWKs;
        type_arguments: [];
    }
    interface ObservedJWKsUpdated {
        epoch: bigint;
        jwks: jwks.AllProvidersJWKs;
    }
    namespace ObservedJWKsUpdated {
        const TYPE_QNAME = "0x1::jwks::ObservedJWKsUpdated";
        function type(): TypeDescriptor<ObservedJWKsUpdated>;
    }
    interface ObservedJWKsUpdatedInstance extends TypedEventInstance<ObservedJWKsUpdated> {
        data_decoded: ObservedJWKsUpdated;
        type_arguments: [];
    }
    interface Patch {
        variant: copyable_any.Any;
    }
    namespace Patch {
        const TYPE_QNAME = "0x1::jwks::Patch";
        function type(): TypeDescriptor<Patch>;
    }
    interface PatchInstance extends TypedEventInstance<Patch> {
        data_decoded: Patch;
        type_arguments: [];
    }
    interface PatchRemoveAll {
        dummy_field: Boolean;
    }
    namespace PatchRemoveAll {
        const TYPE_QNAME = "0x1::jwks::PatchRemoveAll";
        function type(): TypeDescriptor<PatchRemoveAll>;
    }
    interface PatchRemoveAllInstance extends TypedEventInstance<PatchRemoveAll> {
        data_decoded: PatchRemoveAll;
        type_arguments: [];
    }
    interface PatchRemoveIssuer {
        issuer: string;
    }
    namespace PatchRemoveIssuer {
        const TYPE_QNAME = "0x1::jwks::PatchRemoveIssuer";
        function type(): TypeDescriptor<PatchRemoveIssuer>;
    }
    interface PatchRemoveIssuerInstance extends TypedEventInstance<PatchRemoveIssuer> {
        data_decoded: PatchRemoveIssuer;
        type_arguments: [];
    }
    interface PatchRemoveJWK {
        issuer: string;
        jwk_id: string;
    }
    namespace PatchRemoveJWK {
        const TYPE_QNAME = "0x1::jwks::PatchRemoveJWK";
        function type(): TypeDescriptor<PatchRemoveJWK>;
    }
    interface PatchRemoveJWKInstance extends TypedEventInstance<PatchRemoveJWK> {
        data_decoded: PatchRemoveJWK;
        type_arguments: [];
    }
    interface PatchUpsertJWK {
        issuer: string;
        jwk: jwks.JWK;
    }
    namespace PatchUpsertJWK {
        const TYPE_QNAME = "0x1::jwks::PatchUpsertJWK";
        function type(): TypeDescriptor<PatchUpsertJWK>;
    }
    interface PatchUpsertJWKInstance extends TypedEventInstance<PatchUpsertJWK> {
        data_decoded: PatchUpsertJWK;
        type_arguments: [];
    }
    interface PatchedJWKs {
        jwks: jwks.AllProvidersJWKs;
    }
    namespace PatchedJWKs {
        const TYPE_QNAME = "0x1::jwks::PatchedJWKs";
        function type(): TypeDescriptor<PatchedJWKs>;
    }
    interface Patches {
        patches: jwks.Patch[];
    }
    namespace Patches {
        const TYPE_QNAME = "0x1::jwks::Patches";
        function type(): TypeDescriptor<Patches>;
    }
    interface ProviderJWKs {
        issuer: string;
        version: bigint;
        jwks: jwks.JWK[];
    }
    namespace ProviderJWKs {
        const TYPE_QNAME = "0x1::jwks::ProviderJWKs";
        function type(): TypeDescriptor<ProviderJWKs>;
    }
    interface ProviderJWKsInstance extends TypedEventInstance<ProviderJWKs> {
        data_decoded: ProviderJWKs;
        type_arguments: [];
    }
    interface RSA_JWK {
        kid: string;
        kty: string;
        alg: string;
        e: string;
        n: string;
    }
    namespace RSA_JWK {
        const TYPE_QNAME = "0x1::jwks::RSA_JWK";
        function type(): TypeDescriptor<RSA_JWK>;
    }
    interface RSA_JWKInstance extends TypedEventInstance<RSA_JWK> {
        data_decoded: RSA_JWK;
        type_arguments: [];
    }
    interface SupportedOIDCProviders {
        providers: jwks.OIDCProvider[];
    }
    namespace SupportedOIDCProviders {
        const TYPE_QNAME = "0x1::jwks::SupportedOIDCProviders";
        function type(): TypeDescriptor<SupportedOIDCProviders>;
    }
    interface SupportedOIDCProvidersInstance extends TypedEventInstance<SupportedOIDCProviders> {
        data_decoded: SupportedOIDCProviders;
        type_arguments: [];
    }
    interface UnsupportedJWK {
        id: string;
        payload: string;
    }
    namespace UnsupportedJWK {
        const TYPE_QNAME = "0x1::jwks::UnsupportedJWK";
        function type(): TypeDescriptor<UnsupportedJWK>;
    }
    interface UnsupportedJWKInstance extends TypedEventInstance<UnsupportedJWK> {
        data_decoded: UnsupportedJWK;
        type_arguments: [];
    }
}
export declare namespace util { }
export declare class block extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): block;
    onEventNewBlock(func: (event: block.NewBlockInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): block;
    onEventNewBlockEvent(func: (event: block.NewBlockEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): block;
    onEventUpdateEpochInterval(func: (event: block.UpdateEpochIntervalInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): block;
    onEventUpdateEpochIntervalEvent(func: (event: block.UpdateEpochIntervalEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): block;
}
export declare namespace block {
    interface BlockResource {
        height: bigint;
        epoch_interval: bigint;
        new_block_events: event.EventHandle<block.NewBlockEvent>;
        update_epoch_interval_events: event.EventHandle<block.UpdateEpochIntervalEvent>;
    }
    namespace BlockResource {
        const TYPE_QNAME = "0x1::block::BlockResource";
        function type(): TypeDescriptor<BlockResource>;
    }
    interface CommitHistory {
        max_capacity: number;
        next_idx: number;
        table: table_with_length.TableWithLength<number, block.NewBlockEvent>;
    }
    namespace CommitHistory {
        const TYPE_QNAME = "0x1::block::CommitHistory";
        function type(): TypeDescriptor<CommitHistory>;
    }
    interface NewBlock {
        hash: MoveAddressType;
        epoch: bigint;
        round: bigint;
        height: bigint;
        previous_block_votes_bitvec: string;
        proposer: MoveAddressType;
        failed_proposer_indices: bigint[];
        time_microseconds: bigint;
    }
    namespace NewBlock {
        const TYPE_QNAME = "0x1::block::NewBlock";
        function type(): TypeDescriptor<NewBlock>;
    }
    interface NewBlockInstance extends TypedEventInstance<NewBlock> {
        data_decoded: NewBlock;
        type_arguments: [];
    }
    interface NewBlockEvent {
        hash: MoveAddressType;
        epoch: bigint;
        round: bigint;
        height: bigint;
        previous_block_votes_bitvec: string;
        proposer: MoveAddressType;
        failed_proposer_indices: bigint[];
        time_microseconds: bigint;
    }
    namespace NewBlockEvent {
        const TYPE_QNAME = "0x1::block::NewBlockEvent";
        function type(): TypeDescriptor<NewBlockEvent>;
    }
    interface NewBlockEventInstance extends TypedEventInstance<NewBlockEvent> {
        data_decoded: NewBlockEvent;
        type_arguments: [];
    }
    interface UpdateEpochInterval {
        old_epoch_interval: bigint;
        new_epoch_interval: bigint;
    }
    namespace UpdateEpochInterval {
        const TYPE_QNAME = "0x1::block::UpdateEpochInterval";
        function type(): TypeDescriptor<UpdateEpochInterval>;
    }
    interface UpdateEpochIntervalInstance extends TypedEventInstance<UpdateEpochInterval> {
        data_decoded: UpdateEpochInterval;
        type_arguments: [];
    }
    interface UpdateEpochIntervalEvent {
        old_epoch_interval: bigint;
        new_epoch_interval: bigint;
    }
    namespace UpdateEpochIntervalEvent {
        const TYPE_QNAME = "0x1::block::UpdateEpochIntervalEvent";
        function type(): TypeDescriptor<UpdateEpochIntervalEvent>;
    }
    interface UpdateEpochIntervalEventInstance extends TypedEventInstance<UpdateEpochIntervalEvent> {
        data_decoded: UpdateEpochIntervalEvent;
        type_arguments: [];
    }
}
export declare namespace debug { }
export declare namespace error { }
export declare namespace event {
    interface EventHandle<T0> {
        counter: bigint;
        guid: guid.GUID;
    }
    namespace EventHandle {
        const TYPE_QNAME = "0x1::event::EventHandle";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<EventHandle<T0>>;
    }
}
export declare class stake extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): stake;
    onEntryAddStake(func: (call: stake.AddStakePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEntryIncreaseLockup(func: (call: stake.IncreaseLockupPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEntryInitializeStakeOwner(func: (call: stake.InitializeStakeOwnerPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEntryInitializeValidator(func: (call: stake.InitializeValidatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEntryJoinValidatorSet(func: (call: stake.JoinValidatorSetPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEntryLeaveValidatorSet(func: (call: stake.LeaveValidatorSetPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEntryReactivateStake(func: (call: stake.ReactivateStakePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEntryRotateConsensusKey(func: (call: stake.RotateConsensusKeyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEntrySetDelegatedVoter(func: (call: stake.SetDelegatedVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEntrySetOperator(func: (call: stake.SetOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEntryUnlock(func: (call: stake.UnlockPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEntryUpdateNetworkAndFullnodeAddresses(func: (call: stake.UpdateNetworkAndFullnodeAddressesPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEntryWithdraw(func: (call: stake.WithdrawPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventAddStake(func: (event: stake.AddStakeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventAddStakeEvent(func: (event: stake.AddStakeEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventDistributeRewards(func: (event: stake.DistributeRewardsInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventDistributeRewardsEvent(func: (event: stake.DistributeRewardsEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventIncreaseLockup(func: (event: stake.IncreaseLockupInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventIncreaseLockupEvent(func: (event: stake.IncreaseLockupEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventIndividualValidatorPerformance(func: (event: stake.IndividualValidatorPerformanceInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventJoinValidatorSet(func: (event: stake.JoinValidatorSetInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventJoinValidatorSetEvent(func: (event: stake.JoinValidatorSetEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventLeaveValidatorSet(func: (event: stake.LeaveValidatorSetInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventLeaveValidatorSetEvent(func: (event: stake.LeaveValidatorSetEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventReactivateStake(func: (event: stake.ReactivateStakeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventReactivateStakeEvent(func: (event: stake.ReactivateStakeEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventRegisterValidatorCandidate(func: (event: stake.RegisterValidatorCandidateInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventRegisterValidatorCandidateEvent(func: (event: stake.RegisterValidatorCandidateEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventRotateConsensusKey(func: (event: stake.RotateConsensusKeyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventRotateConsensusKeyEvent(func: (event: stake.RotateConsensusKeyEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventSetOperator(func: (event: stake.SetOperatorInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventSetOperatorEvent(func: (event: stake.SetOperatorEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventUnlockStake(func: (event: stake.UnlockStakeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventUnlockStakeEvent(func: (event: stake.UnlockStakeEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventUpdateNetworkAndFullnodeAddresses(func: (event: stake.UpdateNetworkAndFullnodeAddressesInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventUpdateNetworkAndFullnodeAddressesEvent(func: (event: stake.UpdateNetworkAndFullnodeAddressesEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventValidatorConfig(func: (event: stake.ValidatorConfigInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventValidatorInfo(func: (event: stake.ValidatorInfoInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventValidatorSet(func: (event: stake.ValidatorSetInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventWithdrawStake(func: (event: stake.WithdrawStakeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
    onEventWithdrawStakeEvent(func: (event: stake.WithdrawStakeEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): stake;
}
export declare namespace stake {
    interface AddStake {
        pool_address: MoveAddressType;
        amount_added: bigint;
    }
    namespace AddStake {
        const TYPE_QNAME = "0x1::stake::AddStake";
        function type(): TypeDescriptor<AddStake>;
    }
    interface AddStakeInstance extends TypedEventInstance<AddStake> {
        data_decoded: AddStake;
        type_arguments: [];
    }
    interface AddStakeEvent {
        pool_address: MoveAddressType;
        amount_added: bigint;
    }
    namespace AddStakeEvent {
        const TYPE_QNAME = "0x1::stake::AddStakeEvent";
        function type(): TypeDescriptor<AddStakeEvent>;
    }
    interface AddStakeEventInstance extends TypedEventInstance<AddStakeEvent> {
        data_decoded: AddStakeEvent;
        type_arguments: [];
    }
    interface AllowedValidators {
        accounts: MoveAddressType[];
    }
    namespace AllowedValidators {
        const TYPE_QNAME = "0x1::stake::AllowedValidators";
        function type(): TypeDescriptor<AllowedValidators>;
    }
    interface AptosCoinCapabilities {
        mint_cap: coin.MintCapability<aptos_coin.AptosCoin>;
    }
    namespace AptosCoinCapabilities {
        const TYPE_QNAME = "0x1::stake::AptosCoinCapabilities";
        function type(): TypeDescriptor<AptosCoinCapabilities>;
    }
    interface DistributeRewards {
        pool_address: MoveAddressType;
        rewards_amount: bigint;
    }
    namespace DistributeRewards {
        const TYPE_QNAME = "0x1::stake::DistributeRewards";
        function type(): TypeDescriptor<DistributeRewards>;
    }
    interface DistributeRewardsInstance extends TypedEventInstance<DistributeRewards> {
        data_decoded: DistributeRewards;
        type_arguments: [];
    }
    interface DistributeRewardsEvent {
        pool_address: MoveAddressType;
        rewards_amount: bigint;
    }
    namespace DistributeRewardsEvent {
        const TYPE_QNAME = "0x1::stake::DistributeRewardsEvent";
        function type(): TypeDescriptor<DistributeRewardsEvent>;
    }
    interface DistributeRewardsEventInstance extends TypedEventInstance<DistributeRewardsEvent> {
        data_decoded: DistributeRewardsEvent;
        type_arguments: [];
    }
    interface IncreaseLockup {
        pool_address: MoveAddressType;
        old_locked_until_secs: bigint;
        new_locked_until_secs: bigint;
    }
    namespace IncreaseLockup {
        const TYPE_QNAME = "0x1::stake::IncreaseLockup";
        function type(): TypeDescriptor<IncreaseLockup>;
    }
    interface IncreaseLockupInstance extends TypedEventInstance<IncreaseLockup> {
        data_decoded: IncreaseLockup;
        type_arguments: [];
    }
    interface IncreaseLockupEvent {
        pool_address: MoveAddressType;
        old_locked_until_secs: bigint;
        new_locked_until_secs: bigint;
    }
    namespace IncreaseLockupEvent {
        const TYPE_QNAME = "0x1::stake::IncreaseLockupEvent";
        function type(): TypeDescriptor<IncreaseLockupEvent>;
    }
    interface IncreaseLockupEventInstance extends TypedEventInstance<IncreaseLockupEvent> {
        data_decoded: IncreaseLockupEvent;
        type_arguments: [];
    }
    interface IndividualValidatorPerformance {
        successful_proposals: bigint;
        failed_proposals: bigint;
    }
    namespace IndividualValidatorPerformance {
        const TYPE_QNAME = "0x1::stake::IndividualValidatorPerformance";
        function type(): TypeDescriptor<IndividualValidatorPerformance>;
    }
    interface IndividualValidatorPerformanceInstance extends TypedEventInstance<IndividualValidatorPerformance> {
        data_decoded: IndividualValidatorPerformance;
        type_arguments: [];
    }
    interface JoinValidatorSet {
        pool_address: MoveAddressType;
    }
    namespace JoinValidatorSet {
        const TYPE_QNAME = "0x1::stake::JoinValidatorSet";
        function type(): TypeDescriptor<JoinValidatorSet>;
    }
    interface JoinValidatorSetInstance extends TypedEventInstance<JoinValidatorSet> {
        data_decoded: JoinValidatorSet;
        type_arguments: [];
    }
    interface JoinValidatorSetEvent {
        pool_address: MoveAddressType;
    }
    namespace JoinValidatorSetEvent {
        const TYPE_QNAME = "0x1::stake::JoinValidatorSetEvent";
        function type(): TypeDescriptor<JoinValidatorSetEvent>;
    }
    interface JoinValidatorSetEventInstance extends TypedEventInstance<JoinValidatorSetEvent> {
        data_decoded: JoinValidatorSetEvent;
        type_arguments: [];
    }
    interface LeaveValidatorSet {
        pool_address: MoveAddressType;
    }
    namespace LeaveValidatorSet {
        const TYPE_QNAME = "0x1::stake::LeaveValidatorSet";
        function type(): TypeDescriptor<LeaveValidatorSet>;
    }
    interface LeaveValidatorSetInstance extends TypedEventInstance<LeaveValidatorSet> {
        data_decoded: LeaveValidatorSet;
        type_arguments: [];
    }
    interface LeaveValidatorSetEvent {
        pool_address: MoveAddressType;
    }
    namespace LeaveValidatorSetEvent {
        const TYPE_QNAME = "0x1::stake::LeaveValidatorSetEvent";
        function type(): TypeDescriptor<LeaveValidatorSetEvent>;
    }
    interface LeaveValidatorSetEventInstance extends TypedEventInstance<LeaveValidatorSetEvent> {
        data_decoded: LeaveValidatorSetEvent;
        type_arguments: [];
    }
    interface OwnerCapability {
        pool_address: MoveAddressType;
    }
    namespace OwnerCapability {
        const TYPE_QNAME = "0x1::stake::OwnerCapability";
        function type(): TypeDescriptor<OwnerCapability>;
    }
    interface ReactivateStake {
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace ReactivateStake {
        const TYPE_QNAME = "0x1::stake::ReactivateStake";
        function type(): TypeDescriptor<ReactivateStake>;
    }
    interface ReactivateStakeInstance extends TypedEventInstance<ReactivateStake> {
        data_decoded: ReactivateStake;
        type_arguments: [];
    }
    interface ReactivateStakeEvent {
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace ReactivateStakeEvent {
        const TYPE_QNAME = "0x1::stake::ReactivateStakeEvent";
        function type(): TypeDescriptor<ReactivateStakeEvent>;
    }
    interface ReactivateStakeEventInstance extends TypedEventInstance<ReactivateStakeEvent> {
        data_decoded: ReactivateStakeEvent;
        type_arguments: [];
    }
    interface RegisterValidatorCandidate {
        pool_address: MoveAddressType;
    }
    namespace RegisterValidatorCandidate {
        const TYPE_QNAME = "0x1::stake::RegisterValidatorCandidate";
        function type(): TypeDescriptor<RegisterValidatorCandidate>;
    }
    interface RegisterValidatorCandidateInstance extends TypedEventInstance<RegisterValidatorCandidate> {
        data_decoded: RegisterValidatorCandidate;
        type_arguments: [];
    }
    interface RegisterValidatorCandidateEvent {
        pool_address: MoveAddressType;
    }
    namespace RegisterValidatorCandidateEvent {
        const TYPE_QNAME = "0x1::stake::RegisterValidatorCandidateEvent";
        function type(): TypeDescriptor<RegisterValidatorCandidateEvent>;
    }
    interface RegisterValidatorCandidateEventInstance extends TypedEventInstance<RegisterValidatorCandidateEvent> {
        data_decoded: RegisterValidatorCandidateEvent;
        type_arguments: [];
    }
    interface RotateConsensusKey {
        pool_address: MoveAddressType;
        old_consensus_pubkey: string;
        new_consensus_pubkey: string;
    }
    namespace RotateConsensusKey {
        const TYPE_QNAME = "0x1::stake::RotateConsensusKey";
        function type(): TypeDescriptor<RotateConsensusKey>;
    }
    interface RotateConsensusKeyInstance extends TypedEventInstance<RotateConsensusKey> {
        data_decoded: RotateConsensusKey;
        type_arguments: [];
    }
    interface RotateConsensusKeyEvent {
        pool_address: MoveAddressType;
        old_consensus_pubkey: string;
        new_consensus_pubkey: string;
    }
    namespace RotateConsensusKeyEvent {
        const TYPE_QNAME = "0x1::stake::RotateConsensusKeyEvent";
        function type(): TypeDescriptor<RotateConsensusKeyEvent>;
    }
    interface RotateConsensusKeyEventInstance extends TypedEventInstance<RotateConsensusKeyEvent> {
        data_decoded: RotateConsensusKeyEvent;
        type_arguments: [];
    }
    interface SetOperator {
        pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
    }
    namespace SetOperator {
        const TYPE_QNAME = "0x1::stake::SetOperator";
        function type(): TypeDescriptor<SetOperator>;
    }
    interface SetOperatorInstance extends TypedEventInstance<SetOperator> {
        data_decoded: SetOperator;
        type_arguments: [];
    }
    interface SetOperatorEvent {
        pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
    }
    namespace SetOperatorEvent {
        const TYPE_QNAME = "0x1::stake::SetOperatorEvent";
        function type(): TypeDescriptor<SetOperatorEvent>;
    }
    interface SetOperatorEventInstance extends TypedEventInstance<SetOperatorEvent> {
        data_decoded: SetOperatorEvent;
        type_arguments: [];
    }
    interface StakePool {
        active: coin.Coin<aptos_coin.AptosCoin>;
        inactive: coin.Coin<aptos_coin.AptosCoin>;
        pending_active: coin.Coin<aptos_coin.AptosCoin>;
        pending_inactive: coin.Coin<aptos_coin.AptosCoin>;
        locked_until_secs: bigint;
        operator_address: MoveAddressType;
        delegated_voter: MoveAddressType;
        initialize_validator_events: event.EventHandle<stake.RegisterValidatorCandidateEvent>;
        set_operator_events: event.EventHandle<stake.SetOperatorEvent>;
        add_stake_events: event.EventHandle<stake.AddStakeEvent>;
        reactivate_stake_events: event.EventHandle<stake.ReactivateStakeEvent>;
        rotate_consensus_key_events: event.EventHandle<stake.RotateConsensusKeyEvent>;
        update_network_and_fullnode_addresses_events: event.EventHandle<stake.UpdateNetworkAndFullnodeAddressesEvent>;
        increase_lockup_events: event.EventHandle<stake.IncreaseLockupEvent>;
        join_validator_set_events: event.EventHandle<stake.JoinValidatorSetEvent>;
        distribute_rewards_events: event.EventHandle<stake.DistributeRewardsEvent>;
        unlock_stake_events: event.EventHandle<stake.UnlockStakeEvent>;
        withdraw_stake_events: event.EventHandle<stake.WithdrawStakeEvent>;
        leave_validator_set_events: event.EventHandle<stake.LeaveValidatorSetEvent>;
    }
    namespace StakePool {
        const TYPE_QNAME = "0x1::stake::StakePool";
        function type(): TypeDescriptor<StakePool>;
    }
    interface UnlockStake {
        pool_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStake {
        const TYPE_QNAME = "0x1::stake::UnlockStake";
        function type(): TypeDescriptor<UnlockStake>;
    }
    interface UnlockStakeInstance extends TypedEventInstance<UnlockStake> {
        data_decoded: UnlockStake;
        type_arguments: [];
    }
    interface UnlockStakeEvent {
        pool_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStakeEvent {
        const TYPE_QNAME = "0x1::stake::UnlockStakeEvent";
        function type(): TypeDescriptor<UnlockStakeEvent>;
    }
    interface UnlockStakeEventInstance extends TypedEventInstance<UnlockStakeEvent> {
        data_decoded: UnlockStakeEvent;
        type_arguments: [];
    }
    interface UpdateNetworkAndFullnodeAddresses {
        pool_address: MoveAddressType;
        old_network_addresses: string;
        new_network_addresses: string;
        old_fullnode_addresses: string;
        new_fullnode_addresses: string;
    }
    namespace UpdateNetworkAndFullnodeAddresses {
        const TYPE_QNAME = "0x1::stake::UpdateNetworkAndFullnodeAddresses";
        function type(): TypeDescriptor<UpdateNetworkAndFullnodeAddresses>;
    }
    interface UpdateNetworkAndFullnodeAddressesInstance extends TypedEventInstance<UpdateNetworkAndFullnodeAddresses> {
        data_decoded: UpdateNetworkAndFullnodeAddresses;
        type_arguments: [];
    }
    interface UpdateNetworkAndFullnodeAddressesEvent {
        pool_address: MoveAddressType;
        old_network_addresses: string;
        new_network_addresses: string;
        old_fullnode_addresses: string;
        new_fullnode_addresses: string;
    }
    namespace UpdateNetworkAndFullnodeAddressesEvent {
        const TYPE_QNAME = "0x1::stake::UpdateNetworkAndFullnodeAddressesEvent";
        function type(): TypeDescriptor<UpdateNetworkAndFullnodeAddressesEvent>;
    }
    interface UpdateNetworkAndFullnodeAddressesEventInstance extends TypedEventInstance<UpdateNetworkAndFullnodeAddressesEvent> {
        data_decoded: UpdateNetworkAndFullnodeAddressesEvent;
        type_arguments: [];
    }
    interface ValidatorConfig {
        consensus_pubkey: string;
        network_addresses: string;
        fullnode_addresses: string;
        validator_index: bigint;
    }
    namespace ValidatorConfig {
        const TYPE_QNAME = "0x1::stake::ValidatorConfig";
        function type(): TypeDescriptor<ValidatorConfig>;
    }
    interface ValidatorConfigInstance extends TypedEventInstance<ValidatorConfig> {
        data_decoded: ValidatorConfig;
        type_arguments: [];
    }
    interface ValidatorFees {
        fees_table: table.Table<MoveAddressType, coin.Coin<aptos_coin.AptosCoin>>;
    }
    namespace ValidatorFees {
        const TYPE_QNAME = "0x1::stake::ValidatorFees";
        function type(): TypeDescriptor<ValidatorFees>;
    }
    interface ValidatorInfo {
        addr: MoveAddressType;
        voting_power: bigint;
        config: stake.ValidatorConfig;
    }
    namespace ValidatorInfo {
        const TYPE_QNAME = "0x1::stake::ValidatorInfo";
        function type(): TypeDescriptor<ValidatorInfo>;
    }
    interface ValidatorInfoInstance extends TypedEventInstance<ValidatorInfo> {
        data_decoded: ValidatorInfo;
        type_arguments: [];
    }
    interface ValidatorPerformance {
        validators: stake.IndividualValidatorPerformance[];
    }
    namespace ValidatorPerformance {
        const TYPE_QNAME = "0x1::stake::ValidatorPerformance";
        function type(): TypeDescriptor<ValidatorPerformance>;
    }
    interface ValidatorSet {
        consensus_scheme: number;
        active_validators: stake.ValidatorInfo[];
        pending_inactive: stake.ValidatorInfo[];
        pending_active: stake.ValidatorInfo[];
        total_voting_power: bigint;
        total_joining_power: bigint;
    }
    namespace ValidatorSet {
        const TYPE_QNAME = "0x1::stake::ValidatorSet";
        function type(): TypeDescriptor<ValidatorSet>;
    }
    interface ValidatorSetInstance extends TypedEventInstance<ValidatorSet> {
        data_decoded: ValidatorSet;
        type_arguments: [];
    }
    interface WithdrawStake {
        pool_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStake {
        const TYPE_QNAME = "0x1::stake::WithdrawStake";
        function type(): TypeDescriptor<WithdrawStake>;
    }
    interface WithdrawStakeInstance extends TypedEventInstance<WithdrawStake> {
        data_decoded: WithdrawStake;
        type_arguments: [];
    }
    interface WithdrawStakeEvent {
        pool_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStakeEvent {
        const TYPE_QNAME = "0x1::stake::WithdrawStakeEvent";
        function type(): TypeDescriptor<WithdrawStakeEvent>;
    }
    interface WithdrawStakeEventInstance extends TypedEventInstance<WithdrawStakeEvent> {
        data_decoded: WithdrawStakeEvent;
        type_arguments: [];
    }
    interface AddStakePayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface IncreaseLockupPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface InitializeStakeOwnerPayload extends TypedFunctionPayload<[bigint, MoveAddressType, MoveAddressType]> {
        arguments_decoded: [bigint, MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface InitializeValidatorPayload extends TypedFunctionPayload<[string, string, string, string]> {
        arguments_decoded: [string, string, string, string];
        type_arguments: [];
    }
    interface JoinValidatorSetPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface LeaveValidatorSetPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface ReactivateStakePayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface RotateConsensusKeyPayload extends TypedFunctionPayload<[MoveAddressType, string, string]> {
        arguments_decoded: [MoveAddressType, string, string];
        type_arguments: [];
    }
    interface SetDelegatedVoterPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetOperatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UnlockPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface UpdateNetworkAndFullnodeAddressesPayload extends TypedFunctionPayload<[MoveAddressType, string, string]> {
        arguments_decoded: [MoveAddressType, string, string];
        type_arguments: [];
    }
    interface WithdrawPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
}
export declare class table extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): table;
    onEventBox(func: (event: table.BoxInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): table;
}
export declare namespace table {
    interface Box<T0> {
        val: T0;
    }
    namespace Box {
        const TYPE_QNAME = "0x1::table::Box";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Box<T0>>;
    }
    interface BoxInstance extends TypedEventInstance<Box<any>> {
        data_decoded: Box<any>;
        type_arguments: [string];
    }
    interface Table<T0, T1> {
        handle: MoveAddressType;
    }
    namespace Table {
        const TYPE_QNAME = "0x1::table::Table";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Table<T0, T1>>;
    }
}
export declare namespace math64 { }
export declare class object_ extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): object_;
    onEntryBurn(func: (call: object_.BurnPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): object_;
    onEntryTransfer(func: (call: object_.TransferPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): object_;
    onEntryTransferCall(func: (call: object_.TransferCallPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): object_;
    onEntryTransferToObject(func: (call: object_.TransferToObjectPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): object_;
    onEntryUnburn(func: (call: object_.UnburnPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): object_;
    onEventDeleteRef(func: (event: object_.DeleteRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): object_;
    onEventDeriveRef(func: (event: object_.DeriveRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): object_;
    onEventExtendRef(func: (event: object_.ExtendRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): object_;
    onEventObject(func: (event: object_.ObjectInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): object_;
    onEventTransfer(func: (event: object_.TransferInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): object_;
    onEventTransferEvent(func: (event: object_.TransferEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): object_;
    onEventTransferRef(func: (event: object_.TransferRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): object_;
}
export declare namespace object_ {
    interface ConstructorRef {
        self: MoveAddressType;
        can_delete: Boolean;
    }
    namespace ConstructorRef {
        const TYPE_QNAME = "0x1::object::ConstructorRef";
        function type(): TypeDescriptor<ConstructorRef>;
    }
    interface DeleteRef {
        self: MoveAddressType;
    }
    namespace DeleteRef {
        const TYPE_QNAME = "0x1::object::DeleteRef";
        function type(): TypeDescriptor<DeleteRef>;
    }
    interface DeleteRefInstance extends TypedEventInstance<DeleteRef> {
        data_decoded: DeleteRef;
        type_arguments: [];
    }
    interface DeriveRef {
        self: MoveAddressType;
    }
    namespace DeriveRef {
        const TYPE_QNAME = "0x1::object::DeriveRef";
        function type(): TypeDescriptor<DeriveRef>;
    }
    interface DeriveRefInstance extends TypedEventInstance<DeriveRef> {
        data_decoded: DeriveRef;
        type_arguments: [];
    }
    interface ExtendRef {
        self: MoveAddressType;
    }
    namespace ExtendRef {
        const TYPE_QNAME = "0x1::object::ExtendRef";
        function type(): TypeDescriptor<ExtendRef>;
    }
    interface ExtendRefInstance extends TypedEventInstance<ExtendRef> {
        data_decoded: ExtendRef;
        type_arguments: [];
    }
    interface LinearTransferRef {
        self: MoveAddressType;
        owner: MoveAddressType;
    }
    namespace LinearTransferRef {
        const TYPE_QNAME = "0x1::object::LinearTransferRef";
        function type(): TypeDescriptor<LinearTransferRef>;
    }
    interface Object<T0> {
        inner: MoveAddressType;
    }
    namespace Object {
        const TYPE_QNAME = "0x1::object::Object";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Object<T0>>;
    }
    interface ObjectInstance extends TypedEventInstance<Object<any>> {
        data_decoded: Object<any>;
        type_arguments: [string];
    }
    interface ObjectCore {
        guid_creation_num: bigint;
        owner: MoveAddressType;
        allow_ungated_transfer: Boolean;
        transfer_events: event.EventHandle<object_.TransferEvent>;
    }
    namespace ObjectCore {
        const TYPE_QNAME = "0x1::object::ObjectCore";
        function type(): TypeDescriptor<ObjectCore>;
    }
    interface ObjectGroup {
        dummy_field: Boolean;
    }
    namespace ObjectGroup {
        const TYPE_QNAME = "0x1::object::ObjectGroup";
        function type(): TypeDescriptor<ObjectGroup>;
    }
    interface TombStone {
        original_owner: MoveAddressType;
    }
    namespace TombStone {
        const TYPE_QNAME = "0x1::object::TombStone";
        function type(): TypeDescriptor<TombStone>;
    }
    interface Transfer {
        object: MoveAddressType;
        from: MoveAddressType;
        to: MoveAddressType;
    }
    namespace Transfer {
        const TYPE_QNAME = "0x1::object::Transfer";
        function type(): TypeDescriptor<Transfer>;
    }
    interface TransferInstance extends TypedEventInstance<Transfer> {
        data_decoded: Transfer;
        type_arguments: [];
    }
    interface TransferEvent {
        object: MoveAddressType;
        from: MoveAddressType;
        to: MoveAddressType;
    }
    namespace TransferEvent {
        const TYPE_QNAME = "0x1::object::TransferEvent";
        function type(): TypeDescriptor<TransferEvent>;
    }
    interface TransferEventInstance extends TypedEventInstance<TransferEvent> {
        data_decoded: TransferEvent;
        type_arguments: [];
    }
    interface TransferRef {
        self: MoveAddressType;
    }
    namespace TransferRef {
        const TYPE_QNAME = "0x1::object::TransferRef";
        function type(): TypeDescriptor<TransferRef>;
    }
    interface TransferRefInstance extends TypedEventInstance<TransferRef> {
        data_decoded: TransferRef;
        type_arguments: [];
    }
    interface Untransferable {
        dummy_field: Boolean;
    }
    namespace Untransferable {
        const TYPE_QNAME = "0x1::object::Untransferable";
        function type(): TypeDescriptor<Untransferable>;
    }
    interface BurnPayload<T0 = any> extends TypedFunctionPayload<[object_.Object<T0>]> {
        arguments_decoded: [object_.Object<T0>];
        type_arguments: [string];
    }
    interface TransferPayload<T0 = any> extends TypedFunctionPayload<[object_.Object<T0>, MoveAddressType]> {
        arguments_decoded: [object_.Object<T0>, MoveAddressType];
        type_arguments: [string];
    }
    interface TransferCallPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface TransferToObjectPayload<T0 = any, T1 = any> extends TypedFunctionPayload<[object_.Object<T0>, object_.Object<T1>]> {
        arguments_decoded: [object_.Object<T0>, object_.Object<T1>];
        type_arguments: [string, string];
    }
    interface UnburnPayload<T0 = any> extends TypedFunctionPayload<[object_.Object<T0>]> {
        arguments_decoded: [object_.Object<T0>];
        type_arguments: [string];
    }
}
export declare class option extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): option;
    onEventOption(func: (event: option.OptionInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): option;
}
export declare namespace option {
    interface Option<T0> {
        vec: T0[] | string;
    }
    namespace Option {
        const TYPE_QNAME = "0x1::option::Option";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Option<T0>>;
    }
    interface OptionInstance extends TypedEventInstance<Option<any>> {
        data_decoded: Option<any>;
        type_arguments: [string];
    }
}
export declare namespace signer { }
export declare class string_ extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): string_;
    onEventString(func: (event: string_.StringInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): string_;
}
export declare namespace string_ {
    interface String {
        bytes: string;
    }
    namespace String {
        const TYPE_QNAME = "0x1::string::String";
        function type(): TypeDescriptor<String>;
    }
    interface StringInstance extends TypedEventInstance<String> {
        data_decoded: String;
        type_arguments: [];
    }
}
export declare namespace vector { }
export declare class voting extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): voting;
    onEventCreateProposal(func: (event: voting.CreateProposalInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): voting;
    onEventCreateProposalEvent(func: (event: voting.CreateProposalEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): voting;
    onEventRegisterForum(func: (event: voting.RegisterForumInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): voting;
    onEventRegisterForumEvent(func: (event: voting.RegisterForumEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): voting;
    onEventResolveProposal(func: (event: voting.ResolveProposalInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): voting;
    onEventVote(func: (event: voting.VoteInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): voting;
    onEventVoteEvent(func: (event: voting.VoteEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): voting;
}
export declare namespace voting {
    interface CreateProposal {
        proposal_id: bigint;
        early_resolution_vote_threshold: option.Option<bigint>;
        execution_hash: string;
        expiration_secs: bigint;
        metadata: simple_map.SimpleMap<string, string>;
        min_vote_threshold: bigint;
    }
    namespace CreateProposal {
        const TYPE_QNAME = "0x1::voting::CreateProposal";
        function type(): TypeDescriptor<CreateProposal>;
    }
    interface CreateProposalInstance extends TypedEventInstance<CreateProposal> {
        data_decoded: CreateProposal;
        type_arguments: [];
    }
    interface CreateProposalEvent {
        proposal_id: bigint;
        early_resolution_vote_threshold: option.Option<bigint>;
        execution_hash: string;
        expiration_secs: bigint;
        metadata: simple_map.SimpleMap<string, string>;
        min_vote_threshold: bigint;
    }
    namespace CreateProposalEvent {
        const TYPE_QNAME = "0x1::voting::CreateProposalEvent";
        function type(): TypeDescriptor<CreateProposalEvent>;
    }
    interface CreateProposalEventInstance extends TypedEventInstance<CreateProposalEvent> {
        data_decoded: CreateProposalEvent;
        type_arguments: [];
    }
    interface Proposal<T0> {
        proposer: MoveAddressType;
        execution_content: option.Option<T0>;
        metadata: simple_map.SimpleMap<string, string>;
        creation_time_secs: bigint;
        execution_hash: string;
        min_vote_threshold: bigint;
        expiration_secs: bigint;
        early_resolution_vote_threshold: option.Option<bigint>;
        yes_votes: bigint;
        no_votes: bigint;
        is_resolved: Boolean;
        resolution_time_secs: bigint;
    }
    namespace Proposal {
        const TYPE_QNAME = "0x1::voting::Proposal";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Proposal<T0>>;
    }
    interface RegisterForum {
        hosting_account: MoveAddressType;
        proposal_type_info: type_info.TypeInfo;
    }
    namespace RegisterForum {
        const TYPE_QNAME = "0x1::voting::RegisterForum";
        function type(): TypeDescriptor<RegisterForum>;
    }
    interface RegisterForumInstance extends TypedEventInstance<RegisterForum> {
        data_decoded: RegisterForum;
        type_arguments: [];
    }
    interface RegisterForumEvent {
        hosting_account: MoveAddressType;
        proposal_type_info: type_info.TypeInfo;
    }
    namespace RegisterForumEvent {
        const TYPE_QNAME = "0x1::voting::RegisterForumEvent";
        function type(): TypeDescriptor<RegisterForumEvent>;
    }
    interface RegisterForumEventInstance extends TypedEventInstance<RegisterForumEvent> {
        data_decoded: RegisterForumEvent;
        type_arguments: [];
    }
    interface ResolveProposal {
        proposal_id: bigint;
        yes_votes: bigint;
        no_votes: bigint;
        resolved_early: Boolean;
    }
    namespace ResolveProposal {
        const TYPE_QNAME = "0x1::voting::ResolveProposal";
        function type(): TypeDescriptor<ResolveProposal>;
    }
    interface ResolveProposalInstance extends TypedEventInstance<ResolveProposal> {
        data_decoded: ResolveProposal;
        type_arguments: [];
    }
    interface Vote {
        proposal_id: bigint;
        num_votes: bigint;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::voting::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    interface VoteInstance extends TypedEventInstance<Vote> {
        data_decoded: Vote;
        type_arguments: [];
    }
    interface VoteEvent {
        proposal_id: bigint;
        num_votes: bigint;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::voting::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    interface VoteEventInstance extends TypedEventInstance<VoteEvent> {
        data_decoded: VoteEvent;
        type_arguments: [];
    }
    interface VotingEvents {
        create_proposal_events: event.EventHandle<voting.CreateProposalEvent>;
        register_forum_events: event.EventHandle<voting.RegisterForumEvent>;
        resolve_proposal_events: event.EventHandle<voting.ResolveProposal>;
        vote_events: event.EventHandle<voting.VoteEvent>;
    }
    namespace VotingEvents {
        const TYPE_QNAME = "0x1::voting::VotingEvents";
        function type(): TypeDescriptor<VotingEvents>;
    }
    interface VotingForum<T0> {
        proposals: table.Table<bigint, voting.Proposal<T0>>;
        events: voting.VotingEvents;
        next_proposal_id: bigint;
    }
    namespace VotingForum {
        const TYPE_QNAME = "0x1::voting::VotingForum";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<VotingForum<T0>>;
    }
}
export declare class account extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): account;
    onEntryOfferRotationCapability(func: (call: account.OfferRotationCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEntryOfferSignerCapability(func: (call: account.OfferSignerCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEntryRevokeAnyRotationCapability(func: (call: account.RevokeAnyRotationCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEntryRevokeAnySignerCapability(func: (call: account.RevokeAnySignerCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEntryRevokeRotationCapability(func: (call: account.RevokeRotationCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEntryRevokeSignerCapability(func: (call: account.RevokeSignerCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEntryRotateAuthenticationKey(func: (call: account.RotateAuthenticationKeyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEntryRotateAuthenticationKeyCall(func: (call: account.RotateAuthenticationKeyCallPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEntryRotateAuthenticationKeyWithRotationCapability(func: (call: account.RotateAuthenticationKeyWithRotationCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEventCoinRegisterEvent(func: (event: account.CoinRegisterEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEventKeyRotation(func: (event: account.KeyRotationInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEventKeyRotationEvent(func: (event: account.KeyRotationEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEventRotationCapability(func: (event: account.RotationCapabilityInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): account;
    onEventSignerCapability(func: (event: account.SignerCapabilityInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): account;
}
export declare namespace account {
    interface Account {
        authentication_key: string;
        sequence_number: bigint;
        guid_creation_num: bigint;
        coin_register_events: event.EventHandle<account.CoinRegisterEvent>;
        key_rotation_events: event.EventHandle<account.KeyRotationEvent>;
        rotation_capability_offer: account.CapabilityOffer<account.RotationCapability>;
        signer_capability_offer: account.CapabilityOffer<account.SignerCapability>;
    }
    namespace Account {
        const TYPE_QNAME = "0x1::account::Account";
        function type(): TypeDescriptor<Account>;
    }
    interface CapabilityOffer<T0> {
        for: option.Option<MoveAddressType>;
    }
    namespace CapabilityOffer {
        const TYPE_QNAME = "0x1::account::CapabilityOffer";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CapabilityOffer<T0>>;
    }
    interface CoinRegisterEvent {
        type_info: type_info.TypeInfo;
    }
    namespace CoinRegisterEvent {
        const TYPE_QNAME = "0x1::account::CoinRegisterEvent";
        function type(): TypeDescriptor<CoinRegisterEvent>;
    }
    interface CoinRegisterEventInstance extends TypedEventInstance<CoinRegisterEvent> {
        data_decoded: CoinRegisterEvent;
        type_arguments: [];
    }
    interface KeyRotation {
        account: MoveAddressType;
        old_authentication_key: string;
        new_authentication_key: string;
    }
    namespace KeyRotation {
        const TYPE_QNAME = "0x1::account::KeyRotation";
        function type(): TypeDescriptor<KeyRotation>;
    }
    interface KeyRotationInstance extends TypedEventInstance<KeyRotation> {
        data_decoded: KeyRotation;
        type_arguments: [];
    }
    interface KeyRotationEvent {
        old_authentication_key: string;
        new_authentication_key: string;
    }
    namespace KeyRotationEvent {
        const TYPE_QNAME = "0x1::account::KeyRotationEvent";
        function type(): TypeDescriptor<KeyRotationEvent>;
    }
    interface KeyRotationEventInstance extends TypedEventInstance<KeyRotationEvent> {
        data_decoded: KeyRotationEvent;
        type_arguments: [];
    }
    interface OriginatingAddress {
        address_map: table.Table<MoveAddressType, MoveAddressType>;
    }
    namespace OriginatingAddress {
        const TYPE_QNAME = "0x1::account::OriginatingAddress";
        function type(): TypeDescriptor<OriginatingAddress>;
    }
    interface RotationCapability {
        account: MoveAddressType;
    }
    namespace RotationCapability {
        const TYPE_QNAME = "0x1::account::RotationCapability";
        function type(): TypeDescriptor<RotationCapability>;
    }
    interface RotationCapabilityInstance extends TypedEventInstance<RotationCapability> {
        data_decoded: RotationCapability;
        type_arguments: [];
    }
    interface RotationCapabilityOfferProofChallenge {
        sequence_number: bigint;
        recipient_address: MoveAddressType;
    }
    namespace RotationCapabilityOfferProofChallenge {
        const TYPE_QNAME = "0x1::account::RotationCapabilityOfferProofChallenge";
        function type(): TypeDescriptor<RotationCapabilityOfferProofChallenge>;
    }
    interface RotationCapabilityOfferProofChallengeV2 {
        chain_id: number;
        sequence_number: bigint;
        source_address: MoveAddressType;
        recipient_address: MoveAddressType;
    }
    namespace RotationCapabilityOfferProofChallengeV2 {
        const TYPE_QNAME = "0x1::account::RotationCapabilityOfferProofChallengeV2";
        function type(): TypeDescriptor<RotationCapabilityOfferProofChallengeV2>;
    }
    interface RotationProofChallenge {
        sequence_number: bigint;
        originator: MoveAddressType;
        current_auth_key: MoveAddressType;
        new_public_key: string;
    }
    namespace RotationProofChallenge {
        const TYPE_QNAME = "0x1::account::RotationProofChallenge";
        function type(): TypeDescriptor<RotationProofChallenge>;
    }
    interface SignerCapability {
        account: MoveAddressType;
    }
    namespace SignerCapability {
        const TYPE_QNAME = "0x1::account::SignerCapability";
        function type(): TypeDescriptor<SignerCapability>;
    }
    interface SignerCapabilityInstance extends TypedEventInstance<SignerCapability> {
        data_decoded: SignerCapability;
        type_arguments: [];
    }
    interface SignerCapabilityOfferProofChallenge {
        sequence_number: bigint;
        recipient_address: MoveAddressType;
    }
    namespace SignerCapabilityOfferProofChallenge {
        const TYPE_QNAME = "0x1::account::SignerCapabilityOfferProofChallenge";
        function type(): TypeDescriptor<SignerCapabilityOfferProofChallenge>;
    }
    interface SignerCapabilityOfferProofChallengeV2 {
        sequence_number: bigint;
        source_address: MoveAddressType;
        recipient_address: MoveAddressType;
    }
    namespace SignerCapabilityOfferProofChallengeV2 {
        const TYPE_QNAME = "0x1::account::SignerCapabilityOfferProofChallengeV2";
        function type(): TypeDescriptor<SignerCapabilityOfferProofChallengeV2>;
    }
    interface OfferRotationCapabilityPayload extends TypedFunctionPayload<[string, number, string, MoveAddressType]> {
        arguments_decoded: [string, number, string, MoveAddressType];
        type_arguments: [];
    }
    interface OfferSignerCapabilityPayload extends TypedFunctionPayload<[string, number, string, MoveAddressType]> {
        arguments_decoded: [string, number, string, MoveAddressType];
        type_arguments: [];
    }
    interface RevokeAnyRotationCapabilityPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface RevokeAnySignerCapabilityPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface RevokeRotationCapabilityPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface RevokeSignerCapabilityPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface RotateAuthenticationKeyPayload extends TypedFunctionPayload<[
        number,
        string,
        number,
        string,
        string,
        string
    ]> {
        arguments_decoded: [number, string, number, string, string, string];
        type_arguments: [];
    }
    interface RotateAuthenticationKeyCallPayload extends TypedFunctionPayload<[string]> {
        arguments_decoded: [string];
        type_arguments: [];
    }
    interface RotateAuthenticationKeyWithRotationCapabilityPayload extends TypedFunctionPayload<[MoveAddressType, number, string, string]> {
        arguments_decoded: [MoveAddressType, number, string, string];
        type_arguments: [];
    }
}
export declare class ed25519 extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): ed25519;
    onEventSignature(func: (event: ed25519.SignatureInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): ed25519;
    onEventUnvalidatedPublicKey(func: (event: ed25519.UnvalidatedPublicKeyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): ed25519;
    onEventValidatedPublicKey(func: (event: ed25519.ValidatedPublicKeyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): ed25519;
}
export declare namespace ed25519 {
    interface Signature {
        bytes: string;
    }
    namespace Signature {
        const TYPE_QNAME = "0x1::ed25519::Signature";
        function type(): TypeDescriptor<Signature>;
    }
    interface SignatureInstance extends TypedEventInstance<Signature> {
        data_decoded: Signature;
        type_arguments: [];
    }
    interface SignedMessage<T0> {
        type_info: type_info.TypeInfo;
        inner: T0;
    }
    namespace SignedMessage {
        const TYPE_QNAME = "0x1::ed25519::SignedMessage";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<SignedMessage<T0>>;
    }
    interface UnvalidatedPublicKey {
        bytes: string;
    }
    namespace UnvalidatedPublicKey {
        const TYPE_QNAME = "0x1::ed25519::UnvalidatedPublicKey";
        function type(): TypeDescriptor<UnvalidatedPublicKey>;
    }
    interface UnvalidatedPublicKeyInstance extends TypedEventInstance<UnvalidatedPublicKey> {
        data_decoded: UnvalidatedPublicKey;
        type_arguments: [];
    }
    interface ValidatedPublicKey {
        bytes: string;
    }
    namespace ValidatedPublicKey {
        const TYPE_QNAME = "0x1::ed25519::ValidatedPublicKey";
        function type(): TypeDescriptor<ValidatedPublicKey>;
    }
    interface ValidatedPublicKeyInstance extends TypedEventInstance<ValidatedPublicKey> {
        data_decoded: ValidatedPublicKey;
        type_arguments: [];
    }
}
export declare namespace genesis {
    interface AccountMap {
        account_address: MoveAddressType;
        balance: bigint;
    }
    namespace AccountMap {
        const TYPE_QNAME = "0x1::genesis::AccountMap";
        function type(): TypeDescriptor<AccountMap>;
    }
    interface EmployeeAccountMap {
        accounts: MoveAddressType[];
        validator: genesis.ValidatorConfigurationWithCommission;
        vesting_schedule_numerator: bigint[];
        vesting_schedule_denominator: bigint;
        beneficiary_resetter: MoveAddressType;
    }
    namespace EmployeeAccountMap {
        const TYPE_QNAME = "0x1::genesis::EmployeeAccountMap";
        function type(): TypeDescriptor<EmployeeAccountMap>;
    }
    interface ValidatorConfiguration {
        owner_address: MoveAddressType;
        operator_address: MoveAddressType;
        voter_address: MoveAddressType;
        stake_amount: bigint;
        consensus_pubkey: string;
        proof_of_possession: string;
        network_addresses: string;
        full_node_network_addresses: string;
    }
    namespace ValidatorConfiguration {
        const TYPE_QNAME = "0x1::genesis::ValidatorConfiguration";
        function type(): TypeDescriptor<ValidatorConfiguration>;
    }
    interface ValidatorConfigurationWithCommission {
        validator_config: genesis.ValidatorConfiguration;
        commission_percentage: bigint;
        join_during_genesis: Boolean;
    }
    namespace ValidatorConfigurationWithCommission {
        const TYPE_QNAME = "0x1::genesis::ValidatorConfigurationWithCommission";
        function type(): TypeDescriptor<ValidatorConfigurationWithCommission>;
    }
}
export declare namespace math128 { }
export declare class version extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): version;
    onEntrySetForNextEpoch(func: (call: version.SetForNextEpochPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): version;
    onEntrySetVersion(func: (call: version.SetVersionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): version;
    onEventVersion(func: (event: version.VersionInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): version;
}
export declare namespace version {
    interface SetVersionCapability {
        dummy_field: Boolean;
    }
    namespace SetVersionCapability {
        const TYPE_QNAME = "0x1::version::SetVersionCapability";
        function type(): TypeDescriptor<SetVersionCapability>;
    }
    interface Version {
        major: bigint;
    }
    namespace Version {
        const TYPE_QNAME = "0x1::version::Version";
        function type(): TypeDescriptor<Version>;
    }
    interface VersionInstance extends TypedEventInstance<Version> {
        data_decoded: Version;
        type_arguments: [];
    }
    interface SetForNextEpochPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface SetVersionPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
}
export declare class vesting extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): vesting;
    onEntryAdminWithdraw(func: (call: vesting.AdminWithdrawPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryDistribute(func: (call: vesting.DistributePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryDistributeMany(func: (call: vesting.DistributeManyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryResetBeneficiary(func: (call: vesting.ResetBeneficiaryPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryResetLockup(func: (call: vesting.ResetLockupPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntrySetBeneficiary(func: (call: vesting.SetBeneficiaryPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntrySetBeneficiaryForOperator(func: (call: vesting.SetBeneficiaryForOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntrySetBeneficiaryResetter(func: (call: vesting.SetBeneficiaryResetterPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntrySetManagementRole(func: (call: vesting.SetManagementRolePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryTerminateVestingContract(func: (call: vesting.TerminateVestingContractPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryUnlockRewards(func: (call: vesting.UnlockRewardsPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryUnlockRewardsMany(func: (call: vesting.UnlockRewardsManyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryUpdateCommissionPercentage(func: (call: vesting.UpdateCommissionPercentagePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryUpdateOperator(func: (call: vesting.UpdateOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryUpdateOperatorWithSameCommission(func: (call: vesting.UpdateOperatorWithSameCommissionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryUpdateVoter(func: (call: vesting.UpdateVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryVest(func: (call: vesting.VestPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEntryVestMany(func: (call: vesting.VestManyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventAdminWithdraw(func: (event: vesting.AdminWithdrawInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventAdminWithdrawEvent(func: (event: vesting.AdminWithdrawEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventCreateVestingContract(func: (event: vesting.CreateVestingContractInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventCreateVestingContractEvent(func: (event: vesting.CreateVestingContractEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventDistribute(func: (event: vesting.DistributeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventDistributeEvent(func: (event: vesting.DistributeEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventResetLockup(func: (event: vesting.ResetLockupInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventResetLockupEvent(func: (event: vesting.ResetLockupEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventSetBeneficiary(func: (event: vesting.SetBeneficiaryInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventSetBeneficiaryEvent(func: (event: vesting.SetBeneficiaryEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventTerminate(func: (event: vesting.TerminateInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventTerminateEvent(func: (event: vesting.TerminateEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventUnlockRewards(func: (event: vesting.UnlockRewardsInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventUnlockRewardsEvent(func: (event: vesting.UnlockRewardsEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventUpdateOperator(func: (event: vesting.UpdateOperatorInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventUpdateOperatorEvent(func: (event: vesting.UpdateOperatorEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventUpdateVoter(func: (event: vesting.UpdateVoterInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventUpdateVoterEvent(func: (event: vesting.UpdateVoterEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventVest(func: (event: vesting.VestInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventVestEvent(func: (event: vesting.VestEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
    onEventVestingSchedule(func: (event: vesting.VestingScheduleInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): vesting;
}
export declare namespace vesting {
    interface AdminStore {
        vesting_contracts: MoveAddressType[];
        nonce: bigint;
        create_events: event.EventHandle<vesting.CreateVestingContractEvent>;
    }
    namespace AdminStore {
        const TYPE_QNAME = "0x1::vesting::AdminStore";
        function type(): TypeDescriptor<AdminStore>;
    }
    interface AdminWithdraw {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace AdminWithdraw {
        const TYPE_QNAME = "0x1::vesting::AdminWithdraw";
        function type(): TypeDescriptor<AdminWithdraw>;
    }
    interface AdminWithdrawInstance extends TypedEventInstance<AdminWithdraw> {
        data_decoded: AdminWithdraw;
        type_arguments: [];
    }
    interface AdminWithdrawEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace AdminWithdrawEvent {
        const TYPE_QNAME = "0x1::vesting::AdminWithdrawEvent";
        function type(): TypeDescriptor<AdminWithdrawEvent>;
    }
    interface AdminWithdrawEventInstance extends TypedEventInstance<AdminWithdrawEvent> {
        data_decoded: AdminWithdrawEvent;
        type_arguments: [];
    }
    interface CreateVestingContract {
        operator: MoveAddressType;
        voter: MoveAddressType;
        grant_amount: bigint;
        withdrawal_address: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace CreateVestingContract {
        const TYPE_QNAME = "0x1::vesting::CreateVestingContract";
        function type(): TypeDescriptor<CreateVestingContract>;
    }
    interface CreateVestingContractInstance extends TypedEventInstance<CreateVestingContract> {
        data_decoded: CreateVestingContract;
        type_arguments: [];
    }
    interface CreateVestingContractEvent {
        operator: MoveAddressType;
        voter: MoveAddressType;
        grant_amount: bigint;
        withdrawal_address: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace CreateVestingContractEvent {
        const TYPE_QNAME = "0x1::vesting::CreateVestingContractEvent";
        function type(): TypeDescriptor<CreateVestingContractEvent>;
    }
    interface CreateVestingContractEventInstance extends TypedEventInstance<CreateVestingContractEvent> {
        data_decoded: CreateVestingContractEvent;
        type_arguments: [];
    }
    interface Distribute {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace Distribute {
        const TYPE_QNAME = "0x1::vesting::Distribute";
        function type(): TypeDescriptor<Distribute>;
    }
    interface DistributeInstance extends TypedEventInstance<Distribute> {
        data_decoded: Distribute;
        type_arguments: [];
    }
    interface DistributeEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        amount: bigint;
    }
    namespace DistributeEvent {
        const TYPE_QNAME = "0x1::vesting::DistributeEvent";
        function type(): TypeDescriptor<DistributeEvent>;
    }
    interface DistributeEventInstance extends TypedEventInstance<DistributeEvent> {
        data_decoded: DistributeEvent;
        type_arguments: [];
    }
    interface ResetLockup {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        new_lockup_expiration_secs: bigint;
    }
    namespace ResetLockup {
        const TYPE_QNAME = "0x1::vesting::ResetLockup";
        function type(): TypeDescriptor<ResetLockup>;
    }
    interface ResetLockupInstance extends TypedEventInstance<ResetLockup> {
        data_decoded: ResetLockup;
        type_arguments: [];
    }
    interface ResetLockupEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        new_lockup_expiration_secs: bigint;
    }
    namespace ResetLockupEvent {
        const TYPE_QNAME = "0x1::vesting::ResetLockupEvent";
        function type(): TypeDescriptor<ResetLockupEvent>;
    }
    interface ResetLockupEventInstance extends TypedEventInstance<ResetLockupEvent> {
        data_decoded: ResetLockupEvent;
        type_arguments: [];
    }
    interface SetBeneficiary {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        shareholder: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiary {
        const TYPE_QNAME = "0x1::vesting::SetBeneficiary";
        function type(): TypeDescriptor<SetBeneficiary>;
    }
    interface SetBeneficiaryInstance extends TypedEventInstance<SetBeneficiary> {
        data_decoded: SetBeneficiary;
        type_arguments: [];
    }
    interface SetBeneficiaryEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        shareholder: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiaryEvent {
        const TYPE_QNAME = "0x1::vesting::SetBeneficiaryEvent";
        function type(): TypeDescriptor<SetBeneficiaryEvent>;
    }
    interface SetBeneficiaryEventInstance extends TypedEventInstance<SetBeneficiaryEvent> {
        data_decoded: SetBeneficiaryEvent;
        type_arguments: [];
    }
    interface StakingInfo {
        pool_address: MoveAddressType;
        operator: MoveAddressType;
        voter: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace StakingInfo {
        const TYPE_QNAME = "0x1::vesting::StakingInfo";
        function type(): TypeDescriptor<StakingInfo>;
    }
    interface Terminate {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
    }
    namespace Terminate {
        const TYPE_QNAME = "0x1::vesting::Terminate";
        function type(): TypeDescriptor<Terminate>;
    }
    interface TerminateInstance extends TypedEventInstance<Terminate> {
        data_decoded: Terminate;
        type_arguments: [];
    }
    interface TerminateEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
    }
    namespace TerminateEvent {
        const TYPE_QNAME = "0x1::vesting::TerminateEvent";
        function type(): TypeDescriptor<TerminateEvent>;
    }
    interface TerminateEventInstance extends TypedEventInstance<TerminateEvent> {
        data_decoded: TerminateEvent;
        type_arguments: [];
    }
    interface UnlockRewards {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace UnlockRewards {
        const TYPE_QNAME = "0x1::vesting::UnlockRewards";
        function type(): TypeDescriptor<UnlockRewards>;
    }
    interface UnlockRewardsInstance extends TypedEventInstance<UnlockRewards> {
        data_decoded: UnlockRewards;
        type_arguments: [];
    }
    interface UnlockRewardsEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace UnlockRewardsEvent {
        const TYPE_QNAME = "0x1::vesting::UnlockRewardsEvent";
        function type(): TypeDescriptor<UnlockRewardsEvent>;
    }
    interface UnlockRewardsEventInstance extends TypedEventInstance<UnlockRewardsEvent> {
        data_decoded: UnlockRewardsEvent;
        type_arguments: [];
    }
    interface UpdateOperator {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace UpdateOperator {
        const TYPE_QNAME = "0x1::vesting::UpdateOperator";
        function type(): TypeDescriptor<UpdateOperator>;
    }
    interface UpdateOperatorInstance extends TypedEventInstance<UpdateOperator> {
        data_decoded: UpdateOperator;
        type_arguments: [];
    }
    interface UpdateOperatorEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        commission_percentage: bigint;
    }
    namespace UpdateOperatorEvent {
        const TYPE_QNAME = "0x1::vesting::UpdateOperatorEvent";
        function type(): TypeDescriptor<UpdateOperatorEvent>;
    }
    interface UpdateOperatorEventInstance extends TypedEventInstance<UpdateOperatorEvent> {
        data_decoded: UpdateOperatorEvent;
        type_arguments: [];
    }
    interface UpdateVoter {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoter {
        const TYPE_QNAME = "0x1::vesting::UpdateVoter";
        function type(): TypeDescriptor<UpdateVoter>;
    }
    interface UpdateVoterInstance extends TypedEventInstance<UpdateVoter> {
        data_decoded: UpdateVoter;
        type_arguments: [];
    }
    interface UpdateVoterEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoterEvent {
        const TYPE_QNAME = "0x1::vesting::UpdateVoterEvent";
        function type(): TypeDescriptor<UpdateVoterEvent>;
    }
    interface UpdateVoterEventInstance extends TypedEventInstance<UpdateVoterEvent> {
        data_decoded: UpdateVoterEvent;
        type_arguments: [];
    }
    interface Vest {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        period_vested: bigint;
        amount: bigint;
    }
    namespace Vest {
        const TYPE_QNAME = "0x1::vesting::Vest";
        function type(): TypeDescriptor<Vest>;
    }
    interface VestInstance extends TypedEventInstance<Vest> {
        data_decoded: Vest;
        type_arguments: [];
    }
    interface VestEvent {
        admin: MoveAddressType;
        vesting_contract_address: MoveAddressType;
        staking_pool_address: MoveAddressType;
        period_vested: bigint;
        amount: bigint;
    }
    namespace VestEvent {
        const TYPE_QNAME = "0x1::vesting::VestEvent";
        function type(): TypeDescriptor<VestEvent>;
    }
    interface VestEventInstance extends TypedEventInstance<VestEvent> {
        data_decoded: VestEvent;
        type_arguments: [];
    }
    interface VestingAccountManagement {
        roles: simple_map.SimpleMap<string, MoveAddressType>;
    }
    namespace VestingAccountManagement {
        const TYPE_QNAME = "0x1::vesting::VestingAccountManagement";
        function type(): TypeDescriptor<VestingAccountManagement>;
    }
    interface VestingContract {
        state: bigint;
        admin: MoveAddressType;
        grant_pool: pool_u64.Pool;
        beneficiaries: simple_map.SimpleMap<MoveAddressType, MoveAddressType>;
        vesting_schedule: vesting.VestingSchedule;
        withdrawal_address: MoveAddressType;
        staking: vesting.StakingInfo;
        remaining_grant: bigint;
        signer_cap: account.SignerCapability;
        update_operator_events: event.EventHandle<vesting.UpdateOperatorEvent>;
        update_voter_events: event.EventHandle<vesting.UpdateVoterEvent>;
        reset_lockup_events: event.EventHandle<vesting.ResetLockupEvent>;
        set_beneficiary_events: event.EventHandle<vesting.SetBeneficiaryEvent>;
        unlock_rewards_events: event.EventHandle<vesting.UnlockRewardsEvent>;
        vest_events: event.EventHandle<vesting.VestEvent>;
        distribute_events: event.EventHandle<vesting.DistributeEvent>;
        terminate_events: event.EventHandle<vesting.TerminateEvent>;
        admin_withdraw_events: event.EventHandle<vesting.AdminWithdrawEvent>;
    }
    namespace VestingContract {
        const TYPE_QNAME = "0x1::vesting::VestingContract";
        function type(): TypeDescriptor<VestingContract>;
    }
    interface VestingSchedule {
        schedule: fixed_point32.FixedPoint32[];
        start_timestamp_secs: bigint;
        period_duration: bigint;
        last_vested_period: bigint;
    }
    namespace VestingSchedule {
        const TYPE_QNAME = "0x1::vesting::VestingSchedule";
        function type(): TypeDescriptor<VestingSchedule>;
    }
    interface VestingScheduleInstance extends TypedEventInstance<VestingSchedule> {
        data_decoded: VestingSchedule;
        type_arguments: [];
    }
    interface AdminWithdrawPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface DistributePayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface DistributeManyPayload extends TypedFunctionPayload<[MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[]];
        type_arguments: [];
    }
    interface ResetBeneficiaryPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface ResetLockupPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetBeneficiaryPayload extends TypedFunctionPayload<[
        MoveAddressType,
        MoveAddressType,
        MoveAddressType
    ]> {
        arguments_decoded: [MoveAddressType, MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetBeneficiaryForOperatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetBeneficiaryResetterPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetManagementRolePayload extends TypedFunctionPayload<[MoveAddressType, string, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, string, MoveAddressType];
        type_arguments: [];
    }
    interface TerminateVestingContractPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UnlockRewardsPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UnlockRewardsManyPayload extends TypedFunctionPayload<[MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[]];
        type_arguments: [];
    }
    interface UpdateCommissionPercentagePayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface UpdateOperatorPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, MoveAddressType, bigint];
        type_arguments: [];
    }
    interface UpdateOperatorWithSameCommissionPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface UpdateVoterPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface VestPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface VestManyPayload extends TypedFunctionPayload<[MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[]];
        type_arguments: [];
    }
}
export declare class bls12381 extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): bls12381;
    onEventAggrOrMultiSignature(func: (event: bls12381.AggrOrMultiSignatureInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): bls12381;
    onEventAggrPublicKeysWithPoP(func: (event: bls12381.AggrPublicKeysWithPoPInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): bls12381;
    onEventProofOfPossession(func: (event: bls12381.ProofOfPossessionInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): bls12381;
    onEventPublicKey(func: (event: bls12381.PublicKeyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): bls12381;
    onEventPublicKeyWithPoP(func: (event: bls12381.PublicKeyWithPoPInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): bls12381;
    onEventSignature(func: (event: bls12381.SignatureInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): bls12381;
}
export declare namespace bls12381 {
    interface AggrOrMultiSignature {
        bytes: string;
    }
    namespace AggrOrMultiSignature {
        const TYPE_QNAME = "0x1::bls12381::AggrOrMultiSignature";
        function type(): TypeDescriptor<AggrOrMultiSignature>;
    }
    interface AggrOrMultiSignatureInstance extends TypedEventInstance<AggrOrMultiSignature> {
        data_decoded: AggrOrMultiSignature;
        type_arguments: [];
    }
    interface AggrPublicKeysWithPoP {
        bytes: string;
    }
    namespace AggrPublicKeysWithPoP {
        const TYPE_QNAME = "0x1::bls12381::AggrPublicKeysWithPoP";
        function type(): TypeDescriptor<AggrPublicKeysWithPoP>;
    }
    interface AggrPublicKeysWithPoPInstance extends TypedEventInstance<AggrPublicKeysWithPoP> {
        data_decoded: AggrPublicKeysWithPoP;
        type_arguments: [];
    }
    interface ProofOfPossession {
        bytes: string;
    }
    namespace ProofOfPossession {
        const TYPE_QNAME = "0x1::bls12381::ProofOfPossession";
        function type(): TypeDescriptor<ProofOfPossession>;
    }
    interface ProofOfPossessionInstance extends TypedEventInstance<ProofOfPossession> {
        data_decoded: ProofOfPossession;
        type_arguments: [];
    }
    interface PublicKey {
        bytes: string;
    }
    namespace PublicKey {
        const TYPE_QNAME = "0x1::bls12381::PublicKey";
        function type(): TypeDescriptor<PublicKey>;
    }
    interface PublicKeyInstance extends TypedEventInstance<PublicKey> {
        data_decoded: PublicKey;
        type_arguments: [];
    }
    interface PublicKeyWithPoP {
        bytes: string;
    }
    namespace PublicKeyWithPoP {
        const TYPE_QNAME = "0x1::bls12381::PublicKeyWithPoP";
        function type(): TypeDescriptor<PublicKeyWithPoP>;
    }
    interface PublicKeyWithPoPInstance extends TypedEventInstance<PublicKeyWithPoP> {
        data_decoded: PublicKeyWithPoP;
        type_arguments: [];
    }
    interface Signature {
        bytes: string;
    }
    namespace Signature {
        const TYPE_QNAME = "0x1::bls12381::Signature";
        function type(): TypeDescriptor<Signature>;
    }
    interface SignatureInstance extends TypedEventInstance<Signature> {
        data_decoded: Signature;
        type_arguments: [];
    }
}
export declare namespace chain_id {
    interface ChainId {
        id: number;
    }
    namespace ChainId {
        const TYPE_QNAME = "0x1::chain_id::ChainId";
        function type(): TypeDescriptor<ChainId>;
    }
}
export declare namespace features {
    interface Features {
        features: string;
    }
    namespace Features {
        const TYPE_QNAME = "0x1::features::Features";
        function type(): TypeDescriptor<Features>;
    }
    interface PendingFeatures {
        features: string;
    }
    namespace PendingFeatures {
        const TYPE_QNAME = "0x1::features::PendingFeatures";
        function type(): TypeDescriptor<PendingFeatures>;
    }
}
export declare namespace from_bcs { }
export declare namespace pool_u64 {
    interface Pool {
        shareholders_limit: bigint;
        total_coins: bigint;
        total_shares: bigint;
        shares: simple_map.SimpleMap<MoveAddressType, bigint>;
        shareholders: MoveAddressType[];
        scaling_factor: bigint;
    }
    namespace Pool {
        const TYPE_QNAME = "0x1::pool_u64::Pool";
        function type(): TypeDescriptor<Pool>;
    }
}
export declare class secp256k1 extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): secp256k1;
    onEventECDSARawPublicKey(func: (event: secp256k1.ECDSARawPublicKeyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): secp256k1;
    onEventECDSASignature(func: (event: secp256k1.ECDSASignatureInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): secp256k1;
}
export declare namespace secp256k1 {
    interface ECDSARawPublicKey {
        bytes: string;
    }
    namespace ECDSARawPublicKey {
        const TYPE_QNAME = "0x1::secp256k1::ECDSARawPublicKey";
        function type(): TypeDescriptor<ECDSARawPublicKey>;
    }
    interface ECDSARawPublicKeyInstance extends TypedEventInstance<ECDSARawPublicKey> {
        data_decoded: ECDSARawPublicKey;
        type_arguments: [];
    }
    interface ECDSASignature {
        bytes: string;
    }
    namespace ECDSASignature {
        const TYPE_QNAME = "0x1::secp256k1::ECDSASignature";
        function type(): TypeDescriptor<ECDSASignature>;
    }
    interface ECDSASignatureInstance extends TypedEventInstance<ECDSASignature> {
        data_decoded: ECDSASignature;
        type_arguments: [];
    }
}
export declare namespace timestamp {
    interface CurrentTimeMicroseconds {
        microseconds: bigint;
    }
    namespace CurrentTimeMicroseconds {
        const TYPE_QNAME = "0x1::timestamp::CurrentTimeMicroseconds";
        function type(): TypeDescriptor<CurrentTimeMicroseconds>;
    }
}
export declare class type_info extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): type_info;
    onEventTypeInfo(func: (event: type_info.TypeInfoInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): type_info;
}
export declare namespace type_info {
    interface TypeInfo {
        account_address: MoveAddressType;
        module_name: string;
        struct_name: string;
    }
    namespace TypeInfo {
        const TYPE_QNAME = "0x1::type_info::TypeInfo";
        function type(): TypeDescriptor<TypeInfo>;
    }
    interface TypeInfoInstance extends TypedEventInstance<TypeInfo> {
        data_decoded: TypeInfo;
        type_arguments: [];
    }
}
export declare namespace aggregator {
    interface Aggregator {
        handle: MoveAddressType;
        key: MoveAddressType;
        limit: bigint;
    }
    namespace Aggregator {
        const TYPE_QNAME = "0x1::aggregator::Aggregator";
        function type(): TypeDescriptor<Aggregator>;
    }
}
export declare class aptos_coin extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): aptos_coin;
    onEntryClaimMintCapability(func: (call: aptos_coin.ClaimMintCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_coin;
    onEntryDelegateMintCapability(func: (call: aptos_coin.DelegateMintCapabilityPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_coin;
    onEntryMint(func: (call: aptos_coin.MintPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_coin;
}
export declare namespace aptos_coin {
    interface AptosCoin {
        dummy_field: Boolean;
    }
    namespace AptosCoin {
        const TYPE_QNAME = "0x1::aptos_coin::AptosCoin";
        function type(): TypeDescriptor<AptosCoin>;
    }
    interface DelegatedMintCapability {
        to: MoveAddressType;
    }
    namespace DelegatedMintCapability {
        const TYPE_QNAME = "0x1::aptos_coin::DelegatedMintCapability";
        function type(): TypeDescriptor<DelegatedMintCapability>;
    }
    interface Delegations {
        inner: aptos_coin.DelegatedMintCapability[];
    }
    namespace Delegations {
        const TYPE_QNAME = "0x1::aptos_coin::Delegations";
        function type(): TypeDescriptor<Delegations>;
    }
    interface MintCapStore {
        mint_cap: coin.MintCapability<aptos_coin.AptosCoin>;
    }
    namespace MintCapStore {
        const TYPE_QNAME = "0x1::aptos_coin::MintCapStore";
        function type(): TypeDescriptor<MintCapStore>;
    }
    interface ClaimMintCapabilityPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface DelegateMintCapabilityPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface MintPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
}
export declare namespace aptos_hash { }
export declare namespace big_vector {
    interface BigVector<T0> {
        buckets: table_with_length.TableWithLength<bigint, T0[] | string>;
        end_index: bigint;
        bucket_size: bigint;
    }
    namespace BigVector {
        const TYPE_QNAME = "0x1::big_vector::BigVector";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<BigVector<T0>>;
    }
}
export declare class bit_vector extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): bit_vector;
    onEventBitVector(func: (event: bit_vector.BitVectorInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): bit_vector;
}
export declare namespace bit_vector {
    interface BitVector {
        length: bigint;
        bit_field: Boolean[];
    }
    namespace BitVector {
        const TYPE_QNAME = "0x1::bit_vector::BitVector";
        function type(): TypeDescriptor<BitVector>;
    }
    interface BitVectorInstance extends TypedEventInstance<BitVector> {
        data_decoded: BitVector;
        type_arguments: [];
    }
}
export declare namespace capability {
    interface Cap<T0> {
        root: MoveAddressType;
    }
    namespace Cap {
        const TYPE_QNAME = "0x1::capability::Cap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Cap<T0>>;
    }
    interface CapDelegateState<T0> {
        root: MoveAddressType;
    }
    namespace CapDelegateState {
        const TYPE_QNAME = "0x1::capability::CapDelegateState";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CapDelegateState<T0>>;
    }
    interface CapState<T0> {
        delegates: MoveAddressType[];
    }
    namespace CapState {
        const TYPE_QNAME = "0x1::capability::CapState";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<CapState<T0>>;
    }
    interface LinearCap<T0> {
        root: MoveAddressType;
    }
    namespace LinearCap {
        const TYPE_QNAME = "0x1::capability::LinearCap";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<LinearCap<T0>>;
    }
}
export declare namespace comparator {
    interface Result {
        inner: number;
    }
    namespace Result {
        const TYPE_QNAME = "0x1::comparator::Result";
        function type(): TypeDescriptor<Result>;
    }
}
export declare namespace math_fixed { }
export declare class randomness extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): randomness;
    onEventRandomnessGeneratedEvent(func: (event: randomness.RandomnessGeneratedEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): randomness;
}
export declare namespace randomness {
    interface PerBlockRandomness {
        epoch: bigint;
        round: bigint;
        seed: option.Option<string>;
    }
    namespace PerBlockRandomness {
        const TYPE_QNAME = "0x1::randomness::PerBlockRandomness";
        function type(): TypeDescriptor<PerBlockRandomness>;
    }
    interface RandomnessGeneratedEvent {
        dummy_field: Boolean;
    }
    namespace RandomnessGeneratedEvent {
        const TYPE_QNAME = "0x1::randomness::RandomnessGeneratedEvent";
        function type(): TypeDescriptor<RandomnessGeneratedEvent>;
    }
    interface RandomnessGeneratedEventInstance extends TypedEventInstance<RandomnessGeneratedEvent> {
        data_decoded: RandomnessGeneratedEvent;
        type_arguments: [];
    }
}
export declare class simple_map extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): simple_map;
    onEventElement(func: (event: simple_map.ElementInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): simple_map;
    onEventSimpleMap(func: (event: simple_map.SimpleMapInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): simple_map;
}
export declare namespace simple_map {
    interface Element<T0, T1> {
        key: T0;
        value: T1;
    }
    namespace Element {
        const TYPE_QNAME = "0x1::simple_map::Element";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Element<T0, T1>>;
    }
    interface ElementInstance extends TypedEventInstance<Element<any, any>> {
        data_decoded: Element<any, any>;
        type_arguments: [string, string];
    }
    interface SimpleMap<T0, T1> {
        data: simple_map.Element<T0, T1>[];
    }
    namespace SimpleMap {
        const TYPE_QNAME = "0x1::simple_map::SimpleMap";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<SimpleMap<T0, T1>>;
    }
    interface SimpleMapInstance extends TypedEventInstance<SimpleMap<any, any>> {
        data_decoded: SimpleMap<any, any>;
        type_arguments: [string, string];
    }
}
export declare class smart_table extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): smart_table;
    onEventEntry(func: (event: smart_table.EntryInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): smart_table;
}
export declare namespace smart_table {
    interface Entry<T0, T1> {
        hash: bigint;
        key: T0;
        value: T1;
    }
    namespace Entry {
        const TYPE_QNAME = "0x1::smart_table::Entry";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Entry<T0, T1>>;
    }
    interface EntryInstance extends TypedEventInstance<Entry<any, any>> {
        data_decoded: Entry<any, any>;
        type_arguments: [string, string];
    }
    interface SmartTable<T0, T1> {
        buckets: table_with_length.TableWithLength<bigint, smart_table.Entry<T0, T1>[]>;
        num_buckets: bigint;
        level: number;
        size: bigint;
        split_load_threshold: number;
        target_bucket_size: bigint;
    }
    namespace SmartTable {
        const TYPE_QNAME = "0x1::smart_table::SmartTable";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<SmartTable<T0, T1>>;
    }
}
export declare class storage_gas extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): storage_gas;
    onEventGasCurve(func: (event: storage_gas.GasCurveInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): storage_gas;
    onEventPoint(func: (event: storage_gas.PointInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): storage_gas;
    onEventUsageGasConfig(func: (event: storage_gas.UsageGasConfigInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): storage_gas;
}
export declare namespace storage_gas {
    interface GasCurve {
        min_gas: bigint;
        max_gas: bigint;
        points: storage_gas.Point[];
    }
    namespace GasCurve {
        const TYPE_QNAME = "0x1::storage_gas::GasCurve";
        function type(): TypeDescriptor<GasCurve>;
    }
    interface GasCurveInstance extends TypedEventInstance<GasCurve> {
        data_decoded: GasCurve;
        type_arguments: [];
    }
    interface Point {
        x: bigint;
        y: bigint;
    }
    namespace Point {
        const TYPE_QNAME = "0x1::storage_gas::Point";
        function type(): TypeDescriptor<Point>;
    }
    interface PointInstance extends TypedEventInstance<Point> {
        data_decoded: Point;
        type_arguments: [];
    }
    interface StorageGas {
        per_item_read: bigint;
        per_item_create: bigint;
        per_item_write: bigint;
        per_byte_read: bigint;
        per_byte_create: bigint;
        per_byte_write: bigint;
    }
    namespace StorageGas {
        const TYPE_QNAME = "0x1::storage_gas::StorageGas";
        function type(): TypeDescriptor<StorageGas>;
    }
    interface StorageGasConfig {
        item_config: storage_gas.UsageGasConfig;
        byte_config: storage_gas.UsageGasConfig;
    }
    namespace StorageGasConfig {
        const TYPE_QNAME = "0x1::storage_gas::StorageGasConfig";
        function type(): TypeDescriptor<StorageGasConfig>;
    }
    interface UsageGasConfig {
        target_usage: bigint;
        read_curve: storage_gas.GasCurve;
        create_curve: storage_gas.GasCurve;
        write_curve: storage_gas.GasCurve;
    }
    namespace UsageGasConfig {
        const TYPE_QNAME = "0x1::storage_gas::UsageGasConfig";
        function type(): TypeDescriptor<UsageGasConfig>;
    }
    interface UsageGasConfigInstance extends TypedEventInstance<UsageGasConfig> {
        data_decoded: UsageGasConfig;
        type_arguments: [];
    }
}
export declare namespace chain_status {
    interface GenesisEndMarker {
        dummy_field: Boolean;
    }
    namespace GenesisEndMarker {
        const TYPE_QNAME = "0x1::chain_status::GenesisEndMarker";
        function type(): TypeDescriptor<GenesisEndMarker>;
    }
}
export declare class copyable_any extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): copyable_any;
    onEventAny(func: (event: copyable_any.AnyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): copyable_any;
}
export declare namespace copyable_any {
    interface Any {
        type_name: string;
        data: string;
    }
    namespace Any {
        const TYPE_QNAME = "0x1::copyable_any::Any";
        function type(): TypeDescriptor<Any>;
    }
    interface AnyInstance extends TypedEventInstance<Any> {
        data_decoded: Any;
        type_arguments: [];
    }
}
export declare class gas_schedule extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): gas_schedule;
    onEventGasEntry(func: (event: gas_schedule.GasEntryInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): gas_schedule;
    onEventGasScheduleV2(func: (event: gas_schedule.GasScheduleV2Instance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): gas_schedule;
}
export declare namespace gas_schedule {
    interface GasEntry {
        key: string;
        val: bigint;
    }
    namespace GasEntry {
        const TYPE_QNAME = "0x1::gas_schedule::GasEntry";
        function type(): TypeDescriptor<GasEntry>;
    }
    interface GasEntryInstance extends TypedEventInstance<GasEntry> {
        data_decoded: GasEntry;
        type_arguments: [];
    }
    interface GasSchedule {
        entries: gas_schedule.GasEntry[];
    }
    namespace GasSchedule {
        const TYPE_QNAME = "0x1::gas_schedule::GasSchedule";
        function type(): TypeDescriptor<GasSchedule>;
    }
    interface GasScheduleV2 {
        feature_version: bigint;
        entries: gas_schedule.GasEntry[];
    }
    namespace GasScheduleV2 {
        const TYPE_QNAME = "0x1::gas_schedule::GasScheduleV2";
        function type(): TypeDescriptor<GasScheduleV2>;
    }
    interface GasScheduleV2Instance extends TypedEventInstance<GasScheduleV2> {
        data_decoded: GasScheduleV2;
        type_arguments: [];
    }
}
export declare class managed_coin extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): managed_coin;
    onEntryBurn(func: (call: managed_coin.BurnPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): managed_coin;
    onEntryInitialize(func: (call: managed_coin.InitializePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): managed_coin;
    onEntryMint(func: (call: managed_coin.MintPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): managed_coin;
    onEntryRegister(func: (call: managed_coin.RegisterPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): managed_coin;
}
export declare namespace managed_coin {
    interface Capabilities<T0> {
        burn_cap: coin.BurnCapability<T0>;
        freeze_cap: coin.FreezeCapability<T0>;
        mint_cap: coin.MintCapability<T0>;
    }
    namespace Capabilities {
        const TYPE_QNAME = "0x1::managed_coin::Capabilities";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Capabilities<T0>>;
    }
    interface BurnPayload<T0 = any> extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [string];
    }
    interface InitializePayload<T0 = any> extends TypedFunctionPayload<[string, string, number, Boolean]> {
        arguments_decoded: [string, string, number, Boolean];
        type_arguments: [string];
    }
    interface MintPayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [string];
    }
    interface RegisterPayload<T0 = any> extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [string];
    }
}
export declare namespace math_fixed64 { }
export declare class ristretto255 extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): ristretto255;
    onEventCompressedRistretto(func: (event: ristretto255.CompressedRistrettoInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): ristretto255;
    onEventScalar(func: (event: ristretto255.ScalarInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): ristretto255;
}
export declare namespace ristretto255 {
    interface CompressedRistretto {
        data: string;
    }
    namespace CompressedRistretto {
        const TYPE_QNAME = "0x1::ristretto255::CompressedRistretto";
        function type(): TypeDescriptor<CompressedRistretto>;
    }
    interface CompressedRistrettoInstance extends TypedEventInstance<CompressedRistretto> {
        data_decoded: CompressedRistretto;
        type_arguments: [];
    }
    interface RistrettoPoint {
        handle: bigint;
    }
    namespace RistrettoPoint {
        const TYPE_QNAME = "0x1::ristretto255::RistrettoPoint";
        function type(): TypeDescriptor<RistrettoPoint>;
    }
    interface Scalar {
        data: string;
    }
    namespace Scalar {
        const TYPE_QNAME = "0x1::ristretto255::Scalar";
        function type(): TypeDescriptor<Scalar>;
    }
    interface ScalarInstance extends TypedEventInstance<Scalar> {
        data_decoded: Scalar;
        type_arguments: [];
    }
}
export declare namespace smart_vector {
    interface SmartVector<T0> {
        inline_vec: T0[] | string;
        big_vec: option.Option<big_vector.BigVector<T0>>;
        inline_capacity: option.Option<bigint>;
        bucket_size: option.Option<bigint>;
    }
    namespace SmartVector {
        const TYPE_QNAME = "0x1::smart_vector::SmartVector";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<SmartVector<T0>>;
    }
}
export declare class string_utils extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): string_utils;
    onEventCons(func: (event: string_utils.ConsInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): string_utils;
    onEventFakeCons(func: (event: string_utils.FakeConsInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): string_utils;
    onEventNIL(func: (event: string_utils.NILInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): string_utils;
}
export declare namespace string_utils {
    interface Cons<T0, T1> {
        car: T0;
        cdr: T1;
    }
    namespace Cons {
        const TYPE_QNAME = "0x1::string_utils::Cons";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<Cons<T0, T1>>;
    }
    interface ConsInstance extends TypedEventInstance<Cons<any, any>> {
        data_decoded: Cons<any, any>;
        type_arguments: [string, string];
    }
    interface FakeCons<T0, T1> {
        car: T0;
        cdr: T1;
    }
    namespace FakeCons {
        const TYPE_QNAME = "0x1::string_utils::FakeCons";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<FakeCons<T0, T1>>;
    }
    interface FakeConsInstance extends TypedEventInstance<FakeCons<any, any>> {
        data_decoded: FakeCons<any, any>;
        type_arguments: [string, string];
    }
    interface NIL {
        dummy_field: Boolean;
    }
    namespace NIL {
        const TYPE_QNAME = "0x1::string_utils::NIL";
        function type(): TypeDescriptor<NIL>;
    }
    interface NILInstance extends TypedEventInstance<NIL> {
        data_decoded: NIL;
        type_arguments: [];
    }
}
export declare class aggregator_v2 extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): aggregator_v2;
    onEventAggregator(func: (event: aggregator_v2.AggregatorInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): aggregator_v2;
    onEventAggregatorSnapshot(func: (event: aggregator_v2.AggregatorSnapshotInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): aggregator_v2;
    onEventDerivedStringSnapshot(func: (event: aggregator_v2.DerivedStringSnapshotInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): aggregator_v2;
}
export declare namespace aggregator_v2 {
    interface Aggregator<T0> {
        value: T0;
        max_value: T0;
    }
    namespace Aggregator {
        const TYPE_QNAME = "0x1::aggregator_v2::Aggregator";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Aggregator<T0>>;
    }
    interface AggregatorInstance extends TypedEventInstance<Aggregator<any>> {
        data_decoded: Aggregator<any>;
        type_arguments: [string];
    }
    interface AggregatorSnapshot<T0> {
        value: T0;
    }
    namespace AggregatorSnapshot {
        const TYPE_QNAME = "0x1::aggregator_v2::AggregatorSnapshot";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<AggregatorSnapshot<T0>>;
    }
    interface AggregatorSnapshotInstance extends TypedEventInstance<AggregatorSnapshot<any>> {
        data_decoded: AggregatorSnapshot<any>;
        type_arguments: [string];
    }
    interface DerivedStringSnapshot {
        value: string;
        padding: string;
    }
    namespace DerivedStringSnapshot {
        const TYPE_QNAME = "0x1::aggregator_v2::DerivedStringSnapshot";
        function type(): TypeDescriptor<DerivedStringSnapshot>;
    }
    interface DerivedStringSnapshotInstance extends TypedEventInstance<DerivedStringSnapshot> {
        data_decoded: DerivedStringSnapshot;
        type_arguments: [];
    }
}
export declare class aptos_account extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): aptos_account;
    onEntryBatchTransfer(func: (call: aptos_account.BatchTransferPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_account;
    onEntryBatchTransferCoins(func: (call: aptos_account.BatchTransferCoinsPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_account;
    onEntryCreateAccount(func: (call: aptos_account.CreateAccountPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_account;
    onEntrySetAllowDirectCoinTransfers(func: (call: aptos_account.SetAllowDirectCoinTransfersPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_account;
    onEntryTransfer(func: (call: aptos_account.TransferPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_account;
    onEntryTransferCoins(func: (call: aptos_account.TransferCoinsPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_account;
    onEventDirectCoinTransferConfigUpdated(func: (event: aptos_account.DirectCoinTransferConfigUpdatedInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): aptos_account;
    onEventDirectCoinTransferConfigUpdatedEvent(func: (event: aptos_account.DirectCoinTransferConfigUpdatedEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): aptos_account;
}
export declare namespace aptos_account {
    interface DirectCoinTransferConfigUpdated {
        account: MoveAddressType;
        new_allow_direct_transfers: Boolean;
    }
    namespace DirectCoinTransferConfigUpdated {
        const TYPE_QNAME = "0x1::aptos_account::DirectCoinTransferConfigUpdated";
        function type(): TypeDescriptor<DirectCoinTransferConfigUpdated>;
    }
    interface DirectCoinTransferConfigUpdatedInstance extends TypedEventInstance<DirectCoinTransferConfigUpdated> {
        data_decoded: DirectCoinTransferConfigUpdated;
        type_arguments: [];
    }
    interface DirectCoinTransferConfigUpdatedEvent {
        new_allow_direct_transfers: Boolean;
    }
    namespace DirectCoinTransferConfigUpdatedEvent {
        const TYPE_QNAME = "0x1::aptos_account::DirectCoinTransferConfigUpdatedEvent";
        function type(): TypeDescriptor<DirectCoinTransferConfigUpdatedEvent>;
    }
    interface DirectCoinTransferConfigUpdatedEventInstance extends TypedEventInstance<DirectCoinTransferConfigUpdatedEvent> {
        data_decoded: DirectCoinTransferConfigUpdatedEvent;
        type_arguments: [];
    }
    interface DirectTransferConfig {
        allow_arbitrary_coin_transfers: Boolean;
        update_coin_transfer_events: event.EventHandle<aptos_account.DirectCoinTransferConfigUpdatedEvent>;
    }
    namespace DirectTransferConfig {
        const TYPE_QNAME = "0x1::aptos_account::DirectTransferConfig";
        function type(): TypeDescriptor<DirectTransferConfig>;
    }
    interface BatchTransferPayload extends TypedFunctionPayload<[MoveAddressType[], bigint[]]> {
        arguments_decoded: [MoveAddressType[], bigint[]];
        type_arguments: [];
    }
    interface BatchTransferCoinsPayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType[], bigint[]]> {
        arguments_decoded: [MoveAddressType[], bigint[]];
        type_arguments: [string];
    }
    interface CreateAccountPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetAllowDirectCoinTransfersPayload extends TypedFunctionPayload<[Boolean]> {
        arguments_decoded: [Boolean];
        type_arguments: [];
    }
    interface TransferPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface TransferCoinsPayload<T0 = any> extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [string];
    }
}
export declare namespace bn254_algebra {
    interface FormatFq12LscLsb {
        dummy_field: Boolean;
    }
    namespace FormatFq12LscLsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFq12LscLsb";
        function type(): TypeDescriptor<FormatFq12LscLsb>;
    }
    interface FormatFqLsb {
        dummy_field: Boolean;
    }
    namespace FormatFqLsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFqLsb";
        function type(): TypeDescriptor<FormatFqLsb>;
    }
    interface FormatFqMsb {
        dummy_field: Boolean;
    }
    namespace FormatFqMsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFqMsb";
        function type(): TypeDescriptor<FormatFqMsb>;
    }
    interface FormatFrLsb {
        dummy_field: Boolean;
    }
    namespace FormatFrLsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFrLsb";
        function type(): TypeDescriptor<FormatFrLsb>;
    }
    interface FormatFrMsb {
        dummy_field: Boolean;
    }
    namespace FormatFrMsb {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatFrMsb";
        function type(): TypeDescriptor<FormatFrMsb>;
    }
    interface FormatG1Compr {
        dummy_field: Boolean;
    }
    namespace FormatG1Compr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG1Compr";
        function type(): TypeDescriptor<FormatG1Compr>;
    }
    interface FormatG1Uncompr {
        dummy_field: Boolean;
    }
    namespace FormatG1Uncompr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG1Uncompr";
        function type(): TypeDescriptor<FormatG1Uncompr>;
    }
    interface FormatG2Compr {
        dummy_field: Boolean;
    }
    namespace FormatG2Compr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG2Compr";
        function type(): TypeDescriptor<FormatG2Compr>;
    }
    interface FormatG2Uncompr {
        dummy_field: Boolean;
    }
    namespace FormatG2Uncompr {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatG2Uncompr";
        function type(): TypeDescriptor<FormatG2Uncompr>;
    }
    interface FormatGt {
        dummy_field: Boolean;
    }
    namespace FormatGt {
        const TYPE_QNAME = "0x1::bn254_algebra::FormatGt";
        function type(): TypeDescriptor<FormatGt>;
    }
    interface Fq {
        dummy_field: Boolean;
    }
    namespace Fq {
        const TYPE_QNAME = "0x1::bn254_algebra::Fq";
        function type(): TypeDescriptor<Fq>;
    }
    interface Fq12 {
        dummy_field: Boolean;
    }
    namespace Fq12 {
        const TYPE_QNAME = "0x1::bn254_algebra::Fq12";
        function type(): TypeDescriptor<Fq12>;
    }
    interface Fr {
        dummy_field: Boolean;
    }
    namespace Fr {
        const TYPE_QNAME = "0x1::bn254_algebra::Fr";
        function type(): TypeDescriptor<Fr>;
    }
    interface G1 {
        dummy_field: Boolean;
    }
    namespace G1 {
        const TYPE_QNAME = "0x1::bn254_algebra::G1";
        function type(): TypeDescriptor<G1>;
    }
    interface G2 {
        dummy_field: Boolean;
    }
    namespace G2 {
        const TYPE_QNAME = "0x1::bn254_algebra::G2";
        function type(): TypeDescriptor<G2>;
    }
    interface Gt {
        dummy_field: Boolean;
    }
    namespace Gt {
        const TYPE_QNAME = "0x1::bn254_algebra::Gt";
        function type(): TypeDescriptor<Gt>;
    }
}
export declare namespace config_buffer {
    interface PendingConfigs {
        configs: simple_map.SimpleMap<string, any_.Any>;
    }
    namespace PendingConfigs {
        const TYPE_QNAME = "0x1::config_buffer::PendingConfigs";
        function type(): TypeDescriptor<PendingConfigs>;
    }
}
export declare namespace create_signer { }
export declare class fixed_point32 extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): fixed_point32;
    onEventFixedPoint32(func: (event: fixed_point32.FixedPoint32Instance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fixed_point32;
}
export declare namespace fixed_point32 {
    interface FixedPoint32 {
        value: bigint;
    }
    namespace FixedPoint32 {
        const TYPE_QNAME = "0x1::fixed_point32::FixedPoint32";
        function type(): TypeDescriptor<FixedPoint32>;
    }
    interface FixedPoint32Instance extends TypedEventInstance<FixedPoint32> {
        data_decoded: FixedPoint32;
        type_arguments: [];
    }
}
export declare class fixed_point64 extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): fixed_point64;
    onEventFixedPoint64(func: (event: fixed_point64.FixedPoint64Instance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fixed_point64;
}
export declare namespace fixed_point64 {
    interface FixedPoint64 {
        value: bigint;
    }
    namespace FixedPoint64 {
        const TYPE_QNAME = "0x1::fixed_point64::FixedPoint64";
        function type(): TypeDescriptor<FixedPoint64>;
    }
    interface FixedPoint64Instance extends TypedEventInstance<FixedPoint64> {
        data_decoded: FixedPoint64;
        type_arguments: [];
    }
}
export declare class function_info extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): function_info;
    onEventFunctionInfo(func: (event: function_info.FunctionInfoInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): function_info;
}
export declare namespace function_info {
    interface FunctionInfo {
        module_address: MoveAddressType;
        module_name: string;
        function_name: string;
    }
    namespace FunctionInfo {
        const TYPE_QNAME = "0x1::function_info::FunctionInfo";
        function type(): TypeDescriptor<FunctionInfo>;
    }
    interface FunctionInfoInstance extends TypedEventInstance<FunctionInfo> {
        data_decoded: FunctionInfo;
        type_arguments: [];
    }
}
export declare class multi_ed25519 extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): multi_ed25519;
    onEventSignature(func: (event: multi_ed25519.SignatureInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multi_ed25519;
    onEventUnvalidatedPublicKey(func: (event: multi_ed25519.UnvalidatedPublicKeyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multi_ed25519;
    onEventValidatedPublicKey(func: (event: multi_ed25519.ValidatedPublicKeyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multi_ed25519;
}
export declare namespace multi_ed25519 {
    interface Signature {
        bytes: string;
    }
    namespace Signature {
        const TYPE_QNAME = "0x1::multi_ed25519::Signature";
        function type(): TypeDescriptor<Signature>;
    }
    interface SignatureInstance extends TypedEventInstance<Signature> {
        data_decoded: Signature;
        type_arguments: [];
    }
    interface UnvalidatedPublicKey {
        bytes: string;
    }
    namespace UnvalidatedPublicKey {
        const TYPE_QNAME = "0x1::multi_ed25519::UnvalidatedPublicKey";
        function type(): TypeDescriptor<UnvalidatedPublicKey>;
    }
    interface UnvalidatedPublicKeyInstance extends TypedEventInstance<UnvalidatedPublicKey> {
        data_decoded: UnvalidatedPublicKey;
        type_arguments: [];
    }
    interface ValidatedPublicKey {
        bytes: string;
    }
    namespace ValidatedPublicKey {
        const TYPE_QNAME = "0x1::multi_ed25519::ValidatedPublicKey";
        function type(): TypeDescriptor<ValidatedPublicKey>;
    }
    interface ValidatedPublicKeyInstance extends TypedEventInstance<ValidatedPublicKey> {
        data_decoded: ValidatedPublicKey;
        type_arguments: [];
    }
}
export declare class staking_proxy extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): staking_proxy;
    onEntrySetOperator(func: (call: staking_proxy.SetOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_proxy;
    onEntrySetStakePoolOperator(func: (call: staking_proxy.SetStakePoolOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_proxy;
    onEntrySetStakePoolVoter(func: (call: staking_proxy.SetStakePoolVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_proxy;
    onEntrySetStakingContractOperator(func: (call: staking_proxy.SetStakingContractOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_proxy;
    onEntrySetStakingContractVoter(func: (call: staking_proxy.SetStakingContractVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_proxy;
    onEntrySetVestingContractOperator(func: (call: staking_proxy.SetVestingContractOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_proxy;
    onEntrySetVestingContractVoter(func: (call: staking_proxy.SetVestingContractVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_proxy;
    onEntrySetVoter(func: (call: staking_proxy.SetVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_proxy;
}
export declare namespace staking_proxy {
    interface SetOperatorPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetStakePoolOperatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetStakePoolVoterPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetStakingContractOperatorPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetStakingContractVoterPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetVestingContractOperatorPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetVestingContractVoterPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SetVoterPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
}
export declare class state_storage extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): state_storage;
    onEventUsage(func: (event: state_storage.UsageInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): state_storage;
}
export declare namespace state_storage {
    interface GasParameter {
        usage: state_storage.Usage;
    }
    namespace GasParameter {
        const TYPE_QNAME = "0x1::state_storage::GasParameter";
        function type(): TypeDescriptor<GasParameter>;
    }
    interface StateStorageUsage {
        epoch: bigint;
        usage: state_storage.Usage;
    }
    namespace StateStorageUsage {
        const TYPE_QNAME = "0x1::state_storage::StateStorageUsage";
        function type(): TypeDescriptor<StateStorageUsage>;
    }
    interface Usage {
        items: bigint;
        bytes: bigint;
    }
    namespace Usage {
        const TYPE_QNAME = "0x1::state_storage::Usage";
        function type(): TypeDescriptor<Usage>;
    }
    interface UsageInstance extends TypedEventInstance<Usage> {
        data_decoded: Usage;
        type_arguments: [];
    }
}
export declare namespace crypto_algebra {
    interface Element<T0> {
        handle: bigint;
    }
    namespace Element {
        const TYPE_QNAME = "0x1::crypto_algebra::Element";
        function type<T0>(arg0?: TypeDescriptor<T0>): TypeDescriptor<Element<T0>>;
    }
}
export declare class fungible_asset extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): fungible_asset;
    onEntryTransfer(func: (call: fungible_asset.TransferPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): fungible_asset;
    onEntryUpgradeStoreToConcurrent(func: (call: fungible_asset.UpgradeStoreToConcurrentPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): fungible_asset;
    onEventBurnRef(func: (event: fungible_asset.BurnRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fungible_asset;
    onEventDeposit(func: (event: fungible_asset.DepositInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fungible_asset;
    onEventDepositEvent(func: (event: fungible_asset.DepositEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fungible_asset;
    onEventFrozen(func: (event: fungible_asset.FrozenInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fungible_asset;
    onEventFrozenEvent(func: (event: fungible_asset.FrozenEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fungible_asset;
    onEventMintRef(func: (event: fungible_asset.MintRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fungible_asset;
    onEventMutateMetadataRef(func: (event: fungible_asset.MutateMetadataRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fungible_asset;
    onEventTransferRef(func: (event: fungible_asset.TransferRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fungible_asset;
    onEventWithdraw(func: (event: fungible_asset.WithdrawInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fungible_asset;
    onEventWithdrawEvent(func: (event: fungible_asset.WithdrawEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): fungible_asset;
}
export declare namespace fungible_asset {
    interface BurnRef {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace BurnRef {
        const TYPE_QNAME = "0x1::fungible_asset::BurnRef";
        function type(): TypeDescriptor<BurnRef>;
    }
    interface BurnRefInstance extends TypedEventInstance<BurnRef> {
        data_decoded: BurnRef;
        type_arguments: [];
    }
    interface ConcurrentFungibleBalance {
        balance: aggregator_v2.Aggregator<bigint>;
    }
    namespace ConcurrentFungibleBalance {
        const TYPE_QNAME = "0x1::fungible_asset::ConcurrentFungibleBalance";
        function type(): TypeDescriptor<ConcurrentFungibleBalance>;
    }
    interface ConcurrentSupply {
        current: aggregator_v2.Aggregator<bigint>;
    }
    namespace ConcurrentSupply {
        const TYPE_QNAME = "0x1::fungible_asset::ConcurrentSupply";
        function type(): TypeDescriptor<ConcurrentSupply>;
    }
    interface Deposit {
        store: MoveAddressType;
        amount: bigint;
    }
    namespace Deposit {
        const TYPE_QNAME = "0x1::fungible_asset::Deposit";
        function type(): TypeDescriptor<Deposit>;
    }
    interface DepositInstance extends TypedEventInstance<Deposit> {
        data_decoded: Deposit;
        type_arguments: [];
    }
    interface DepositEvent {
        amount: bigint;
    }
    namespace DepositEvent {
        const TYPE_QNAME = "0x1::fungible_asset::DepositEvent";
        function type(): TypeDescriptor<DepositEvent>;
    }
    interface DepositEventInstance extends TypedEventInstance<DepositEvent> {
        data_decoded: DepositEvent;
        type_arguments: [];
    }
    interface DeriveSupply {
        dispatch_function: option.Option<function_info.FunctionInfo>;
    }
    namespace DeriveSupply {
        const TYPE_QNAME = "0x1::fungible_asset::DeriveSupply";
        function type(): TypeDescriptor<DeriveSupply>;
    }
    interface DispatchFunctionStore {
        withdraw_function: option.Option<function_info.FunctionInfo>;
        deposit_function: option.Option<function_info.FunctionInfo>;
        derived_balance_function: option.Option<function_info.FunctionInfo>;
    }
    namespace DispatchFunctionStore {
        const TYPE_QNAME = "0x1::fungible_asset::DispatchFunctionStore";
        function type(): TypeDescriptor<DispatchFunctionStore>;
    }
    interface Frozen {
        store: MoveAddressType;
        frozen: Boolean;
    }
    namespace Frozen {
        const TYPE_QNAME = "0x1::fungible_asset::Frozen";
        function type(): TypeDescriptor<Frozen>;
    }
    interface FrozenInstance extends TypedEventInstance<Frozen> {
        data_decoded: Frozen;
        type_arguments: [];
    }
    interface FrozenEvent {
        frozen: Boolean;
    }
    namespace FrozenEvent {
        const TYPE_QNAME = "0x1::fungible_asset::FrozenEvent";
        function type(): TypeDescriptor<FrozenEvent>;
    }
    interface FrozenEventInstance extends TypedEventInstance<FrozenEvent> {
        data_decoded: FrozenEvent;
        type_arguments: [];
    }
    interface FungibleAsset {
        metadata: object_.Object<fungible_asset.Metadata>;
        amount: bigint;
    }
    namespace FungibleAsset {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleAsset";
        function type(): TypeDescriptor<FungibleAsset>;
    }
    interface FungibleAssetEvents {
        deposit_events: event.EventHandle<fungible_asset.DepositEvent>;
        withdraw_events: event.EventHandle<fungible_asset.WithdrawEvent>;
        frozen_events: event.EventHandle<fungible_asset.FrozenEvent>;
    }
    namespace FungibleAssetEvents {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleAssetEvents";
        function type(): TypeDescriptor<FungibleAssetEvents>;
    }
    interface FungibleStore {
        metadata: object_.Object<fungible_asset.Metadata>;
        balance: bigint;
        frozen: Boolean;
    }
    namespace FungibleStore {
        const TYPE_QNAME = "0x1::fungible_asset::FungibleStore";
        function type(): TypeDescriptor<FungibleStore>;
    }
    interface Metadata {
        name: string;
        symbol: string;
        decimals: number;
        icon_uri: string;
        project_uri: string;
    }
    namespace Metadata {
        const TYPE_QNAME = "0x1::fungible_asset::Metadata";
        function type(): TypeDescriptor<Metadata>;
    }
    interface MintRef {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace MintRef {
        const TYPE_QNAME = "0x1::fungible_asset::MintRef";
        function type(): TypeDescriptor<MintRef>;
    }
    interface MintRefInstance extends TypedEventInstance<MintRef> {
        data_decoded: MintRef;
        type_arguments: [];
    }
    interface MutateMetadataRef {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace MutateMetadataRef {
        const TYPE_QNAME = "0x1::fungible_asset::MutateMetadataRef";
        function type(): TypeDescriptor<MutateMetadataRef>;
    }
    interface MutateMetadataRefInstance extends TypedEventInstance<MutateMetadataRef> {
        data_decoded: MutateMetadataRef;
        type_arguments: [];
    }
    interface Supply {
        current: bigint;
        maximum: option.Option<bigint>;
    }
    namespace Supply {
        const TYPE_QNAME = "0x1::fungible_asset::Supply";
        function type(): TypeDescriptor<Supply>;
    }
    interface TransferRef {
        metadata: object_.Object<fungible_asset.Metadata>;
    }
    namespace TransferRef {
        const TYPE_QNAME = "0x1::fungible_asset::TransferRef";
        function type(): TypeDescriptor<TransferRef>;
    }
    interface TransferRefInstance extends TypedEventInstance<TransferRef> {
        data_decoded: TransferRef;
        type_arguments: [];
    }
    interface Untransferable {
        dummy_field: Boolean;
    }
    namespace Untransferable {
        const TYPE_QNAME = "0x1::fungible_asset::Untransferable";
        function type(): TypeDescriptor<Untransferable>;
    }
    interface Withdraw {
        store: MoveAddressType;
        amount: bigint;
    }
    namespace Withdraw {
        const TYPE_QNAME = "0x1::fungible_asset::Withdraw";
        function type(): TypeDescriptor<Withdraw>;
    }
    interface WithdrawInstance extends TypedEventInstance<Withdraw> {
        data_decoded: Withdraw;
        type_arguments: [];
    }
    interface WithdrawEvent {
        amount: bigint;
    }
    namespace WithdrawEvent {
        const TYPE_QNAME = "0x1::fungible_asset::WithdrawEvent";
        function type(): TypeDescriptor<WithdrawEvent>;
    }
    interface WithdrawEventInstance extends TypedEventInstance<WithdrawEvent> {
        data_decoded: WithdrawEvent;
        type_arguments: [];
    }
    interface TransferPayload<T0 = any> extends TypedFunctionPayload<[
        object_.Object<T0>,
        object_.Object<T0>,
        bigint
    ]> {
        arguments_decoded: [object_.Object<T0>, object_.Object<T0>, bigint];
        type_arguments: [string];
    }
    interface UpgradeStoreToConcurrentPayload<T0 = any> extends TypedFunctionPayload<[object_.Object<T0>]> {
        arguments_decoded: [object_.Object<T0>];
        type_arguments: [string];
    }
}
export declare namespace staking_config {
    interface StakingConfig {
        minimum_stake: bigint;
        maximum_stake: bigint;
        recurring_lockup_duration_secs: bigint;
        allow_validator_set_change: Boolean;
        rewards_rate: bigint;
        rewards_rate_denominator: bigint;
        voting_power_increase_limit: bigint;
    }
    namespace StakingConfig {
        const TYPE_QNAME = "0x1::staking_config::StakingConfig";
        function type(): TypeDescriptor<StakingConfig>;
    }
    interface StakingRewardsConfig {
        rewards_rate: fixed_point64.FixedPoint64;
        min_rewards_rate: fixed_point64.FixedPoint64;
        rewards_rate_period_in_secs: bigint;
        last_rewards_rate_period_start_in_secs: bigint;
        rewards_rate_decrease_rate: fixed_point64.FixedPoint64;
    }
    namespace StakingRewardsConfig {
        const TYPE_QNAME = "0x1::staking_config::StakingRewardsConfig";
        function type(): TypeDescriptor<StakingRewardsConfig>;
    }
}
export declare class delegation_pool extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): delegation_pool;
    onEntryAddStake(func: (call: delegation_pool.AddStakePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryAllowlistDelegator(func: (call: delegation_pool.AllowlistDelegatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryCreateProposal(func: (call: delegation_pool.CreateProposalPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryDelegateVotingPower(func: (call: delegation_pool.DelegateVotingPowerPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryDisableDelegatorsAllowlisting(func: (call: delegation_pool.DisableDelegatorsAllowlistingPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryEnableDelegatorsAllowlisting(func: (call: delegation_pool.EnableDelegatorsAllowlistingPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryEnablePartialGovernanceVoting(func: (call: delegation_pool.EnablePartialGovernanceVotingPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryEvictDelegator(func: (call: delegation_pool.EvictDelegatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryInitializeDelegationPool(func: (call: delegation_pool.InitializeDelegationPoolPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryReactivateStake(func: (call: delegation_pool.ReactivateStakePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryRemoveDelegatorFromAllowlist(func: (call: delegation_pool.RemoveDelegatorFromAllowlistPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntrySetBeneficiaryForOperator(func: (call: delegation_pool.SetBeneficiaryForOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntrySetDelegatedVoter(func: (call: delegation_pool.SetDelegatedVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntrySetOperator(func: (call: delegation_pool.SetOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntrySynchronizeDelegationPool(func: (call: delegation_pool.SynchronizeDelegationPoolPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryUnlock(func: (call: delegation_pool.UnlockPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryUpdateCommissionPercentage(func: (call: delegation_pool.UpdateCommissionPercentagePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryVote(func: (call: delegation_pool.VotePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEntryWithdraw(func: (call: delegation_pool.WithdrawPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventAddStake(func: (event: delegation_pool.AddStakeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventAddStakeEvent(func: (event: delegation_pool.AddStakeEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventAllowlistDelegator(func: (event: delegation_pool.AllowlistDelegatorInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventCommissionPercentageChange(func: (event: delegation_pool.CommissionPercentageChangeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventCreateProposal(func: (event: delegation_pool.CreateProposalInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventCreateProposalEvent(func: (event: delegation_pool.CreateProposalEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventDelegateVotingPower(func: (event: delegation_pool.DelegateVotingPowerInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventDelegateVotingPowerEvent(func: (event: delegation_pool.DelegateVotingPowerEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventDelegatedVotes(func: (event: delegation_pool.DelegatedVotesInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventDisableDelegatorsAllowlisting(func: (event: delegation_pool.DisableDelegatorsAllowlistingInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventDistributeCommission(func: (event: delegation_pool.DistributeCommissionInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventDistributeCommissionEvent(func: (event: delegation_pool.DistributeCommissionEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventEnableDelegatorsAllowlisting(func: (event: delegation_pool.EnableDelegatorsAllowlistingInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventEvictDelegator(func: (event: delegation_pool.EvictDelegatorInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventObservedLockupCycle(func: (event: delegation_pool.ObservedLockupCycleInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventReactivateStake(func: (event: delegation_pool.ReactivateStakeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventReactivateStakeEvent(func: (event: delegation_pool.ReactivateStakeEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventRemoveDelegatorFromAllowlist(func: (event: delegation_pool.RemoveDelegatorFromAllowlistInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventSetBeneficiaryForOperator(func: (event: delegation_pool.SetBeneficiaryForOperatorInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventUnlockStake(func: (event: delegation_pool.UnlockStakeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventUnlockStakeEvent(func: (event: delegation_pool.UnlockStakeEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventVote(func: (event: delegation_pool.VoteInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventVoteDelegation(func: (event: delegation_pool.VoteDelegationInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventVoteEvent(func: (event: delegation_pool.VoteEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventVotingRecordKey(func: (event: delegation_pool.VotingRecordKeyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventWithdrawStake(func: (event: delegation_pool.WithdrawStakeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
    onEventWithdrawStakeEvent(func: (event: delegation_pool.WithdrawStakeEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): delegation_pool;
}
export declare namespace delegation_pool {
    interface AddStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_added: bigint;
        add_stake_fee: bigint;
    }
    namespace AddStake {
        const TYPE_QNAME = "0x1::delegation_pool::AddStake";
        function type(): TypeDescriptor<AddStake>;
    }
    interface AddStakeInstance extends TypedEventInstance<AddStake> {
        data_decoded: AddStake;
        type_arguments: [];
    }
    interface AddStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_added: bigint;
        add_stake_fee: bigint;
    }
    namespace AddStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::AddStakeEvent";
        function type(): TypeDescriptor<AddStakeEvent>;
    }
    interface AddStakeEventInstance extends TypedEventInstance<AddStakeEvent> {
        data_decoded: AddStakeEvent;
        type_arguments: [];
    }
    interface AllowlistDelegator {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
    }
    namespace AllowlistDelegator {
        const TYPE_QNAME = "0x1::delegation_pool::AllowlistDelegator";
        function type(): TypeDescriptor<AllowlistDelegator>;
    }
    interface AllowlistDelegatorInstance extends TypedEventInstance<AllowlistDelegator> {
        data_decoded: AllowlistDelegator;
        type_arguments: [];
    }
    interface BeneficiaryForOperator {
        beneficiary_for_operator: MoveAddressType;
    }
    namespace BeneficiaryForOperator {
        const TYPE_QNAME = "0x1::delegation_pool::BeneficiaryForOperator";
        function type(): TypeDescriptor<BeneficiaryForOperator>;
    }
    interface CommissionPercentageChange {
        pool_address: MoveAddressType;
        owner: MoveAddressType;
        commission_percentage_next_lockup_cycle: bigint;
    }
    namespace CommissionPercentageChange {
        const TYPE_QNAME = "0x1::delegation_pool::CommissionPercentageChange";
        function type(): TypeDescriptor<CommissionPercentageChange>;
    }
    interface CommissionPercentageChangeInstance extends TypedEventInstance<CommissionPercentageChange> {
        data_decoded: CommissionPercentageChange;
        type_arguments: [];
    }
    interface CreateProposal {
        proposal_id: bigint;
        voter: MoveAddressType;
        delegation_pool: MoveAddressType;
    }
    namespace CreateProposal {
        const TYPE_QNAME = "0x1::delegation_pool::CreateProposal";
        function type(): TypeDescriptor<CreateProposal>;
    }
    interface CreateProposalInstance extends TypedEventInstance<CreateProposal> {
        data_decoded: CreateProposal;
        type_arguments: [];
    }
    interface CreateProposalEvent {
        proposal_id: bigint;
        voter: MoveAddressType;
        delegation_pool: MoveAddressType;
    }
    namespace CreateProposalEvent {
        const TYPE_QNAME = "0x1::delegation_pool::CreateProposalEvent";
        function type(): TypeDescriptor<CreateProposalEvent>;
    }
    interface CreateProposalEventInstance extends TypedEventInstance<CreateProposalEvent> {
        data_decoded: CreateProposalEvent;
        type_arguments: [];
    }
    interface DelegateVotingPower {
        pool_address: MoveAddressType;
        delegator: MoveAddressType;
        voter: MoveAddressType;
    }
    namespace DelegateVotingPower {
        const TYPE_QNAME = "0x1::delegation_pool::DelegateVotingPower";
        function type(): TypeDescriptor<DelegateVotingPower>;
    }
    interface DelegateVotingPowerInstance extends TypedEventInstance<DelegateVotingPower> {
        data_decoded: DelegateVotingPower;
        type_arguments: [];
    }
    interface DelegateVotingPowerEvent {
        pool_address: MoveAddressType;
        delegator: MoveAddressType;
        voter: MoveAddressType;
    }
    namespace DelegateVotingPowerEvent {
        const TYPE_QNAME = "0x1::delegation_pool::DelegateVotingPowerEvent";
        function type(): TypeDescriptor<DelegateVotingPowerEvent>;
    }
    interface DelegateVotingPowerEventInstance extends TypedEventInstance<DelegateVotingPowerEvent> {
        data_decoded: DelegateVotingPowerEvent;
        type_arguments: [];
    }
    interface DelegatedVotes {
        active_shares: bigint;
        pending_inactive_shares: bigint;
        active_shares_next_lockup: bigint;
        last_locked_until_secs: bigint;
    }
    namespace DelegatedVotes {
        const TYPE_QNAME = "0x1::delegation_pool::DelegatedVotes";
        function type(): TypeDescriptor<DelegatedVotes>;
    }
    interface DelegatedVotesInstance extends TypedEventInstance<DelegatedVotes> {
        data_decoded: DelegatedVotes;
        type_arguments: [];
    }
    interface DelegationPool {
        active_shares: pool_u64_unbound.Pool;
        observed_lockup_cycle: delegation_pool.ObservedLockupCycle;
        inactive_shares: table.Table<delegation_pool.ObservedLockupCycle, pool_u64_unbound.Pool>;
        pending_withdrawals: table.Table<MoveAddressType, delegation_pool.ObservedLockupCycle>;
        stake_pool_signer_cap: account.SignerCapability;
        total_coins_inactive: bigint;
        operator_commission_percentage: bigint;
        add_stake_events: event.EventHandle<delegation_pool.AddStakeEvent>;
        reactivate_stake_events: event.EventHandle<delegation_pool.ReactivateStakeEvent>;
        unlock_stake_events: event.EventHandle<delegation_pool.UnlockStakeEvent>;
        withdraw_stake_events: event.EventHandle<delegation_pool.WithdrawStakeEvent>;
        distribute_commission_events: event.EventHandle<delegation_pool.DistributeCommissionEvent>;
    }
    namespace DelegationPool {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPool";
        function type(): TypeDescriptor<DelegationPool>;
    }
    interface DelegationPoolAllowlisting {
        allowlist: smart_table.SmartTable<MoveAddressType, Boolean>;
    }
    namespace DelegationPoolAllowlisting {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPoolAllowlisting";
        function type(): TypeDescriptor<DelegationPoolAllowlisting>;
    }
    interface DelegationPoolOwnership {
        pool_address: MoveAddressType;
    }
    namespace DelegationPoolOwnership {
        const TYPE_QNAME = "0x1::delegation_pool::DelegationPoolOwnership";
        function type(): TypeDescriptor<DelegationPoolOwnership>;
    }
    interface DisableDelegatorsAllowlisting {
        pool_address: MoveAddressType;
    }
    namespace DisableDelegatorsAllowlisting {
        const TYPE_QNAME = "0x1::delegation_pool::DisableDelegatorsAllowlisting";
        function type(): TypeDescriptor<DisableDelegatorsAllowlisting>;
    }
    interface DisableDelegatorsAllowlistingInstance extends TypedEventInstance<DisableDelegatorsAllowlisting> {
        data_decoded: DisableDelegatorsAllowlisting;
        type_arguments: [];
    }
    interface DistributeCommission {
        pool_address: MoveAddressType;
        operator: MoveAddressType;
        beneficiary: MoveAddressType;
        commission_active: bigint;
        commission_pending_inactive: bigint;
    }
    namespace DistributeCommission {
        const TYPE_QNAME = "0x1::delegation_pool::DistributeCommission";
        function type(): TypeDescriptor<DistributeCommission>;
    }
    interface DistributeCommissionInstance extends TypedEventInstance<DistributeCommission> {
        data_decoded: DistributeCommission;
        type_arguments: [];
    }
    interface DistributeCommissionEvent {
        pool_address: MoveAddressType;
        operator: MoveAddressType;
        commission_active: bigint;
        commission_pending_inactive: bigint;
    }
    namespace DistributeCommissionEvent {
        const TYPE_QNAME = "0x1::delegation_pool::DistributeCommissionEvent";
        function type(): TypeDescriptor<DistributeCommissionEvent>;
    }
    interface DistributeCommissionEventInstance extends TypedEventInstance<DistributeCommissionEvent> {
        data_decoded: DistributeCommissionEvent;
        type_arguments: [];
    }
    interface EnableDelegatorsAllowlisting {
        pool_address: MoveAddressType;
    }
    namespace EnableDelegatorsAllowlisting {
        const TYPE_QNAME = "0x1::delegation_pool::EnableDelegatorsAllowlisting";
        function type(): TypeDescriptor<EnableDelegatorsAllowlisting>;
    }
    interface EnableDelegatorsAllowlistingInstance extends TypedEventInstance<EnableDelegatorsAllowlisting> {
        data_decoded: EnableDelegatorsAllowlisting;
        type_arguments: [];
    }
    interface EvictDelegator {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
    }
    namespace EvictDelegator {
        const TYPE_QNAME = "0x1::delegation_pool::EvictDelegator";
        function type(): TypeDescriptor<EvictDelegator>;
    }
    interface EvictDelegatorInstance extends TypedEventInstance<EvictDelegator> {
        data_decoded: EvictDelegator;
        type_arguments: [];
    }
    interface GovernanceRecords {
        votes: smart_table.SmartTable<delegation_pool.VotingRecordKey, bigint>;
        votes_per_proposal: smart_table.SmartTable<bigint, bigint>;
        vote_delegation: smart_table.SmartTable<MoveAddressType, delegation_pool.VoteDelegation>;
        delegated_votes: smart_table.SmartTable<MoveAddressType, delegation_pool.DelegatedVotes>;
        vote_events: event.EventHandle<delegation_pool.VoteEvent>;
        create_proposal_events: event.EventHandle<delegation_pool.CreateProposalEvent>;
        delegate_voting_power_events: event.EventHandle<delegation_pool.DelegateVotingPowerEvent>;
    }
    namespace GovernanceRecords {
        const TYPE_QNAME = "0x1::delegation_pool::GovernanceRecords";
        function type(): TypeDescriptor<GovernanceRecords>;
    }
    interface NextCommissionPercentage {
        commission_percentage_next_lockup_cycle: bigint;
        effective_after_secs: bigint;
    }
    namespace NextCommissionPercentage {
        const TYPE_QNAME = "0x1::delegation_pool::NextCommissionPercentage";
        function type(): TypeDescriptor<NextCommissionPercentage>;
    }
    interface ObservedLockupCycle {
        index: bigint;
    }
    namespace ObservedLockupCycle {
        const TYPE_QNAME = "0x1::delegation_pool::ObservedLockupCycle";
        function type(): TypeDescriptor<ObservedLockupCycle>;
    }
    interface ObservedLockupCycleInstance extends TypedEventInstance<ObservedLockupCycle> {
        data_decoded: ObservedLockupCycle;
        type_arguments: [];
    }
    interface ReactivateStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_reactivated: bigint;
    }
    namespace ReactivateStake {
        const TYPE_QNAME = "0x1::delegation_pool::ReactivateStake";
        function type(): TypeDescriptor<ReactivateStake>;
    }
    interface ReactivateStakeInstance extends TypedEventInstance<ReactivateStake> {
        data_decoded: ReactivateStake;
        type_arguments: [];
    }
    interface ReactivateStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_reactivated: bigint;
    }
    namespace ReactivateStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::ReactivateStakeEvent";
        function type(): TypeDescriptor<ReactivateStakeEvent>;
    }
    interface ReactivateStakeEventInstance extends TypedEventInstance<ReactivateStakeEvent> {
        data_decoded: ReactivateStakeEvent;
        type_arguments: [];
    }
    interface RemoveDelegatorFromAllowlist {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
    }
    namespace RemoveDelegatorFromAllowlist {
        const TYPE_QNAME = "0x1::delegation_pool::RemoveDelegatorFromAllowlist";
        function type(): TypeDescriptor<RemoveDelegatorFromAllowlist>;
    }
    interface RemoveDelegatorFromAllowlistInstance extends TypedEventInstance<RemoveDelegatorFromAllowlist> {
        data_decoded: RemoveDelegatorFromAllowlist;
        type_arguments: [];
    }
    interface SetBeneficiaryForOperator {
        operator: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiaryForOperator {
        const TYPE_QNAME = "0x1::delegation_pool::SetBeneficiaryForOperator";
        function type(): TypeDescriptor<SetBeneficiaryForOperator>;
    }
    interface SetBeneficiaryForOperatorInstance extends TypedEventInstance<SetBeneficiaryForOperator> {
        data_decoded: SetBeneficiaryForOperator;
        type_arguments: [];
    }
    interface UnlockStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStake {
        const TYPE_QNAME = "0x1::delegation_pool::UnlockStake";
        function type(): TypeDescriptor<UnlockStake>;
    }
    interface UnlockStakeInstance extends TypedEventInstance<UnlockStake> {
        data_decoded: UnlockStake;
        type_arguments: [];
    }
    interface UnlockStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_unlocked: bigint;
    }
    namespace UnlockStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::UnlockStakeEvent";
        function type(): TypeDescriptor<UnlockStakeEvent>;
    }
    interface UnlockStakeEventInstance extends TypedEventInstance<UnlockStakeEvent> {
        data_decoded: UnlockStakeEvent;
        type_arguments: [];
    }
    interface Vote {
        voter: MoveAddressType;
        proposal_id: bigint;
        delegation_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: Boolean;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::delegation_pool::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    interface VoteInstance extends TypedEventInstance<Vote> {
        data_decoded: Vote;
        type_arguments: [];
    }
    interface VoteDelegation {
        voter: MoveAddressType;
        pending_voter: MoveAddressType;
        last_locked_until_secs: bigint;
    }
    namespace VoteDelegation {
        const TYPE_QNAME = "0x1::delegation_pool::VoteDelegation";
        function type(): TypeDescriptor<VoteDelegation>;
    }
    interface VoteDelegationInstance extends TypedEventInstance<VoteDelegation> {
        data_decoded: VoteDelegation;
        type_arguments: [];
    }
    interface VoteEvent {
        voter: MoveAddressType;
        proposal_id: bigint;
        delegation_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: Boolean;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::delegation_pool::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    interface VoteEventInstance extends TypedEventInstance<VoteEvent> {
        data_decoded: VoteEvent;
        type_arguments: [];
    }
    interface VotingRecordKey {
        voter: MoveAddressType;
        proposal_id: bigint;
    }
    namespace VotingRecordKey {
        const TYPE_QNAME = "0x1::delegation_pool::VotingRecordKey";
        function type(): TypeDescriptor<VotingRecordKey>;
    }
    interface VotingRecordKeyInstance extends TypedEventInstance<VotingRecordKey> {
        data_decoded: VotingRecordKey;
        type_arguments: [];
    }
    interface WithdrawStake {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStake {
        const TYPE_QNAME = "0x1::delegation_pool::WithdrawStake";
        function type(): TypeDescriptor<WithdrawStake>;
    }
    interface WithdrawStakeInstance extends TypedEventInstance<WithdrawStake> {
        data_decoded: WithdrawStake;
        type_arguments: [];
    }
    interface WithdrawStakeEvent {
        pool_address: MoveAddressType;
        delegator_address: MoveAddressType;
        amount_withdrawn: bigint;
    }
    namespace WithdrawStakeEvent {
        const TYPE_QNAME = "0x1::delegation_pool::WithdrawStakeEvent";
        function type(): TypeDescriptor<WithdrawStakeEvent>;
    }
    interface WithdrawStakeEventInstance extends TypedEventInstance<WithdrawStakeEvent> {
        data_decoded: WithdrawStakeEvent;
        type_arguments: [];
    }
    interface AddStakePayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface AllowlistDelegatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface CreateProposalPayload extends TypedFunctionPayload<[
        MoveAddressType,
        string,
        string,
        string,
        Boolean
    ]> {
        arguments_decoded: [MoveAddressType, string, string, string, Boolean];
        type_arguments: [];
    }
    interface DelegateVotingPowerPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface DisableDelegatorsAllowlistingPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface EnableDelegatorsAllowlistingPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface EnablePartialGovernanceVotingPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface EvictDelegatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface InitializeDelegationPoolPayload extends TypedFunctionPayload<[bigint, string]> {
        arguments_decoded: [bigint, string];
        type_arguments: [];
    }
    interface ReactivateStakePayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface RemoveDelegatorFromAllowlistPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetBeneficiaryForOperatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetDelegatedVoterPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetOperatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SynchronizeDelegationPoolPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UnlockPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface UpdateCommissionPercentagePayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface VotePayload extends TypedFunctionPayload<[MoveAddressType, bigint, bigint, Boolean]> {
        arguments_decoded: [MoveAddressType, bigint, bigint, Boolean];
        type_arguments: [];
    }
    interface WithdrawPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
}
export declare class keyless_account extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): keyless_account;
    onEventConfiguration(func: (event: keyless_account.ConfigurationInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): keyless_account;
    onEventGroth16VerificationKey(func: (event: keyless_account.Groth16VerificationKeyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): keyless_account;
}
export declare namespace keyless_account {
    interface Configuration {
        override_aud_vals: string[];
        max_signatures_per_txn: number;
        max_exp_horizon_secs: bigint;
        training_wheels_pubkey: option.Option<string>;
        max_commited_epk_bytes: number;
        max_iss_val_bytes: number;
        max_extra_field_bytes: number;
        max_jwt_header_b64_bytes: number;
    }
    namespace Configuration {
        const TYPE_QNAME = "0x1::keyless_account::Configuration";
        function type(): TypeDescriptor<Configuration>;
    }
    interface ConfigurationInstance extends TypedEventInstance<Configuration> {
        data_decoded: Configuration;
        type_arguments: [];
    }
    interface Groth16VerificationKey {
        alpha_g1: string;
        beta_g2: string;
        gamma_g2: string;
        delta_g2: string;
        gamma_abc_g1: string[];
    }
    namespace Groth16VerificationKey {
        const TYPE_QNAME = "0x1::keyless_account::Groth16VerificationKey";
        function type(): TypeDescriptor<Groth16VerificationKey>;
    }
    interface Groth16VerificationKeyInstance extends TypedEventInstance<Groth16VerificationKey> {
        data_decoded: Groth16VerificationKey;
        type_arguments: [];
    }
    interface Group {
        dummy_field: Boolean;
    }
    namespace Group {
        const TYPE_QNAME = "0x1::keyless_account::Group";
        function type(): TypeDescriptor<Group>;
    }
}
export declare class reconfiguration extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): reconfiguration;
    onEventNewEpoch(func: (event: reconfiguration.NewEpochInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): reconfiguration;
    onEventNewEpochEvent(func: (event: reconfiguration.NewEpochEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): reconfiguration;
}
export declare namespace reconfiguration {
    interface Configuration {
        epoch: bigint;
        last_reconfiguration_time: bigint;
        events: event.EventHandle<reconfiguration.NewEpochEvent>;
    }
    namespace Configuration {
        const TYPE_QNAME = "0x1::reconfiguration::Configuration";
        function type(): TypeDescriptor<Configuration>;
    }
    interface DisableReconfiguration {
        dummy_field: Boolean;
    }
    namespace DisableReconfiguration {
        const TYPE_QNAME = "0x1::reconfiguration::DisableReconfiguration";
        function type(): TypeDescriptor<DisableReconfiguration>;
    }
    interface NewEpoch {
        epoch: bigint;
    }
    namespace NewEpoch {
        const TYPE_QNAME = "0x1::reconfiguration::NewEpoch";
        function type(): TypeDescriptor<NewEpoch>;
    }
    interface NewEpochInstance extends TypedEventInstance<NewEpoch> {
        data_decoded: NewEpoch;
        type_arguments: [];
    }
    interface NewEpochEvent {
        epoch: bigint;
    }
    namespace NewEpochEvent {
        const TYPE_QNAME = "0x1::reconfiguration::NewEpochEvent";
        function type(): TypeDescriptor<NewEpochEvent>;
    }
    interface NewEpochEventInstance extends TypedEventInstance<NewEpochEvent> {
        data_decoded: NewEpochEvent;
        type_arguments: [];
    }
}
export declare class transaction_fee extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): transaction_fee;
    onEntryConvertToAptosFaBurnRef(func: (call: transaction_fee.ConvertToAptosFaBurnRefPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): transaction_fee;
    onEventFeeStatement(func: (event: transaction_fee.FeeStatementInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): transaction_fee;
}
export declare namespace transaction_fee {
    interface AptosCoinCapabilities {
        burn_cap: coin.BurnCapability<aptos_coin.AptosCoin>;
    }
    namespace AptosCoinCapabilities {
        const TYPE_QNAME = "0x1::transaction_fee::AptosCoinCapabilities";
        function type(): TypeDescriptor<AptosCoinCapabilities>;
    }
    interface AptosCoinMintCapability {
        mint_cap: coin.MintCapability<aptos_coin.AptosCoin>;
    }
    namespace AptosCoinMintCapability {
        const TYPE_QNAME = "0x1::transaction_fee::AptosCoinMintCapability";
        function type(): TypeDescriptor<AptosCoinMintCapability>;
    }
    interface AptosFABurnCapabilities {
        burn_ref: fungible_asset.BurnRef;
    }
    namespace AptosFABurnCapabilities {
        const TYPE_QNAME = "0x1::transaction_fee::AptosFABurnCapabilities";
        function type(): TypeDescriptor<AptosFABurnCapabilities>;
    }
    interface CollectedFeesPerBlock {
        amount: coin.AggregatableCoin<aptos_coin.AptosCoin>;
        proposer: option.Option<MoveAddressType>;
        burn_percentage: number;
    }
    namespace CollectedFeesPerBlock {
        const TYPE_QNAME = "0x1::transaction_fee::CollectedFeesPerBlock";
        function type(): TypeDescriptor<CollectedFeesPerBlock>;
    }
    interface FeeStatement {
        total_charge_gas_units: bigint;
        execution_gas_units: bigint;
        io_gas_units: bigint;
        storage_fee_octas: bigint;
        storage_fee_refund_octas: bigint;
    }
    namespace FeeStatement {
        const TYPE_QNAME = "0x1::transaction_fee::FeeStatement";
        function type(): TypeDescriptor<FeeStatement>;
    }
    interface FeeStatementInstance extends TypedEventInstance<FeeStatement> {
        data_decoded: FeeStatement;
        type_arguments: [];
    }
    interface ConvertToAptosFaBurnRefPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
}
export declare class aptos_governance extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): aptos_governance;
    onEntryAddApprovedScriptHashScript(func: (call: aptos_governance.AddApprovedScriptHashScriptPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEntryBatchPartialVote(func: (call: aptos_governance.BatchPartialVotePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEntryBatchVote(func: (call: aptos_governance.BatchVotePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEntryCreateProposal(func: (call: aptos_governance.CreateProposalPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEntryCreateProposalV2(func: (call: aptos_governance.CreateProposalV2Payload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEntryForceEndEpoch(func: (call: aptos_governance.ForceEndEpochPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEntryForceEndEpochTestOnly(func: (call: aptos_governance.ForceEndEpochTestOnlyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEntryPartialVote(func: (call: aptos_governance.PartialVotePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEntryReconfigure(func: (call: aptos_governance.ReconfigurePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEntryVote(func: (call: aptos_governance.VotePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEventCreateProposal(func: (event: aptos_governance.CreateProposalInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEventCreateProposalEvent(func: (event: aptos_governance.CreateProposalEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEventRecordKey(func: (event: aptos_governance.RecordKeyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEventUpdateConfig(func: (event: aptos_governance.UpdateConfigInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEventUpdateConfigEvent(func: (event: aptos_governance.UpdateConfigEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEventVote(func: (event: aptos_governance.VoteInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
    onEventVoteEvent(func: (event: aptos_governance.VoteEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): aptos_governance;
}
export declare namespace aptos_governance {
    interface ApprovedExecutionHashes {
        hashes: simple_map.SimpleMap<bigint, string>;
    }
    namespace ApprovedExecutionHashes {
        const TYPE_QNAME = "0x1::aptos_governance::ApprovedExecutionHashes";
        function type(): TypeDescriptor<ApprovedExecutionHashes>;
    }
    interface CreateProposal {
        proposer: MoveAddressType;
        stake_pool: MoveAddressType;
        proposal_id: bigint;
        execution_hash: string;
        proposal_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace CreateProposal {
        const TYPE_QNAME = "0x1::aptos_governance::CreateProposal";
        function type(): TypeDescriptor<CreateProposal>;
    }
    interface CreateProposalInstance extends TypedEventInstance<CreateProposal> {
        data_decoded: CreateProposal;
        type_arguments: [];
    }
    interface CreateProposalEvent {
        proposer: MoveAddressType;
        stake_pool: MoveAddressType;
        proposal_id: bigint;
        execution_hash: string;
        proposal_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace CreateProposalEvent {
        const TYPE_QNAME = "0x1::aptos_governance::CreateProposalEvent";
        function type(): TypeDescriptor<CreateProposalEvent>;
    }
    interface CreateProposalEventInstance extends TypedEventInstance<CreateProposalEvent> {
        data_decoded: CreateProposalEvent;
        type_arguments: [];
    }
    interface GovernanceConfig {
        min_voting_threshold: bigint;
        required_proposer_stake: bigint;
        voting_duration_secs: bigint;
    }
    namespace GovernanceConfig {
        const TYPE_QNAME = "0x1::aptos_governance::GovernanceConfig";
        function type(): TypeDescriptor<GovernanceConfig>;
    }
    interface GovernanceEvents {
        create_proposal_events: event.EventHandle<aptos_governance.CreateProposalEvent>;
        update_config_events: event.EventHandle<aptos_governance.UpdateConfigEvent>;
        vote_events: event.EventHandle<aptos_governance.VoteEvent>;
    }
    namespace GovernanceEvents {
        const TYPE_QNAME = "0x1::aptos_governance::GovernanceEvents";
        function type(): TypeDescriptor<GovernanceEvents>;
    }
    interface GovernanceResponsbility {
        signer_caps: simple_map.SimpleMap<MoveAddressType, account.SignerCapability>;
    }
    namespace GovernanceResponsbility {
        const TYPE_QNAME = "0x1::aptos_governance::GovernanceResponsbility";
        function type(): TypeDescriptor<GovernanceResponsbility>;
    }
    interface RecordKey {
        stake_pool: MoveAddressType;
        proposal_id: bigint;
    }
    namespace RecordKey {
        const TYPE_QNAME = "0x1::aptos_governance::RecordKey";
        function type(): TypeDescriptor<RecordKey>;
    }
    interface RecordKeyInstance extends TypedEventInstance<RecordKey> {
        data_decoded: RecordKey;
        type_arguments: [];
    }
    interface UpdateConfig {
        min_voting_threshold: bigint;
        required_proposer_stake: bigint;
        voting_duration_secs: bigint;
    }
    namespace UpdateConfig {
        const TYPE_QNAME = "0x1::aptos_governance::UpdateConfig";
        function type(): TypeDescriptor<UpdateConfig>;
    }
    interface UpdateConfigInstance extends TypedEventInstance<UpdateConfig> {
        data_decoded: UpdateConfig;
        type_arguments: [];
    }
    interface UpdateConfigEvent {
        min_voting_threshold: bigint;
        required_proposer_stake: bigint;
        voting_duration_secs: bigint;
    }
    namespace UpdateConfigEvent {
        const TYPE_QNAME = "0x1::aptos_governance::UpdateConfigEvent";
        function type(): TypeDescriptor<UpdateConfigEvent>;
    }
    interface UpdateConfigEventInstance extends TypedEventInstance<UpdateConfigEvent> {
        data_decoded: UpdateConfigEvent;
        type_arguments: [];
    }
    interface Vote {
        proposal_id: bigint;
        voter: MoveAddressType;
        stake_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: Boolean;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::aptos_governance::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    interface VoteInstance extends TypedEventInstance<Vote> {
        data_decoded: Vote;
        type_arguments: [];
    }
    interface VoteEvent {
        proposal_id: bigint;
        voter: MoveAddressType;
        stake_pool: MoveAddressType;
        num_votes: bigint;
        should_pass: Boolean;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::aptos_governance::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    interface VoteEventInstance extends TypedEventInstance<VoteEvent> {
        data_decoded: VoteEvent;
        type_arguments: [];
    }
    interface VotingRecords {
        votes: table.Table<aptos_governance.RecordKey, Boolean>;
    }
    namespace VotingRecords {
        const TYPE_QNAME = "0x1::aptos_governance::VotingRecords";
        function type(): TypeDescriptor<VotingRecords>;
    }
    interface VotingRecordsV2 {
        votes: smart_table.SmartTable<aptos_governance.RecordKey, bigint>;
    }
    namespace VotingRecordsV2 {
        const TYPE_QNAME = "0x1::aptos_governance::VotingRecordsV2";
        function type(): TypeDescriptor<VotingRecordsV2>;
    }
    interface AddApprovedScriptHashScriptPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface BatchPartialVotePayload extends TypedFunctionPayload<[MoveAddressType[], bigint, bigint, Boolean]> {
        arguments_decoded: [MoveAddressType[], bigint, bigint, Boolean];
        type_arguments: [];
    }
    interface BatchVotePayload extends TypedFunctionPayload<[MoveAddressType[], bigint, Boolean]> {
        arguments_decoded: [MoveAddressType[], bigint, Boolean];
        type_arguments: [];
    }
    interface CreateProposalPayload extends TypedFunctionPayload<[MoveAddressType, string, string, string]> {
        arguments_decoded: [MoveAddressType, string, string, string];
        type_arguments: [];
    }
    interface CreateProposalV2Payload extends TypedFunctionPayload<[
        MoveAddressType,
        string,
        string,
        string,
        Boolean
    ]> {
        arguments_decoded: [MoveAddressType, string, string, string, Boolean];
        type_arguments: [];
    }
    interface ForceEndEpochPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface ForceEndEpochTestOnlyPayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface PartialVotePayload extends TypedFunctionPayload<[MoveAddressType, bigint, bigint, Boolean]> {
        arguments_decoded: [MoveAddressType, bigint, bigint, Boolean];
        type_arguments: [];
    }
    interface ReconfigurePayload extends TypedFunctionPayload<[]> {
        arguments_decoded: [];
        type_arguments: [];
    }
    interface VotePayload extends TypedFunctionPayload<[MoveAddressType, bigint, Boolean]> {
        arguments_decoded: [MoveAddressType, bigint, Boolean];
        type_arguments: [];
    }
}
export declare namespace bls12381_algebra {
    interface FormatFq12LscLsb {
        dummy_field: Boolean;
    }
    namespace FormatFq12LscLsb {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatFq12LscLsb";
        function type(): TypeDescriptor<FormatFq12LscLsb>;
    }
    interface FormatFrLsb {
        dummy_field: Boolean;
    }
    namespace FormatFrLsb {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatFrLsb";
        function type(): TypeDescriptor<FormatFrLsb>;
    }
    interface FormatFrMsb {
        dummy_field: Boolean;
    }
    namespace FormatFrMsb {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatFrMsb";
        function type(): TypeDescriptor<FormatFrMsb>;
    }
    interface FormatG1Compr {
        dummy_field: Boolean;
    }
    namespace FormatG1Compr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG1Compr";
        function type(): TypeDescriptor<FormatG1Compr>;
    }
    interface FormatG1Uncompr {
        dummy_field: Boolean;
    }
    namespace FormatG1Uncompr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG1Uncompr";
        function type(): TypeDescriptor<FormatG1Uncompr>;
    }
    interface FormatG2Compr {
        dummy_field: Boolean;
    }
    namespace FormatG2Compr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG2Compr";
        function type(): TypeDescriptor<FormatG2Compr>;
    }
    interface FormatG2Uncompr {
        dummy_field: Boolean;
    }
    namespace FormatG2Uncompr {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatG2Uncompr";
        function type(): TypeDescriptor<FormatG2Uncompr>;
    }
    interface FormatGt {
        dummy_field: Boolean;
    }
    namespace FormatGt {
        const TYPE_QNAME = "0x1::bls12381_algebra::FormatGt";
        function type(): TypeDescriptor<FormatGt>;
    }
    interface Fq12 {
        dummy_field: Boolean;
    }
    namespace Fq12 {
        const TYPE_QNAME = "0x1::bls12381_algebra::Fq12";
        function type(): TypeDescriptor<Fq12>;
    }
    interface Fr {
        dummy_field: Boolean;
    }
    namespace Fr {
        const TYPE_QNAME = "0x1::bls12381_algebra::Fr";
        function type(): TypeDescriptor<Fr>;
    }
    interface G1 {
        dummy_field: Boolean;
    }
    namespace G1 {
        const TYPE_QNAME = "0x1::bls12381_algebra::G1";
        function type(): TypeDescriptor<G1>;
    }
    interface G2 {
        dummy_field: Boolean;
    }
    namespace G2 {
        const TYPE_QNAME = "0x1::bls12381_algebra::G2";
        function type(): TypeDescriptor<G2>;
    }
    interface Gt {
        dummy_field: Boolean;
    }
    namespace Gt {
        const TYPE_QNAME = "0x1::bls12381_algebra::Gt";
        function type(): TypeDescriptor<Gt>;
    }
    interface HashG1XmdSha256SswuRo {
        dummy_field: Boolean;
    }
    namespace HashG1XmdSha256SswuRo {
        const TYPE_QNAME = "0x1::bls12381_algebra::HashG1XmdSha256SswuRo";
        function type(): TypeDescriptor<HashG1XmdSha256SswuRo>;
    }
    interface HashG2XmdSha256SswuRo {
        dummy_field: Boolean;
    }
    namespace HashG2XmdSha256SswuRo {
        const TYPE_QNAME = "0x1::bls12381_algebra::HashG2XmdSha256SswuRo";
        function type(): TypeDescriptor<HashG2XmdSha256SswuRo>;
    }
}
export declare class consensus_config extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): consensus_config;
    onEventConsensusConfig(func: (event: consensus_config.ConsensusConfigInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): consensus_config;
}
export declare namespace consensus_config {
    interface ConsensusConfig {
        config: string;
    }
    namespace ConsensusConfig {
        const TYPE_QNAME = "0x1::consensus_config::ConsensusConfig";
        function type(): TypeDescriptor<ConsensusConfig>;
    }
    interface ConsensusConfigInstance extends TypedEventInstance<ConsensusConfig> {
        data_decoded: ConsensusConfig;
        type_arguments: [];
    }
}
export declare class execution_config extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): execution_config;
    onEventExecutionConfig(func: (event: execution_config.ExecutionConfigInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): execution_config;
}
export declare namespace execution_config {
    interface ExecutionConfig {
        config: string;
    }
    namespace ExecutionConfig {
        const TYPE_QNAME = "0x1::execution_config::ExecutionConfig";
        function type(): TypeDescriptor<ExecutionConfig>;
    }
    interface ExecutionConfigInstance extends TypedEventInstance<ExecutionConfig> {
        data_decoded: ExecutionConfig;
        type_arguments: [];
    }
}
export declare class multisig_account extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): multisig_account;
    onEntryAddOwner(func: (call: multisig_account.AddOwnerPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryAddOwners(func: (call: multisig_account.AddOwnersPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryAddOwnersAndUpdateSignaturesRequired(func: (call: multisig_account.AddOwnersAndUpdateSignaturesRequiredPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryApproveTransaction(func: (call: multisig_account.ApproveTransactionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryCreate(func: (call: multisig_account.CreatePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryCreateTransaction(func: (call: multisig_account.CreateTransactionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryCreateTransactionWithHash(func: (call: multisig_account.CreateTransactionWithHashPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryCreateWithExistingAccount(func: (call: multisig_account.CreateWithExistingAccountPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryCreateWithExistingAccountAndRevokeAuthKey(func: (call: multisig_account.CreateWithExistingAccountAndRevokeAuthKeyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryCreateWithOwners(func: (call: multisig_account.CreateWithOwnersPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryCreateWithOwnersThenRemoveBootstrapper(func: (call: multisig_account.CreateWithOwnersThenRemoveBootstrapperPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryExecuteRejectedTransaction(func: (call: multisig_account.ExecuteRejectedTransactionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryExecuteRejectedTransactions(func: (call: multisig_account.ExecuteRejectedTransactionsPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryRejectTransaction(func: (call: multisig_account.RejectTransactionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryRemoveOwner(func: (call: multisig_account.RemoveOwnerPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryRemoveOwners(func: (call: multisig_account.RemoveOwnersPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntrySwapOwner(func: (call: multisig_account.SwapOwnerPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntrySwapOwners(func: (call: multisig_account.SwapOwnersPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntrySwapOwnersAndUpdateSignaturesRequired(func: (call: multisig_account.SwapOwnersAndUpdateSignaturesRequiredPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryUpdateMetadata(func: (call: multisig_account.UpdateMetadataPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryUpdateSignaturesRequired(func: (call: multisig_account.UpdateSignaturesRequiredPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryVoteTransaction(func: (call: multisig_account.VoteTransactionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryVoteTransactions(func: (call: multisig_account.VoteTransactionsPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEntryVoteTransanction(func: (call: multisig_account.VoteTransanctionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventAddOwners(func: (event: multisig_account.AddOwnersInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventAddOwnersEvent(func: (event: multisig_account.AddOwnersEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventCreateTransaction(func: (event: multisig_account.CreateTransactionInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventCreateTransactionEvent(func: (event: multisig_account.CreateTransactionEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventExecuteRejectedTransaction(func: (event: multisig_account.ExecuteRejectedTransactionInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventExecuteRejectedTransactionEvent(func: (event: multisig_account.ExecuteRejectedTransactionEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventExecutionError(func: (event: multisig_account.ExecutionErrorInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventMetadataUpdated(func: (event: multisig_account.MetadataUpdatedInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventMetadataUpdatedEvent(func: (event: multisig_account.MetadataUpdatedEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventMultisigTransaction(func: (event: multisig_account.MultisigTransactionInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventRemoveOwners(func: (event: multisig_account.RemoveOwnersInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventRemoveOwnersEvent(func: (event: multisig_account.RemoveOwnersEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventTransactionExecutionFailed(func: (event: multisig_account.TransactionExecutionFailedInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventTransactionExecutionFailedEvent(func: (event: multisig_account.TransactionExecutionFailedEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventTransactionExecutionSucceeded(func: (event: multisig_account.TransactionExecutionSucceededInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventTransactionExecutionSucceededEvent(func: (event: multisig_account.TransactionExecutionSucceededEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventUpdateSignaturesRequired(func: (event: multisig_account.UpdateSignaturesRequiredInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventUpdateSignaturesRequiredEvent(func: (event: multisig_account.UpdateSignaturesRequiredEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventVote(func: (event: multisig_account.VoteInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
    onEventVoteEvent(func: (event: multisig_account.VoteEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): multisig_account;
}
export declare namespace multisig_account {
    interface AddOwners {
        multisig_account: MoveAddressType;
        owners_added: MoveAddressType[];
    }
    namespace AddOwners {
        const TYPE_QNAME = "0x1::multisig_account::AddOwners";
        function type(): TypeDescriptor<AddOwners>;
    }
    interface AddOwnersInstance extends TypedEventInstance<AddOwners> {
        data_decoded: AddOwners;
        type_arguments: [];
    }
    interface AddOwnersEvent {
        owners_added: MoveAddressType[];
    }
    namespace AddOwnersEvent {
        const TYPE_QNAME = "0x1::multisig_account::AddOwnersEvent";
        function type(): TypeDescriptor<AddOwnersEvent>;
    }
    interface AddOwnersEventInstance extends TypedEventInstance<AddOwnersEvent> {
        data_decoded: AddOwnersEvent;
        type_arguments: [];
    }
    interface CreateTransaction {
        multisig_account: MoveAddressType;
        creator: MoveAddressType;
        sequence_number: bigint;
        transaction: multisig_account.MultisigTransaction;
    }
    namespace CreateTransaction {
        const TYPE_QNAME = "0x1::multisig_account::CreateTransaction";
        function type(): TypeDescriptor<CreateTransaction>;
    }
    interface CreateTransactionInstance extends TypedEventInstance<CreateTransaction> {
        data_decoded: CreateTransaction;
        type_arguments: [];
    }
    interface CreateTransactionEvent {
        creator: MoveAddressType;
        sequence_number: bigint;
        transaction: multisig_account.MultisigTransaction;
    }
    namespace CreateTransactionEvent {
        const TYPE_QNAME = "0x1::multisig_account::CreateTransactionEvent";
        function type(): TypeDescriptor<CreateTransactionEvent>;
    }
    interface CreateTransactionEventInstance extends TypedEventInstance<CreateTransactionEvent> {
        data_decoded: CreateTransactionEvent;
        type_arguments: [];
    }
    interface ExecuteRejectedTransaction {
        multisig_account: MoveAddressType;
        sequence_number: bigint;
        num_rejections: bigint;
        executor: MoveAddressType;
    }
    namespace ExecuteRejectedTransaction {
        const TYPE_QNAME = "0x1::multisig_account::ExecuteRejectedTransaction";
        function type(): TypeDescriptor<ExecuteRejectedTransaction>;
    }
    interface ExecuteRejectedTransactionInstance extends TypedEventInstance<ExecuteRejectedTransaction> {
        data_decoded: ExecuteRejectedTransaction;
        type_arguments: [];
    }
    interface ExecuteRejectedTransactionEvent {
        sequence_number: bigint;
        num_rejections: bigint;
        executor: MoveAddressType;
    }
    namespace ExecuteRejectedTransactionEvent {
        const TYPE_QNAME = "0x1::multisig_account::ExecuteRejectedTransactionEvent";
        function type(): TypeDescriptor<ExecuteRejectedTransactionEvent>;
    }
    interface ExecuteRejectedTransactionEventInstance extends TypedEventInstance<ExecuteRejectedTransactionEvent> {
        data_decoded: ExecuteRejectedTransactionEvent;
        type_arguments: [];
    }
    interface ExecutionError {
        abort_location: string;
        error_type: string;
        error_code: bigint;
    }
    namespace ExecutionError {
        const TYPE_QNAME = "0x1::multisig_account::ExecutionError";
        function type(): TypeDescriptor<ExecutionError>;
    }
    interface ExecutionErrorInstance extends TypedEventInstance<ExecutionError> {
        data_decoded: ExecutionError;
        type_arguments: [];
    }
    interface MetadataUpdated {
        multisig_account: MoveAddressType;
        old_metadata: simple_map.SimpleMap<string, string>;
        new_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace MetadataUpdated {
        const TYPE_QNAME = "0x1::multisig_account::MetadataUpdated";
        function type(): TypeDescriptor<MetadataUpdated>;
    }
    interface MetadataUpdatedInstance extends TypedEventInstance<MetadataUpdated> {
        data_decoded: MetadataUpdated;
        type_arguments: [];
    }
    interface MetadataUpdatedEvent {
        old_metadata: simple_map.SimpleMap<string, string>;
        new_metadata: simple_map.SimpleMap<string, string>;
    }
    namespace MetadataUpdatedEvent {
        const TYPE_QNAME = "0x1::multisig_account::MetadataUpdatedEvent";
        function type(): TypeDescriptor<MetadataUpdatedEvent>;
    }
    interface MetadataUpdatedEventInstance extends TypedEventInstance<MetadataUpdatedEvent> {
        data_decoded: MetadataUpdatedEvent;
        type_arguments: [];
    }
    interface MultisigAccount {
        owners: MoveAddressType[];
        num_signatures_required: bigint;
        transactions: table.Table<bigint, multisig_account.MultisigTransaction>;
        last_executed_sequence_number: bigint;
        next_sequence_number: bigint;
        signer_cap: option.Option<account.SignerCapability>;
        metadata: simple_map.SimpleMap<string, string>;
        add_owners_events: event.EventHandle<multisig_account.AddOwnersEvent>;
        remove_owners_events: event.EventHandle<multisig_account.RemoveOwnersEvent>;
        update_signature_required_events: event.EventHandle<multisig_account.UpdateSignaturesRequiredEvent>;
        create_transaction_events: event.EventHandle<multisig_account.CreateTransactionEvent>;
        vote_events: event.EventHandle<multisig_account.VoteEvent>;
        execute_rejected_transaction_events: event.EventHandle<multisig_account.ExecuteRejectedTransactionEvent>;
        execute_transaction_events: event.EventHandle<multisig_account.TransactionExecutionSucceededEvent>;
        transaction_execution_failed_events: event.EventHandle<multisig_account.TransactionExecutionFailedEvent>;
        metadata_updated_events: event.EventHandle<multisig_account.MetadataUpdatedEvent>;
    }
    namespace MultisigAccount {
        const TYPE_QNAME = "0x1::multisig_account::MultisigAccount";
        function type(): TypeDescriptor<MultisigAccount>;
    }
    interface MultisigAccountCreationMessage {
        chain_id: number;
        account_address: MoveAddressType;
        sequence_number: bigint;
        owners: MoveAddressType[];
        num_signatures_required: bigint;
    }
    namespace MultisigAccountCreationMessage {
        const TYPE_QNAME = "0x1::multisig_account::MultisigAccountCreationMessage";
        function type(): TypeDescriptor<MultisigAccountCreationMessage>;
    }
    interface MultisigAccountCreationWithAuthKeyRevocationMessage {
        chain_id: number;
        account_address: MoveAddressType;
        sequence_number: bigint;
        owners: MoveAddressType[];
        num_signatures_required: bigint;
    }
    namespace MultisigAccountCreationWithAuthKeyRevocationMessage {
        const TYPE_QNAME = "0x1::multisig_account::MultisigAccountCreationWithAuthKeyRevocationMessage";
        function type(): TypeDescriptor<MultisigAccountCreationWithAuthKeyRevocationMessage>;
    }
    interface MultisigTransaction {
        payload: option.Option<string>;
        payload_hash: option.Option<string>;
        votes: simple_map.SimpleMap<MoveAddressType, Boolean>;
        creator: MoveAddressType;
        creation_time_secs: bigint;
    }
    namespace MultisigTransaction {
        const TYPE_QNAME = "0x1::multisig_account::MultisigTransaction";
        function type(): TypeDescriptor<MultisigTransaction>;
    }
    interface MultisigTransactionInstance extends TypedEventInstance<MultisigTransaction> {
        data_decoded: MultisigTransaction;
        type_arguments: [];
    }
    interface RemoveOwners {
        multisig_account: MoveAddressType;
        owners_removed: MoveAddressType[];
    }
    namespace RemoveOwners {
        const TYPE_QNAME = "0x1::multisig_account::RemoveOwners";
        function type(): TypeDescriptor<RemoveOwners>;
    }
    interface RemoveOwnersInstance extends TypedEventInstance<RemoveOwners> {
        data_decoded: RemoveOwners;
        type_arguments: [];
    }
    interface RemoveOwnersEvent {
        owners_removed: MoveAddressType[];
    }
    namespace RemoveOwnersEvent {
        const TYPE_QNAME = "0x1::multisig_account::RemoveOwnersEvent";
        function type(): TypeDescriptor<RemoveOwnersEvent>;
    }
    interface RemoveOwnersEventInstance extends TypedEventInstance<RemoveOwnersEvent> {
        data_decoded: RemoveOwnersEvent;
        type_arguments: [];
    }
    interface TransactionExecutionFailed {
        multisig_account: MoveAddressType;
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
        execution_error: multisig_account.ExecutionError;
    }
    namespace TransactionExecutionFailed {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionFailed";
        function type(): TypeDescriptor<TransactionExecutionFailed>;
    }
    interface TransactionExecutionFailedInstance extends TypedEventInstance<TransactionExecutionFailed> {
        data_decoded: TransactionExecutionFailed;
        type_arguments: [];
    }
    interface TransactionExecutionFailedEvent {
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
        execution_error: multisig_account.ExecutionError;
    }
    namespace TransactionExecutionFailedEvent {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionFailedEvent";
        function type(): TypeDescriptor<TransactionExecutionFailedEvent>;
    }
    interface TransactionExecutionFailedEventInstance extends TypedEventInstance<TransactionExecutionFailedEvent> {
        data_decoded: TransactionExecutionFailedEvent;
        type_arguments: [];
    }
    interface TransactionExecutionSucceeded {
        multisig_account: MoveAddressType;
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
    }
    namespace TransactionExecutionSucceeded {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionSucceeded";
        function type(): TypeDescriptor<TransactionExecutionSucceeded>;
    }
    interface TransactionExecutionSucceededInstance extends TypedEventInstance<TransactionExecutionSucceeded> {
        data_decoded: TransactionExecutionSucceeded;
        type_arguments: [];
    }
    interface TransactionExecutionSucceededEvent {
        executor: MoveAddressType;
        sequence_number: bigint;
        transaction_payload: string;
        num_approvals: bigint;
    }
    namespace TransactionExecutionSucceededEvent {
        const TYPE_QNAME = "0x1::multisig_account::TransactionExecutionSucceededEvent";
        function type(): TypeDescriptor<TransactionExecutionSucceededEvent>;
    }
    interface TransactionExecutionSucceededEventInstance extends TypedEventInstance<TransactionExecutionSucceededEvent> {
        data_decoded: TransactionExecutionSucceededEvent;
        type_arguments: [];
    }
    interface UpdateSignaturesRequired {
        multisig_account: MoveAddressType;
        old_num_signatures_required: bigint;
        new_num_signatures_required: bigint;
    }
    namespace UpdateSignaturesRequired {
        const TYPE_QNAME = "0x1::multisig_account::UpdateSignaturesRequired";
        function type(): TypeDescriptor<UpdateSignaturesRequired>;
    }
    interface UpdateSignaturesRequiredInstance extends TypedEventInstance<UpdateSignaturesRequired> {
        data_decoded: UpdateSignaturesRequired;
        type_arguments: [];
    }
    interface UpdateSignaturesRequiredEvent {
        old_num_signatures_required: bigint;
        new_num_signatures_required: bigint;
    }
    namespace UpdateSignaturesRequiredEvent {
        const TYPE_QNAME = "0x1::multisig_account::UpdateSignaturesRequiredEvent";
        function type(): TypeDescriptor<UpdateSignaturesRequiredEvent>;
    }
    interface UpdateSignaturesRequiredEventInstance extends TypedEventInstance<UpdateSignaturesRequiredEvent> {
        data_decoded: UpdateSignaturesRequiredEvent;
        type_arguments: [];
    }
    interface Vote {
        multisig_account: MoveAddressType;
        owner: MoveAddressType;
        sequence_number: bigint;
        approved: Boolean;
    }
    namespace Vote {
        const TYPE_QNAME = "0x1::multisig_account::Vote";
        function type(): TypeDescriptor<Vote>;
    }
    interface VoteInstance extends TypedEventInstance<Vote> {
        data_decoded: Vote;
        type_arguments: [];
    }
    interface VoteEvent {
        owner: MoveAddressType;
        sequence_number: bigint;
        approved: Boolean;
    }
    namespace VoteEvent {
        const TYPE_QNAME = "0x1::multisig_account::VoteEvent";
        function type(): TypeDescriptor<VoteEvent>;
    }
    interface VoteEventInstance extends TypedEventInstance<VoteEvent> {
        data_decoded: VoteEvent;
        type_arguments: [];
    }
    interface AddOwnerPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface AddOwnersPayload extends TypedFunctionPayload<[MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[]];
        type_arguments: [];
    }
    interface AddOwnersAndUpdateSignaturesRequiredPayload extends TypedFunctionPayload<[MoveAddressType[], bigint]> {
        arguments_decoded: [MoveAddressType[], bigint];
        type_arguments: [];
    }
    interface ApproveTransactionPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface CreatePayload extends TypedFunctionPayload<[bigint, string[], string[]]> {
        arguments_decoded: [bigint, string[], string[]];
        type_arguments: [];
    }
    interface CreateTransactionPayload extends TypedFunctionPayload<[MoveAddressType, string]> {
        arguments_decoded: [MoveAddressType, string];
        type_arguments: [];
    }
    interface CreateTransactionWithHashPayload extends TypedFunctionPayload<[MoveAddressType, string]> {
        arguments_decoded: [MoveAddressType, string];
        type_arguments: [];
    }
    interface CreateWithExistingAccountPayload extends TypedFunctionPayload<[
        MoveAddressType,
        MoveAddressType[],
        bigint,
        number,
        string,
        string,
        string[],
        string[]
    ]> {
        arguments_decoded: [
            MoveAddressType,
            MoveAddressType[],
            bigint,
            number,
            string,
            string,
            string[],
            string[]
        ];
        type_arguments: [];
    }
    interface CreateWithExistingAccountAndRevokeAuthKeyPayload extends TypedFunctionPayload<[
        MoveAddressType,
        MoveAddressType[],
        bigint,
        number,
        string,
        string,
        string[],
        string[]
    ]> {
        arguments_decoded: [
            MoveAddressType,
            MoveAddressType[],
            bigint,
            number,
            string,
            string,
            string[],
            string[]
        ];
        type_arguments: [];
    }
    interface CreateWithOwnersPayload extends TypedFunctionPayload<[
        MoveAddressType[],
        bigint,
        string[],
        string[]
    ]> {
        arguments_decoded: [MoveAddressType[], bigint, string[], string[]];
        type_arguments: [];
    }
    interface CreateWithOwnersThenRemoveBootstrapperPayload extends TypedFunctionPayload<[
        MoveAddressType[],
        bigint,
        string[],
        string[]
    ]> {
        arguments_decoded: [MoveAddressType[], bigint, string[], string[]];
        type_arguments: [];
    }
    interface ExecuteRejectedTransactionPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface ExecuteRejectedTransactionsPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface RejectTransactionPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface RemoveOwnerPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface RemoveOwnersPayload extends TypedFunctionPayload<[MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[]];
        type_arguments: [];
    }
    interface SwapOwnerPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface SwapOwnersPayload extends TypedFunctionPayload<[MoveAddressType[], MoveAddressType[]]> {
        arguments_decoded: [MoveAddressType[], MoveAddressType[]];
        type_arguments: [];
    }
    interface SwapOwnersAndUpdateSignaturesRequiredPayload extends TypedFunctionPayload<[
        MoveAddressType[],
        MoveAddressType[],
        bigint
    ]> {
        arguments_decoded: [MoveAddressType[], MoveAddressType[], bigint];
        type_arguments: [];
    }
    interface UpdateMetadataPayload extends TypedFunctionPayload<[string[], string[]]> {
        arguments_decoded: [string[], string[]];
        type_arguments: [];
    }
    interface UpdateSignaturesRequiredPayload extends TypedFunctionPayload<[bigint]> {
        arguments_decoded: [bigint];
        type_arguments: [];
    }
    interface VoteTransactionPayload extends TypedFunctionPayload<[MoveAddressType, bigint, Boolean]> {
        arguments_decoded: [MoveAddressType, bigint, Boolean];
        type_arguments: [];
    }
    interface VoteTransactionsPayload extends TypedFunctionPayload<[MoveAddressType, bigint, bigint, Boolean]> {
        arguments_decoded: [MoveAddressType, bigint, bigint, Boolean];
        type_arguments: [];
    }
    interface VoteTransanctionPayload extends TypedFunctionPayload<[MoveAddressType, bigint, Boolean]> {
        arguments_decoded: [MoveAddressType, bigint, Boolean];
        type_arguments: [];
    }
}
export declare namespace pool_u64_unbound {
    interface Pool {
        total_coins: bigint;
        total_shares: bigint;
        shares: table_with_length.TableWithLength<MoveAddressType, bigint>;
        scaling_factor: bigint;
    }
    namespace Pool {
        const TYPE_QNAME = "0x1::pool_u64_unbound::Pool";
        function type(): TypeDescriptor<Pool>;
    }
}
export declare class resource_account extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): resource_account;
    onEntryCreateResourceAccount(func: (call: resource_account.CreateResourceAccountPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): resource_account;
    onEntryCreateResourceAccountAndFund(func: (call: resource_account.CreateResourceAccountAndFundPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): resource_account;
    onEntryCreateResourceAccountAndPublishPackage(func: (call: resource_account.CreateResourceAccountAndPublishPackagePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): resource_account;
}
export declare namespace resource_account {
    interface Container {
        store: simple_map.SimpleMap<MoveAddressType, account.SignerCapability>;
    }
    namespace Container {
        const TYPE_QNAME = "0x1::resource_account::Container";
        function type(): TypeDescriptor<Container>;
    }
    interface CreateResourceAccountPayload extends TypedFunctionPayload<[string, string]> {
        arguments_decoded: [string, string];
        type_arguments: [];
    }
    interface CreateResourceAccountAndFundPayload extends TypedFunctionPayload<[string, string, bigint]> {
        arguments_decoded: [string, string, bigint];
        type_arguments: [];
    }
    interface CreateResourceAccountAndPublishPackagePayload extends TypedFunctionPayload<[string, string, string[]]> {
        arguments_decoded: [string, string, string[]];
        type_arguments: [];
    }
}
export declare class staking_contract extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): staking_contract;
    onEntryAddStake(func: (call: staking_contract.AddStakePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEntryCreateStakingContract(func: (call: staking_contract.CreateStakingContractPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEntryDistribute(func: (call: staking_contract.DistributePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEntryRequestCommission(func: (call: staking_contract.RequestCommissionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEntryResetLockup(func: (call: staking_contract.ResetLockupPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEntrySetBeneficiaryForOperator(func: (call: staking_contract.SetBeneficiaryForOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEntrySwitchOperator(func: (call: staking_contract.SwitchOperatorPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEntrySwitchOperatorWithSameCommission(func: (call: staking_contract.SwitchOperatorWithSameCommissionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEntryUnlockRewards(func: (call: staking_contract.UnlockRewardsPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEntryUnlockStake(func: (call: staking_contract.UnlockStakePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEntryUpdateCommision(func: (call: staking_contract.UpdateCommisionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEntryUpdateVoter(func: (call: staking_contract.UpdateVoterPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventAddDistribution(func: (event: staking_contract.AddDistributionInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventAddDistributionEvent(func: (event: staking_contract.AddDistributionEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventAddStake(func: (event: staking_contract.AddStakeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventAddStakeEvent(func: (event: staking_contract.AddStakeEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventCreateStakingContract(func: (event: staking_contract.CreateStakingContractInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventCreateStakingContractEvent(func: (event: staking_contract.CreateStakingContractEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventDistribute(func: (event: staking_contract.DistributeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventDistributeEvent(func: (event: staking_contract.DistributeEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventRequestCommission(func: (event: staking_contract.RequestCommissionInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventRequestCommissionEvent(func: (event: staking_contract.RequestCommissionEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventResetLockup(func: (event: staking_contract.ResetLockupInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventResetLockupEvent(func: (event: staking_contract.ResetLockupEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventSetBeneficiaryForOperator(func: (event: staking_contract.SetBeneficiaryForOperatorInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventSwitchOperator(func: (event: staking_contract.SwitchOperatorInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventSwitchOperatorEvent(func: (event: staking_contract.SwitchOperatorEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventUnlockStake(func: (event: staking_contract.UnlockStakeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventUnlockStakeEvent(func: (event: staking_contract.UnlockStakeEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventUpdateCommission(func: (event: staking_contract.UpdateCommissionInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventUpdateCommissionEvent(func: (event: staking_contract.UpdateCommissionEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventUpdateVoter(func: (event: staking_contract.UpdateVoterInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
    onEventUpdateVoterEvent(func: (event: staking_contract.UpdateVoterEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): staking_contract;
}
export declare namespace staking_contract {
    interface AddDistribution {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddDistribution {
        const TYPE_QNAME = "0x1::staking_contract::AddDistribution";
        function type(): TypeDescriptor<AddDistribution>;
    }
    interface AddDistributionInstance extends TypedEventInstance<AddDistribution> {
        data_decoded: AddDistribution;
        type_arguments: [];
    }
    interface AddDistributionEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddDistributionEvent {
        const TYPE_QNAME = "0x1::staking_contract::AddDistributionEvent";
        function type(): TypeDescriptor<AddDistributionEvent>;
    }
    interface AddDistributionEventInstance extends TypedEventInstance<AddDistributionEvent> {
        data_decoded: AddDistributionEvent;
        type_arguments: [];
    }
    interface AddStake {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddStake {
        const TYPE_QNAME = "0x1::staking_contract::AddStake";
        function type(): TypeDescriptor<AddStake>;
    }
    interface AddStakeInstance extends TypedEventInstance<AddStake> {
        data_decoded: AddStake;
        type_arguments: [];
    }
    interface AddStakeEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
    }
    namespace AddStakeEvent {
        const TYPE_QNAME = "0x1::staking_contract::AddStakeEvent";
        function type(): TypeDescriptor<AddStakeEvent>;
    }
    interface AddStakeEventInstance extends TypedEventInstance<AddStakeEvent> {
        data_decoded: AddStakeEvent;
        type_arguments: [];
    }
    interface BeneficiaryForOperator {
        beneficiary_for_operator: MoveAddressType;
    }
    namespace BeneficiaryForOperator {
        const TYPE_QNAME = "0x1::staking_contract::BeneficiaryForOperator";
        function type(): TypeDescriptor<BeneficiaryForOperator>;
    }
    interface CreateStakingContract {
        operator: MoveAddressType;
        voter: MoveAddressType;
        pool_address: MoveAddressType;
        principal: bigint;
        commission_percentage: bigint;
    }
    namespace CreateStakingContract {
        const TYPE_QNAME = "0x1::staking_contract::CreateStakingContract";
        function type(): TypeDescriptor<CreateStakingContract>;
    }
    interface CreateStakingContractInstance extends TypedEventInstance<CreateStakingContract> {
        data_decoded: CreateStakingContract;
        type_arguments: [];
    }
    interface CreateStakingContractEvent {
        operator: MoveAddressType;
        voter: MoveAddressType;
        pool_address: MoveAddressType;
        principal: bigint;
        commission_percentage: bigint;
    }
    namespace CreateStakingContractEvent {
        const TYPE_QNAME = "0x1::staking_contract::CreateStakingContractEvent";
        function type(): TypeDescriptor<CreateStakingContractEvent>;
    }
    interface CreateStakingContractEventInstance extends TypedEventInstance<CreateStakingContractEvent> {
        data_decoded: CreateStakingContractEvent;
        type_arguments: [];
    }
    interface Distribute {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        recipient: MoveAddressType;
        amount: bigint;
    }
    namespace Distribute {
        const TYPE_QNAME = "0x1::staking_contract::Distribute";
        function type(): TypeDescriptor<Distribute>;
    }
    interface DistributeInstance extends TypedEventInstance<Distribute> {
        data_decoded: Distribute;
        type_arguments: [];
    }
    interface DistributeEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        recipient: MoveAddressType;
        amount: bigint;
    }
    namespace DistributeEvent {
        const TYPE_QNAME = "0x1::staking_contract::DistributeEvent";
        function type(): TypeDescriptor<DistributeEvent>;
    }
    interface DistributeEventInstance extends TypedEventInstance<DistributeEvent> {
        data_decoded: DistributeEvent;
        type_arguments: [];
    }
    interface RequestCommission {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        accumulated_rewards: bigint;
        commission_amount: bigint;
    }
    namespace RequestCommission {
        const TYPE_QNAME = "0x1::staking_contract::RequestCommission";
        function type(): TypeDescriptor<RequestCommission>;
    }
    interface RequestCommissionInstance extends TypedEventInstance<RequestCommission> {
        data_decoded: RequestCommission;
        type_arguments: [];
    }
    interface RequestCommissionEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        accumulated_rewards: bigint;
        commission_amount: bigint;
    }
    namespace RequestCommissionEvent {
        const TYPE_QNAME = "0x1::staking_contract::RequestCommissionEvent";
        function type(): TypeDescriptor<RequestCommissionEvent>;
    }
    interface RequestCommissionEventInstance extends TypedEventInstance<RequestCommissionEvent> {
        data_decoded: RequestCommissionEvent;
        type_arguments: [];
    }
    interface ResetLockup {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace ResetLockup {
        const TYPE_QNAME = "0x1::staking_contract::ResetLockup";
        function type(): TypeDescriptor<ResetLockup>;
    }
    interface ResetLockupInstance extends TypedEventInstance<ResetLockup> {
        data_decoded: ResetLockup;
        type_arguments: [];
    }
    interface ResetLockupEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace ResetLockupEvent {
        const TYPE_QNAME = "0x1::staking_contract::ResetLockupEvent";
        function type(): TypeDescriptor<ResetLockupEvent>;
    }
    interface ResetLockupEventInstance extends TypedEventInstance<ResetLockupEvent> {
        data_decoded: ResetLockupEvent;
        type_arguments: [];
    }
    interface SetBeneficiaryForOperator {
        operator: MoveAddressType;
        old_beneficiary: MoveAddressType;
        new_beneficiary: MoveAddressType;
    }
    namespace SetBeneficiaryForOperator {
        const TYPE_QNAME = "0x1::staking_contract::SetBeneficiaryForOperator";
        function type(): TypeDescriptor<SetBeneficiaryForOperator>;
    }
    interface SetBeneficiaryForOperatorInstance extends TypedEventInstance<SetBeneficiaryForOperator> {
        data_decoded: SetBeneficiaryForOperator;
        type_arguments: [];
    }
    interface StakingContract {
        principal: bigint;
        pool_address: MoveAddressType;
        owner_cap: stake.OwnerCapability;
        commission_percentage: bigint;
        distribution_pool: pool_u64.Pool;
        signer_cap: account.SignerCapability;
    }
    namespace StakingContract {
        const TYPE_QNAME = "0x1::staking_contract::StakingContract";
        function type(): TypeDescriptor<StakingContract>;
    }
    interface StakingGroupContainer {
        dummy_field: Boolean;
    }
    namespace StakingGroupContainer {
        const TYPE_QNAME = "0x1::staking_contract::StakingGroupContainer";
        function type(): TypeDescriptor<StakingGroupContainer>;
    }
    interface StakingGroupUpdateCommissionEvent {
        update_commission_events: event.EventHandle<staking_contract.UpdateCommissionEvent>;
    }
    namespace StakingGroupUpdateCommissionEvent {
        const TYPE_QNAME = "0x1::staking_contract::StakingGroupUpdateCommissionEvent";
        function type(): TypeDescriptor<StakingGroupUpdateCommissionEvent>;
    }
    interface Store {
        staking_contracts: simple_map.SimpleMap<MoveAddressType, staking_contract.StakingContract>;
        create_staking_contract_events: event.EventHandle<staking_contract.CreateStakingContractEvent>;
        update_voter_events: event.EventHandle<staking_contract.UpdateVoterEvent>;
        reset_lockup_events: event.EventHandle<staking_contract.ResetLockupEvent>;
        add_stake_events: event.EventHandle<staking_contract.AddStakeEvent>;
        request_commission_events: event.EventHandle<staking_contract.RequestCommissionEvent>;
        unlock_stake_events: event.EventHandle<staking_contract.UnlockStakeEvent>;
        switch_operator_events: event.EventHandle<staking_contract.SwitchOperatorEvent>;
        add_distribution_events: event.EventHandle<staking_contract.AddDistributionEvent>;
        distribute_events: event.EventHandle<staking_contract.DistributeEvent>;
    }
    namespace Store {
        const TYPE_QNAME = "0x1::staking_contract::Store";
        function type(): TypeDescriptor<Store>;
    }
    interface SwitchOperator {
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace SwitchOperator {
        const TYPE_QNAME = "0x1::staking_contract::SwitchOperator";
        function type(): TypeDescriptor<SwitchOperator>;
    }
    interface SwitchOperatorInstance extends TypedEventInstance<SwitchOperator> {
        data_decoded: SwitchOperator;
        type_arguments: [];
    }
    interface SwitchOperatorEvent {
        old_operator: MoveAddressType;
        new_operator: MoveAddressType;
        pool_address: MoveAddressType;
    }
    namespace SwitchOperatorEvent {
        const TYPE_QNAME = "0x1::staking_contract::SwitchOperatorEvent";
        function type(): TypeDescriptor<SwitchOperatorEvent>;
    }
    interface SwitchOperatorEventInstance extends TypedEventInstance<SwitchOperatorEvent> {
        data_decoded: SwitchOperatorEvent;
        type_arguments: [];
    }
    interface UnlockStake {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
        commission_paid: bigint;
    }
    namespace UnlockStake {
        const TYPE_QNAME = "0x1::staking_contract::UnlockStake";
        function type(): TypeDescriptor<UnlockStake>;
    }
    interface UnlockStakeInstance extends TypedEventInstance<UnlockStake> {
        data_decoded: UnlockStake;
        type_arguments: [];
    }
    interface UnlockStakeEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        amount: bigint;
        commission_paid: bigint;
    }
    namespace UnlockStakeEvent {
        const TYPE_QNAME = "0x1::staking_contract::UnlockStakeEvent";
        function type(): TypeDescriptor<UnlockStakeEvent>;
    }
    interface UnlockStakeEventInstance extends TypedEventInstance<UnlockStakeEvent> {
        data_decoded: UnlockStakeEvent;
        type_arguments: [];
    }
    interface UpdateCommission {
        staker: MoveAddressType;
        operator: MoveAddressType;
        old_commission_percentage: bigint;
        new_commission_percentage: bigint;
    }
    namespace UpdateCommission {
        const TYPE_QNAME = "0x1::staking_contract::UpdateCommission";
        function type(): TypeDescriptor<UpdateCommission>;
    }
    interface UpdateCommissionInstance extends TypedEventInstance<UpdateCommission> {
        data_decoded: UpdateCommission;
        type_arguments: [];
    }
    interface UpdateCommissionEvent {
        staker: MoveAddressType;
        operator: MoveAddressType;
        old_commission_percentage: bigint;
        new_commission_percentage: bigint;
    }
    namespace UpdateCommissionEvent {
        const TYPE_QNAME = "0x1::staking_contract::UpdateCommissionEvent";
        function type(): TypeDescriptor<UpdateCommissionEvent>;
    }
    interface UpdateCommissionEventInstance extends TypedEventInstance<UpdateCommissionEvent> {
        data_decoded: UpdateCommissionEvent;
        type_arguments: [];
    }
    interface UpdateVoter {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoter {
        const TYPE_QNAME = "0x1::staking_contract::UpdateVoter";
        function type(): TypeDescriptor<UpdateVoter>;
    }
    interface UpdateVoterInstance extends TypedEventInstance<UpdateVoter> {
        data_decoded: UpdateVoter;
        type_arguments: [];
    }
    interface UpdateVoterEvent {
        operator: MoveAddressType;
        pool_address: MoveAddressType;
        old_voter: MoveAddressType;
        new_voter: MoveAddressType;
    }
    namespace UpdateVoterEvent {
        const TYPE_QNAME = "0x1::staking_contract::UpdateVoterEvent";
        function type(): TypeDescriptor<UpdateVoterEvent>;
    }
    interface UpdateVoterEventInstance extends TypedEventInstance<UpdateVoterEvent> {
        data_decoded: UpdateVoterEvent;
        type_arguments: [];
    }
    interface AddStakePayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface CreateStakingContractPayload extends TypedFunctionPayload<[
        MoveAddressType,
        MoveAddressType,
        bigint,
        bigint,
        string
    ]> {
        arguments_decoded: [
            MoveAddressType,
            MoveAddressType,
            bigint,
            bigint,
            string
        ];
        type_arguments: [];
    }
    interface DistributePayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface RequestCommissionPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface ResetLockupPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SetBeneficiaryForOperatorPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface SwitchOperatorPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, MoveAddressType, bigint];
        type_arguments: [];
    }
    interface SwitchOperatorWithSameCommissionPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
    interface UnlockRewardsPayload extends TypedFunctionPayload<[MoveAddressType]> {
        arguments_decoded: [MoveAddressType];
        type_arguments: [];
    }
    interface UnlockStakePayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface UpdateCommisionPayload extends TypedFunctionPayload<[MoveAddressType, bigint]> {
        arguments_decoded: [MoveAddressType, bigint];
        type_arguments: [];
    }
    interface UpdateVoterPayload extends TypedFunctionPayload<[MoveAddressType, MoveAddressType]> {
        arguments_decoded: [MoveAddressType, MoveAddressType];
        type_arguments: [];
    }
}
export declare namespace system_addresses { }
export declare class randomness_config extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): randomness_config;
    onEventConfigOff(func: (event: randomness_config.ConfigOffInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): randomness_config;
    onEventConfigV1(func: (event: randomness_config.ConfigV1Instance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): randomness_config;
    onEventConfigV2(func: (event: randomness_config.ConfigV2Instance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): randomness_config;
    onEventRandomnessConfig(func: (event: randomness_config.RandomnessConfigInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): randomness_config;
}
export declare namespace randomness_config {
    interface ConfigOff {
        dummy_field: Boolean;
    }
    namespace ConfigOff {
        const TYPE_QNAME = "0x1::randomness_config::ConfigOff";
        function type(): TypeDescriptor<ConfigOff>;
    }
    interface ConfigOffInstance extends TypedEventInstance<ConfigOff> {
        data_decoded: ConfigOff;
        type_arguments: [];
    }
    interface ConfigV1 {
        secrecy_threshold: fixed_point64.FixedPoint64;
        reconstruction_threshold: fixed_point64.FixedPoint64;
    }
    namespace ConfigV1 {
        const TYPE_QNAME = "0x1::randomness_config::ConfigV1";
        function type(): TypeDescriptor<ConfigV1>;
    }
    interface ConfigV1Instance extends TypedEventInstance<ConfigV1> {
        data_decoded: ConfigV1;
        type_arguments: [];
    }
    interface ConfigV2 {
        secrecy_threshold: fixed_point64.FixedPoint64;
        reconstruction_threshold: fixed_point64.FixedPoint64;
        fast_path_secrecy_threshold: fixed_point64.FixedPoint64;
    }
    namespace ConfigV2 {
        const TYPE_QNAME = "0x1::randomness_config::ConfigV2";
        function type(): TypeDescriptor<ConfigV2>;
    }
    interface ConfigV2Instance extends TypedEventInstance<ConfigV2> {
        data_decoded: ConfigV2;
        type_arguments: [];
    }
    interface RandomnessConfig {
        variant: copyable_any.Any;
    }
    namespace RandomnessConfig {
        const TYPE_QNAME = "0x1::randomness_config::RandomnessConfig";
        function type(): TypeDescriptor<RandomnessConfig>;
    }
    interface RandomnessConfigInstance extends TypedEventInstance<RandomnessConfig> {
        data_decoded: RandomnessConfig;
        type_arguments: [];
    }
}
export declare namespace table_with_length {
    interface TableWithLength<T0, T1> {
        inner: table.Table<T0, T1>;
        length: bigint;
    }
    namespace TableWithLength {
        const TYPE_QNAME = "0x1::table_with_length::TableWithLength";
        function type<T0, T1>(arg0?: TypeDescriptor<T0>, arg1?: TypeDescriptor<T1>): TypeDescriptor<TableWithLength<T0, T1>>;
    }
}
export declare namespace aggregator_factory {
    interface AggregatorFactory {
        phantom_table: table.Table<MoveAddressType, bigint>;
    }
    namespace AggregatorFactory {
        const TYPE_QNAME = "0x1::aggregator_factory::AggregatorFactory";
        function type(): TypeDescriptor<AggregatorFactory>;
    }
}
export declare class governance_proposal extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): governance_proposal;
    onEventGovernanceProposal(func: (event: governance_proposal.GovernanceProposalInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): governance_proposal;
}
export declare namespace governance_proposal {
    interface GovernanceProposal {
        dummy_field: Boolean;
    }
    namespace GovernanceProposal {
        const TYPE_QNAME = "0x1::governance_proposal::GovernanceProposal";
        function type(): TypeDescriptor<GovernanceProposal>;
    }
    interface GovernanceProposalInstance extends TypedEventInstance<GovernanceProposal> {
        data_decoded: GovernanceProposal;
        type_arguments: [];
    }
}
export declare namespace optional_aggregator {
    interface Integer {
        value: bigint;
        limit: bigint;
    }
    namespace Integer {
        const TYPE_QNAME = "0x1::optional_aggregator::Integer";
        function type(): TypeDescriptor<Integer>;
    }
    interface OptionalAggregator {
        aggregator: option.Option<aggregator.Aggregator>;
        integer: option.Option<optional_aggregator.Integer>;
    }
    namespace OptionalAggregator {
        const TYPE_QNAME = "0x1::optional_aggregator::OptionalAggregator";
        function type(): TypeDescriptor<OptionalAggregator>;
    }
}
export declare class transaction_context extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): transaction_context;
    onEventAUID(func: (event: transaction_context.AUIDInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): transaction_context;
}
export declare namespace transaction_context {
    interface AUID {
        unique_address: MoveAddressType;
    }
    namespace AUID {
        const TYPE_QNAME = "0x1::transaction_context::AUID";
        function type(): TypeDescriptor<AUID>;
    }
    interface AUIDInstance extends TypedEventInstance<AUID> {
        data_decoded: AUID;
        type_arguments: [];
    }
    interface EntryFunctionPayload {
        account_address: MoveAddressType;
        module_name: string;
        function_name: string;
        ty_args_names: string[];
        args: string[];
    }
    namespace EntryFunctionPayload {
        const TYPE_QNAME = "0x1::transaction_context::EntryFunctionPayload";
        function type(): TypeDescriptor<EntryFunctionPayload>;
    }
    interface MultisigPayload {
        multisig_address: MoveAddressType;
        entry_function_payload: option.Option<transaction_context.EntryFunctionPayload>;
    }
    namespace MultisigPayload {
        const TYPE_QNAME = "0x1::transaction_context::MultisigPayload";
        function type(): TypeDescriptor<MultisigPayload>;
    }
}
export declare class jwk_consensus_config extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): jwk_consensus_config;
    onEventConfigOff(func: (event: jwk_consensus_config.ConfigOffInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwk_consensus_config;
    onEventConfigV1(func: (event: jwk_consensus_config.ConfigV1Instance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwk_consensus_config;
    onEventJWKConsensusConfig(func: (event: jwk_consensus_config.JWKConsensusConfigInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwk_consensus_config;
    onEventOIDCProvider(func: (event: jwk_consensus_config.OIDCProviderInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): jwk_consensus_config;
}
export declare namespace jwk_consensus_config {
    interface ConfigOff {
        dummy_field: Boolean;
    }
    namespace ConfigOff {
        const TYPE_QNAME = "0x1::jwk_consensus_config::ConfigOff";
        function type(): TypeDescriptor<ConfigOff>;
    }
    interface ConfigOffInstance extends TypedEventInstance<ConfigOff> {
        data_decoded: ConfigOff;
        type_arguments: [];
    }
    interface ConfigV1 {
        oidc_providers: jwk_consensus_config.OIDCProvider[];
    }
    namespace ConfigV1 {
        const TYPE_QNAME = "0x1::jwk_consensus_config::ConfigV1";
        function type(): TypeDescriptor<ConfigV1>;
    }
    interface ConfigV1Instance extends TypedEventInstance<ConfigV1> {
        data_decoded: ConfigV1;
        type_arguments: [];
    }
    interface JWKConsensusConfig {
        variant: copyable_any.Any;
    }
    namespace JWKConsensusConfig {
        const TYPE_QNAME = "0x1::jwk_consensus_config::JWKConsensusConfig";
        function type(): TypeDescriptor<JWKConsensusConfig>;
    }
    interface JWKConsensusConfigInstance extends TypedEventInstance<JWKConsensusConfig> {
        data_decoded: JWKConsensusConfig;
        type_arguments: [];
    }
    interface OIDCProvider {
        name: string;
        config_url: string;
    }
    namespace OIDCProvider {
        const TYPE_QNAME = "0x1::jwk_consensus_config::OIDCProvider";
        function type(): TypeDescriptor<OIDCProvider>;
    }
    interface OIDCProviderInstance extends TypedEventInstance<OIDCProvider> {
        data_decoded: OIDCProvider;
        type_arguments: [];
    }
}
export declare class ristretto255_elgamal extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): ristretto255_elgamal;
    onEventCompressedCiphertext(func: (event: ristretto255_elgamal.CompressedCiphertextInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): ristretto255_elgamal;
    onEventCompressedPubkey(func: (event: ristretto255_elgamal.CompressedPubkeyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): ristretto255_elgamal;
}
export declare namespace ristretto255_elgamal {
    interface Ciphertext {
        left: ristretto255.RistrettoPoint;
        right: ristretto255.RistrettoPoint;
    }
    namespace Ciphertext {
        const TYPE_QNAME = "0x1::ristretto255_elgamal::Ciphertext";
        function type(): TypeDescriptor<Ciphertext>;
    }
    interface CompressedCiphertext {
        left: ristretto255.CompressedRistretto;
        right: ristretto255.CompressedRistretto;
    }
    namespace CompressedCiphertext {
        const TYPE_QNAME = "0x1::ristretto255_elgamal::CompressedCiphertext";
        function type(): TypeDescriptor<CompressedCiphertext>;
    }
    interface CompressedCiphertextInstance extends TypedEventInstance<CompressedCiphertext> {
        data_decoded: CompressedCiphertext;
        type_arguments: [];
    }
    interface CompressedPubkey {
        point: ristretto255.CompressedRistretto;
    }
    namespace CompressedPubkey {
        const TYPE_QNAME = "0x1::ristretto255_elgamal::CompressedPubkey";
        function type(): TypeDescriptor<CompressedPubkey>;
    }
    interface CompressedPubkeyInstance extends TypedEventInstance<CompressedPubkey> {
        data_decoded: CompressedPubkey;
        type_arguments: [];
    }
}
export declare class reconfiguration_state extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): reconfiguration_state;
    onEventStateActive(func: (event: reconfiguration_state.StateActiveInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): reconfiguration_state;
    onEventStateInactive(func: (event: reconfiguration_state.StateInactiveInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): reconfiguration_state;
}
export declare namespace reconfiguration_state {
    interface State {
        variant: copyable_any.Any;
    }
    namespace State {
        const TYPE_QNAME = "0x1::reconfiguration_state::State";
        function type(): TypeDescriptor<State>;
    }
    interface StateActive {
        start_time_secs: bigint;
    }
    namespace StateActive {
        const TYPE_QNAME = "0x1::reconfiguration_state::StateActive";
        function type(): TypeDescriptor<StateActive>;
    }
    interface StateActiveInstance extends TypedEventInstance<StateActive> {
        data_decoded: StateActive;
        type_arguments: [];
    }
    interface StateInactive {
        dummy_field: Boolean;
    }
    namespace StateInactive {
        const TYPE_QNAME = "0x1::reconfiguration_state::StateInactive";
        function type(): TypeDescriptor<StateInactive>;
    }
    interface StateInactiveInstance extends TypedEventInstance<StateInactive> {
        data_decoded: StateInactive;
        type_arguments: [];
    }
}
export declare namespace ristretto255_pedersen {
    interface Commitment {
        point: ristretto255.RistrettoPoint;
    }
    namespace Commitment {
        const TYPE_QNAME = "0x1::ristretto255_pedersen::Commitment";
        function type(): TypeDescriptor<Commitment>;
    }
}
export declare class object_code_deployment extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): object_code_deployment;
    onEntryFreezeCodeObject(func: (call: object_code_deployment.FreezeCodeObjectPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): object_code_deployment;
    onEntryPublish(func: (call: object_code_deployment.PublishPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): object_code_deployment;
    onEntryUpgrade(func: (call: object_code_deployment.UpgradePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): object_code_deployment;
    onEventFreeze(func: (event: object_code_deployment.FreezeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): object_code_deployment;
    onEventPublish(func: (event: object_code_deployment.PublishInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): object_code_deployment;
    onEventUpgrade(func: (event: object_code_deployment.UpgradeInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): object_code_deployment;
}
export declare namespace object_code_deployment {
    interface Freeze {
        object_address: MoveAddressType;
    }
    namespace Freeze {
        const TYPE_QNAME = "0x1::object_code_deployment::Freeze";
        function type(): TypeDescriptor<Freeze>;
    }
    interface FreezeInstance extends TypedEventInstance<Freeze> {
        data_decoded: Freeze;
        type_arguments: [];
    }
    interface ManagingRefs {
        extend_ref: object_.ExtendRef;
    }
    namespace ManagingRefs {
        const TYPE_QNAME = "0x1::object_code_deployment::ManagingRefs";
        function type(): TypeDescriptor<ManagingRefs>;
    }
    interface Publish {
        object_address: MoveAddressType;
    }
    namespace Publish {
        const TYPE_QNAME = "0x1::object_code_deployment::Publish";
        function type(): TypeDescriptor<Publish>;
    }
    interface PublishInstance extends TypedEventInstance<Publish> {
        data_decoded: Publish;
        type_arguments: [];
    }
    interface Upgrade {
        object_address: MoveAddressType;
    }
    namespace Upgrade {
        const TYPE_QNAME = "0x1::object_code_deployment::Upgrade";
        function type(): TypeDescriptor<Upgrade>;
    }
    interface UpgradeInstance extends TypedEventInstance<Upgrade> {
        data_decoded: Upgrade;
        type_arguments: [];
    }
    interface FreezeCodeObjectPayload extends TypedFunctionPayload<[object_.Object<code.PackageRegistry>]> {
        arguments_decoded: [object_.Object<code.PackageRegistry>];
        type_arguments: [];
    }
    interface PublishPayload extends TypedFunctionPayload<[string, string[]]> {
        arguments_decoded: [string, string[]];
        type_arguments: [];
    }
    interface UpgradePayload extends TypedFunctionPayload<[
        string,
        string[],
        object_.Object<code.PackageRegistry>
    ]> {
        arguments_decoded: [string, string[], object_.Object<code.PackageRegistry>];
        type_arguments: [];
    }
}
export declare class primary_fungible_store extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): primary_fungible_store;
    onEntryTransfer(func: (call: primary_fungible_store.TransferPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): primary_fungible_store;
    onEntryTransferAssertMinimumDeposit(func: (call: primary_fungible_store.TransferAssertMinimumDepositPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): primary_fungible_store;
}
export declare namespace primary_fungible_store {
    interface DeriveRefPod {
        metadata_derive_ref: object_.DeriveRef;
    }
    namespace DeriveRefPod {
        const TYPE_QNAME = "0x1::primary_fungible_store::DeriveRefPod";
        function type(): TypeDescriptor<DeriveRefPod>;
    }
    interface TransferPayload<T0 = any> extends TypedFunctionPayload<[
        object_.Object<T0>,
        MoveAddressType,
        bigint
    ]> {
        arguments_decoded: [object_.Object<T0>, MoveAddressType, bigint];
        type_arguments: [string];
    }
    interface TransferAssertMinimumDepositPayload<T0 = any> extends TypedFunctionPayload<[
        object_.Object<T0>,
        MoveAddressType,
        bigint,
        bigint
    ]> {
        arguments_decoded: [object_.Object<T0>, MoveAddressType, bigint, bigint];
        type_arguments: [string];
    }
}
export declare namespace transaction_validation {
    interface TransactionValidation {
        module_addr: MoveAddressType;
        module_name: string;
        script_prologue_name: string;
        module_prologue_name: string;
        multi_agent_prologue_name: string;
        user_epilogue_name: string;
    }
    namespace TransactionValidation {
        const TYPE_QNAME = "0x1::transaction_validation::TransactionValidation";
        function type(): TypeDescriptor<TransactionValidation>;
    }
}
export declare class randomness_api_v0_config extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): randomness_api_v0_config;
    onEventAllowCustomMaxGasFlag(func: (event: randomness_api_v0_config.AllowCustomMaxGasFlagInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): randomness_api_v0_config;
    onEventRequiredGasDeposit(func: (event: randomness_api_v0_config.RequiredGasDepositInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): randomness_api_v0_config;
}
export declare namespace randomness_api_v0_config {
    interface AllowCustomMaxGasFlag {
        value: Boolean;
    }
    namespace AllowCustomMaxGasFlag {
        const TYPE_QNAME = "0x1::randomness_api_v0_config::AllowCustomMaxGasFlag";
        function type(): TypeDescriptor<AllowCustomMaxGasFlag>;
    }
    interface AllowCustomMaxGasFlagInstance extends TypedEventInstance<AllowCustomMaxGasFlag> {
        data_decoded: AllowCustomMaxGasFlag;
        type_arguments: [];
    }
    interface RequiredGasDeposit {
        gas_amount: option.Option<bigint>;
    }
    namespace RequiredGasDeposit {
        const TYPE_QNAME = "0x1::randomness_api_v0_config::RequiredGasDeposit";
        function type(): TypeDescriptor<RequiredGasDeposit>;
    }
    interface RequiredGasDepositInstance extends TypedEventInstance<RequiredGasDeposit> {
        data_decoded: RequiredGasDeposit;
        type_arguments: [];
    }
}
export declare class randomness_config_seqnum extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): randomness_config_seqnum;
    onEventRandomnessConfigSeqNum(func: (event: randomness_config_seqnum.RandomnessConfigSeqNumInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): randomness_config_seqnum;
}
export declare namespace randomness_config_seqnum {
    interface RandomnessConfigSeqNum {
        seq_num: bigint;
    }
    namespace RandomnessConfigSeqNum {
        const TYPE_QNAME = "0x1::randomness_config_seqnum::RandomnessConfigSeqNum";
        function type(): TypeDescriptor<RandomnessConfigSeqNum>;
    }
    interface RandomnessConfigSeqNumInstance extends TypedEventInstance<RandomnessConfigSeqNum> {
        data_decoded: RandomnessConfigSeqNum;
        type_arguments: [];
    }
}
export declare namespace reconfiguration_with_dkg { }
export declare class validator_consensus_info extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): validator_consensus_info;
    onEventValidatorConsensusInfo(func: (event: validator_consensus_info.ValidatorConsensusInfoInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): validator_consensus_info;
}
export declare namespace validator_consensus_info {
    interface ValidatorConsensusInfo {
        addr: MoveAddressType;
        pk_bytes: string;
        voting_power: bigint;
    }
    namespace ValidatorConsensusInfo {
        const TYPE_QNAME = "0x1::validator_consensus_info::ValidatorConsensusInfo";
        function type(): TypeDescriptor<ValidatorConsensusInfo>;
    }
    interface ValidatorConsensusInfoInstance extends TypedEventInstance<ValidatorConsensusInfo> {
        data_decoded: ValidatorConsensusInfo;
        type_arguments: [];
    }
}
export declare class ristretto255_bulletproofs extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): ristretto255_bulletproofs;
    onEventRangeProof(func: (event: ristretto255_bulletproofs.RangeProofInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): ristretto255_bulletproofs;
}
export declare namespace ristretto255_bulletproofs {
    interface RangeProof {
        bytes: string;
    }
    namespace RangeProof {
        const TYPE_QNAME = "0x1::ristretto255_bulletproofs::RangeProof";
        function type(): TypeDescriptor<RangeProof>;
    }
    interface RangeProofInstance extends TypedEventInstance<RangeProof> {
        data_decoded: RangeProof;
        type_arguments: [];
    }
}
export declare class dispatchable_fungible_asset extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): dispatchable_fungible_asset;
    onEntryTransfer(func: (call: dispatchable_fungible_asset.TransferPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): dispatchable_fungible_asset;
    onEntryTransferAssertMinimumDeposit(func: (call: dispatchable_fungible_asset.TransferAssertMinimumDepositPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): dispatchable_fungible_asset;
}
export declare namespace dispatchable_fungible_asset {
    interface TransferRefStore {
        transfer_ref: fungible_asset.TransferRef;
    }
    namespace TransferRefStore {
        const TYPE_QNAME = "0x1::dispatchable_fungible_asset::TransferRefStore";
        function type(): TypeDescriptor<TransferRefStore>;
    }
    interface TransferPayload<T0 = any> extends TypedFunctionPayload<[
        object_.Object<T0>,
        object_.Object<T0>,
        bigint
    ]> {
        arguments_decoded: [object_.Object<T0>, object_.Object<T0>, bigint];
        type_arguments: [string];
    }
    interface TransferAssertMinimumDepositPayload<T0 = any> extends TypedFunctionPayload<[
        object_.Object<T0>,
        object_.Object<T0>,
        bigint,
        bigint
    ]> {
        arguments_decoded: [object_.Object<T0>, object_.Object<T0>, bigint, bigint];
        type_arguments: [string];
    }
}
export declare function loadAllTypes(coder: MoveCoder): void;
//# sourceMappingURL=0x1.d.ts.map