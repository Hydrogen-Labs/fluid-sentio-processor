import { TypeDescriptor } from "@typemove/move";
import { MoveCoder, TypedEventInstance } from "@typemove/aptos";
import { CallFilter, MoveFetchConfig } from "@sentio/sdk/move";
import { AptosBindOptions, AptosBaseProcessor, TypedFunctionPayload, AptosContext } from "@sentio/sdk/aptos";
import { MoveAddressType } from "@aptos-labs/ts-sdk";
import * as _0x1 from "./0x1.js";
export declare class token extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): token;
    onEventBurnRef(func: (event: token.BurnRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): token;
    onEventMutation(func: (event: token.MutationInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): token;
    onEventMutationEvent(func: (event: token.MutationEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): token;
    onEventMutatorRef(func: (event: token.MutatorRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): token;
}
export declare namespace token {
    interface BurnRef {
        inner: _0x1.option.Option<_0x1.object_.DeleteRef>;
        self: _0x1.option.Option<MoveAddressType>;
    }
    namespace BurnRef {
        const TYPE_QNAME = "0x4::token::BurnRef";
        function type(): TypeDescriptor<BurnRef>;
    }
    interface BurnRefInstance extends TypedEventInstance<BurnRef> {
        data_decoded: BurnRef;
        type_arguments: [];
    }
    interface ConcurrentTokenIdentifiers {
        index: _0x1.aggregator_v2.AggregatorSnapshot<bigint>;
        name: _0x1.aggregator_v2.AggregatorSnapshot<string>;
    }
    namespace ConcurrentTokenIdentifiers {
        const TYPE_QNAME = "0x4::token::ConcurrentTokenIdentifiers";
        function type(): TypeDescriptor<ConcurrentTokenIdentifiers>;
    }
    interface Mutation {
        token_address: MoveAddressType;
        mutated_field_name: string;
        old_value: string;
        new_value: string;
    }
    namespace Mutation {
        const TYPE_QNAME = "0x4::token::Mutation";
        function type(): TypeDescriptor<Mutation>;
    }
    interface MutationInstance extends TypedEventInstance<Mutation> {
        data_decoded: Mutation;
        type_arguments: [];
    }
    interface MutationEvent {
        mutated_field_name: string;
        old_value: string;
        new_value: string;
    }
    namespace MutationEvent {
        const TYPE_QNAME = "0x4::token::MutationEvent";
        function type(): TypeDescriptor<MutationEvent>;
    }
    interface MutationEventInstance extends TypedEventInstance<MutationEvent> {
        data_decoded: MutationEvent;
        type_arguments: [];
    }
    interface MutatorRef {
        self: MoveAddressType;
    }
    namespace MutatorRef {
        const TYPE_QNAME = "0x4::token::MutatorRef";
        function type(): TypeDescriptor<MutatorRef>;
    }
    interface MutatorRefInstance extends TypedEventInstance<MutatorRef> {
        data_decoded: MutatorRef;
        type_arguments: [];
    }
    interface Token {
        collection: _0x1.object_.Object<collection.Collection>;
        index: bigint;
        description: string;
        name: string;
        uri: string;
        mutation_events: _0x1.event.EventHandle<token.MutationEvent>;
    }
    namespace Token {
        const TYPE_QNAME = "0x4::token::Token";
        function type(): TypeDescriptor<Token>;
    }
    interface TokenIdentifiers {
        index: _0x1.aggregator_v2.AggregatorSnapshot<bigint>;
        name: _0x1.aggregator_v2.DerivedStringSnapshot;
    }
    namespace TokenIdentifiers {
        const TYPE_QNAME = "0x4::token::TokenIdentifiers";
        function type(): TypeDescriptor<TokenIdentifiers>;
    }
}
export declare class royalty extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): royalty;
    onEventMutatorRef(func: (event: royalty.MutatorRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): royalty;
}
export declare namespace royalty {
    interface MutatorRef {
        inner: _0x1.object_.ExtendRef;
    }
    namespace MutatorRef {
        const TYPE_QNAME = "0x4::royalty::MutatorRef";
        function type(): TypeDescriptor<MutatorRef>;
    }
    interface MutatorRefInstance extends TypedEventInstance<MutatorRef> {
        data_decoded: MutatorRef;
        type_arguments: [];
    }
    interface Royalty {
        numerator: bigint;
        denominator: bigint;
        payee_address: MoveAddressType;
    }
    namespace Royalty {
        const TYPE_QNAME = "0x4::royalty::Royalty";
        function type(): TypeDescriptor<Royalty>;
    }
}
export declare class collection extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): collection;
    onEventBurn(func: (event: collection.BurnInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): collection;
    onEventBurnEvent(func: (event: collection.BurnEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): collection;
    onEventConcurrentBurnEvent(func: (event: collection.ConcurrentBurnEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): collection;
    onEventConcurrentMintEvent(func: (event: collection.ConcurrentMintEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): collection;
    onEventMint(func: (event: collection.MintInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): collection;
    onEventMintEvent(func: (event: collection.MintEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): collection;
    onEventMutation(func: (event: collection.MutationInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): collection;
    onEventMutationEvent(func: (event: collection.MutationEventInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): collection;
    onEventMutatorRef(func: (event: collection.MutatorRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): collection;
    onEventSetMaxSupply(func: (event: collection.SetMaxSupplyInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): collection;
}
export declare namespace collection {
    interface Burn {
        collection: MoveAddressType;
        index: bigint;
        token: MoveAddressType;
        previous_owner: MoveAddressType;
    }
    namespace Burn {
        const TYPE_QNAME = "0x4::collection::Burn";
        function type(): TypeDescriptor<Burn>;
    }
    interface BurnInstance extends TypedEventInstance<Burn> {
        data_decoded: Burn;
        type_arguments: [];
    }
    interface BurnEvent {
        index: bigint;
        token: MoveAddressType;
    }
    namespace BurnEvent {
        const TYPE_QNAME = "0x4::collection::BurnEvent";
        function type(): TypeDescriptor<BurnEvent>;
    }
    interface BurnEventInstance extends TypedEventInstance<BurnEvent> {
        data_decoded: BurnEvent;
        type_arguments: [];
    }
    interface Collection {
        creator: MoveAddressType;
        description: string;
        name: string;
        uri: string;
        mutation_events: _0x1.event.EventHandle<collection.MutationEvent>;
    }
    namespace Collection {
        const TYPE_QNAME = "0x4::collection::Collection";
        function type(): TypeDescriptor<Collection>;
    }
    interface ConcurrentBurnEvent {
        collection_addr: MoveAddressType;
        index: bigint;
        token: MoveAddressType;
    }
    namespace ConcurrentBurnEvent {
        const TYPE_QNAME = "0x4::collection::ConcurrentBurnEvent";
        function type(): TypeDescriptor<ConcurrentBurnEvent>;
    }
    interface ConcurrentBurnEventInstance extends TypedEventInstance<ConcurrentBurnEvent> {
        data_decoded: ConcurrentBurnEvent;
        type_arguments: [];
    }
    interface ConcurrentMintEvent {
        collection_addr: MoveAddressType;
        index: _0x1.aggregator_v2.AggregatorSnapshot<bigint>;
        token: MoveAddressType;
    }
    namespace ConcurrentMintEvent {
        const TYPE_QNAME = "0x4::collection::ConcurrentMintEvent";
        function type(): TypeDescriptor<ConcurrentMintEvent>;
    }
    interface ConcurrentMintEventInstance extends TypedEventInstance<ConcurrentMintEvent> {
        data_decoded: ConcurrentMintEvent;
        type_arguments: [];
    }
    interface ConcurrentSupply {
        current_supply: _0x1.aggregator_v2.Aggregator<bigint>;
        total_minted: _0x1.aggregator_v2.Aggregator<bigint>;
    }
    namespace ConcurrentSupply {
        const TYPE_QNAME = "0x4::collection::ConcurrentSupply";
        function type(): TypeDescriptor<ConcurrentSupply>;
    }
    interface FixedSupply {
        current_supply: bigint;
        max_supply: bigint;
        total_minted: bigint;
        burn_events: _0x1.event.EventHandle<collection.BurnEvent>;
        mint_events: _0x1.event.EventHandle<collection.MintEvent>;
    }
    namespace FixedSupply {
        const TYPE_QNAME = "0x4::collection::FixedSupply";
        function type(): TypeDescriptor<FixedSupply>;
    }
    interface Mint {
        collection: MoveAddressType;
        index: _0x1.aggregator_v2.AggregatorSnapshot<bigint>;
        token: MoveAddressType;
    }
    namespace Mint {
        const TYPE_QNAME = "0x4::collection::Mint";
        function type(): TypeDescriptor<Mint>;
    }
    interface MintInstance extends TypedEventInstance<Mint> {
        data_decoded: Mint;
        type_arguments: [];
    }
    interface MintEvent {
        index: bigint;
        token: MoveAddressType;
    }
    namespace MintEvent {
        const TYPE_QNAME = "0x4::collection::MintEvent";
        function type(): TypeDescriptor<MintEvent>;
    }
    interface MintEventInstance extends TypedEventInstance<MintEvent> {
        data_decoded: MintEvent;
        type_arguments: [];
    }
    interface Mutation {
        mutated_field_name: string;
        collection: _0x1.object_.Object<collection.Collection>;
        old_value: string;
        new_value: string;
    }
    namespace Mutation {
        const TYPE_QNAME = "0x4::collection::Mutation";
        function type(): TypeDescriptor<Mutation>;
    }
    interface MutationInstance extends TypedEventInstance<Mutation> {
        data_decoded: Mutation;
        type_arguments: [];
    }
    interface MutationEvent {
        mutated_field_name: string;
    }
    namespace MutationEvent {
        const TYPE_QNAME = "0x4::collection::MutationEvent";
        function type(): TypeDescriptor<MutationEvent>;
    }
    interface MutationEventInstance extends TypedEventInstance<MutationEvent> {
        data_decoded: MutationEvent;
        type_arguments: [];
    }
    interface MutatorRef {
        self: MoveAddressType;
    }
    namespace MutatorRef {
        const TYPE_QNAME = "0x4::collection::MutatorRef";
        function type(): TypeDescriptor<MutatorRef>;
    }
    interface MutatorRefInstance extends TypedEventInstance<MutatorRef> {
        data_decoded: MutatorRef;
        type_arguments: [];
    }
    interface SetMaxSupply {
        collection: _0x1.object_.Object<collection.Collection>;
        old_max_supply: bigint;
        new_max_supply: bigint;
    }
    namespace SetMaxSupply {
        const TYPE_QNAME = "0x4::collection::SetMaxSupply";
        function type(): TypeDescriptor<SetMaxSupply>;
    }
    interface SetMaxSupplyInstance extends TypedEventInstance<SetMaxSupply> {
        data_decoded: SetMaxSupply;
        type_arguments: [];
    }
    interface UnlimitedSupply {
        current_supply: bigint;
        total_minted: bigint;
        burn_events: _0x1.event.EventHandle<collection.BurnEvent>;
        mint_events: _0x1.event.EventHandle<collection.MintEvent>;
    }
    namespace UnlimitedSupply {
        const TYPE_QNAME = "0x4::collection::UnlimitedSupply";
        function type(): TypeDescriptor<UnlimitedSupply>;
    }
}
export declare class aptos_token extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): aptos_token;
    onEntryAddProperty(func: (call: aptos_token.AddPropertyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntryAddTypedProperty(func: (call: aptos_token.AddTypedPropertyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntryBurn(func: (call: aptos_token.BurnPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntryCreateCollection(func: (call: aptos_token.CreateCollectionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntryFreezeTransfer(func: (call: aptos_token.FreezeTransferPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntryMint(func: (call: aptos_token.MintPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntryMintSoulBound(func: (call: aptos_token.MintSoulBoundPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntryRemoveProperty(func: (call: aptos_token.RemovePropertyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntrySetCollectionDescription(func: (call: aptos_token.SetCollectionDescriptionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntrySetCollectionRoyaltiesCall(func: (call: aptos_token.SetCollectionRoyaltiesCallPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntrySetCollectionUri(func: (call: aptos_token.SetCollectionUriPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntrySetDescription(func: (call: aptos_token.SetDescriptionPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntrySetName(func: (call: aptos_token.SetNamePayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntrySetUri(func: (call: aptos_token.SetUriPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntryUnfreezeTransfer(func: (call: aptos_token.UnfreezeTransferPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntryUpdateProperty(func: (call: aptos_token.UpdatePropertyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
    onEntryUpdateTypedProperty(func: (call: aptos_token.UpdateTypedPropertyPayload, ctx: AptosContext) => void, filter?: CallFilter, fetchConfig?: Partial<MoveFetchConfig>): aptos_token;
}
export declare namespace aptos_token {
    interface AptosCollection {
        mutator_ref: _0x1.option.Option<collection.MutatorRef>;
        royalty_mutator_ref: _0x1.option.Option<royalty.MutatorRef>;
        mutable_description: Boolean;
        mutable_uri: Boolean;
        mutable_token_description: Boolean;
        mutable_token_name: Boolean;
        mutable_token_properties: Boolean;
        mutable_token_uri: Boolean;
        tokens_burnable_by_creator: Boolean;
        tokens_freezable_by_creator: Boolean;
    }
    namespace AptosCollection {
        const TYPE_QNAME = "0x4::aptos_token::AptosCollection";
        function type(): TypeDescriptor<AptosCollection>;
    }
    interface AptosToken {
        burn_ref: _0x1.option.Option<token.BurnRef>;
        transfer_ref: _0x1.option.Option<_0x1.object_.TransferRef>;
        mutator_ref: _0x1.option.Option<token.MutatorRef>;
        property_mutator_ref: property_map.MutatorRef;
    }
    namespace AptosToken {
        const TYPE_QNAME = "0x4::aptos_token::AptosToken";
        function type(): TypeDescriptor<AptosToken>;
    }
    interface AddPropertyPayload<T0 = any> extends TypedFunctionPayload<[
        _0x1.object_.Object<T0>,
        string,
        string,
        string
    ]> {
        arguments_decoded: [_0x1.object_.Object<T0>, string, string, string];
        type_arguments: [string];
    }
    interface AddTypedPropertyPayload<T0 = any, T1 = any> extends TypedFunctionPayload<[_0x1.object_.Object<T0>, string, T1]> {
        arguments_decoded: [_0x1.object_.Object<T0>, string, T1];
        type_arguments: [string, string];
    }
    interface BurnPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object_.Object<T0>]> {
        arguments_decoded: [_0x1.object_.Object<T0>];
        type_arguments: [string];
    }
    interface CreateCollectionPayload extends TypedFunctionPayload<[
        string,
        bigint,
        string,
        string,
        Boolean,
        Boolean,
        Boolean,
        Boolean,
        Boolean,
        Boolean,
        Boolean,
        Boolean,
        Boolean,
        bigint,
        bigint
    ]> {
        arguments_decoded: [
            string,
            bigint,
            string,
            string,
            Boolean,
            Boolean,
            Boolean,
            Boolean,
            Boolean,
            Boolean,
            Boolean,
            Boolean,
            Boolean,
            bigint,
            bigint
        ];
        type_arguments: [];
    }
    interface FreezeTransferPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object_.Object<T0>]> {
        arguments_decoded: [_0x1.object_.Object<T0>];
        type_arguments: [string];
    }
    interface MintPayload extends TypedFunctionPayload<[
        string,
        string,
        string,
        string,
        string[],
        string[],
        string[]
    ]> {
        arguments_decoded: [
            string,
            string,
            string,
            string,
            string[],
            string[],
            string[]
        ];
        type_arguments: [];
    }
    interface MintSoulBoundPayload extends TypedFunctionPayload<[
        string,
        string,
        string,
        string,
        string[],
        string[],
        string[],
        MoveAddressType
    ]> {
        arguments_decoded: [
            string,
            string,
            string,
            string,
            string[],
            string[],
            string[],
            MoveAddressType
        ];
        type_arguments: [];
    }
    interface RemovePropertyPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object_.Object<T0>, string]> {
        arguments_decoded: [_0x1.object_.Object<T0>, string];
        type_arguments: [string];
    }
    interface SetCollectionDescriptionPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object_.Object<T0>, string]> {
        arguments_decoded: [_0x1.object_.Object<T0>, string];
        type_arguments: [string];
    }
    interface SetCollectionRoyaltiesCallPayload<T0 = any> extends TypedFunctionPayload<[
        _0x1.object_.Object<T0>,
        bigint,
        bigint,
        MoveAddressType
    ]> {
        arguments_decoded: [
            _0x1.object_.Object<T0>,
            bigint,
            bigint,
            MoveAddressType
        ];
        type_arguments: [string];
    }
    interface SetCollectionUriPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object_.Object<T0>, string]> {
        arguments_decoded: [_0x1.object_.Object<T0>, string];
        type_arguments: [string];
    }
    interface SetDescriptionPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object_.Object<T0>, string]> {
        arguments_decoded: [_0x1.object_.Object<T0>, string];
        type_arguments: [string];
    }
    interface SetNamePayload<T0 = any> extends TypedFunctionPayload<[_0x1.object_.Object<T0>, string]> {
        arguments_decoded: [_0x1.object_.Object<T0>, string];
        type_arguments: [string];
    }
    interface SetUriPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object_.Object<T0>, string]> {
        arguments_decoded: [_0x1.object_.Object<T0>, string];
        type_arguments: [string];
    }
    interface UnfreezeTransferPayload<T0 = any> extends TypedFunctionPayload<[_0x1.object_.Object<T0>]> {
        arguments_decoded: [_0x1.object_.Object<T0>];
        type_arguments: [string];
    }
    interface UpdatePropertyPayload<T0 = any> extends TypedFunctionPayload<[
        _0x1.object_.Object<T0>,
        string,
        string,
        string
    ]> {
        arguments_decoded: [_0x1.object_.Object<T0>, string, string, string];
        type_arguments: [string];
    }
    interface UpdateTypedPropertyPayload<T0 = any, T1 = any> extends TypedFunctionPayload<[_0x1.object_.Object<T0>, string, T1]> {
        arguments_decoded: [_0x1.object_.Object<T0>, string, T1];
        type_arguments: [string, string];
    }
}
export declare class property_map extends AptosBaseProcessor {
    constructor(options: AptosBindOptions);
    static DEFAULT_OPTIONS: AptosBindOptions;
    static bind(options?: Partial<AptosBindOptions>): property_map;
    onEventMutatorRef(func: (event: property_map.MutatorRefInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): property_map;
    onEventPropertyValue(func: (event: property_map.PropertyValueInstance, ctx: AptosContext) => void, fetchConfig?: Partial<MoveFetchConfig>): property_map;
}
export declare namespace property_map {
    interface MutatorRef {
        self: MoveAddressType;
    }
    namespace MutatorRef {
        const TYPE_QNAME = "0x4::property_map::MutatorRef";
        function type(): TypeDescriptor<MutatorRef>;
    }
    interface MutatorRefInstance extends TypedEventInstance<MutatorRef> {
        data_decoded: MutatorRef;
        type_arguments: [];
    }
    interface PropertyMap {
        inner: _0x1.simple_map.SimpleMap<string, property_map.PropertyValue>;
    }
    namespace PropertyMap {
        const TYPE_QNAME = "0x4::property_map::PropertyMap";
        function type(): TypeDescriptor<PropertyMap>;
    }
    interface PropertyValue {
        type: number;
        value: string;
    }
    namespace PropertyValue {
        const TYPE_QNAME = "0x4::property_map::PropertyValue";
        function type(): TypeDescriptor<PropertyValue>;
    }
    interface PropertyValueInstance extends TypedEventInstance<PropertyValue> {
        data_decoded: PropertyValue;
        type_arguments: [];
    }
}
export declare function loadAllTypes(coder: MoveCoder): void;
//# sourceMappingURL=0x4.d.ts.map