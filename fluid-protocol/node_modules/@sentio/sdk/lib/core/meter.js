import { toMetricValue } from './numberish.js';
import { NamedResultDescriptor } from './metadata.js';
import { AggregationType, MetricConfig, MetricType } from '@sentio/protos';
import { MapStateStorage } from '@sentio/runtime';
export class MetricOptions {
    unit;
    description;
    sparse;
    // persistentBetweenVersion?: boolean
    aggregationConfig;
}
export class CounterOptions {
    unit;
    description;
    sparse;
    resolutionConfig;
}
// enum MetricType {
//   Counter = 0,
//   Gauge = 1,
// }
export class Metric extends NamedResultDescriptor {
    config;
    constructor(type, name, option) {
        super(name);
        this.config = MetricConfig.fromPartial({ ...option, name: this.name, type });
        const aggregationConfig = this.config.aggregationConfig;
        if (aggregationConfig && aggregationConfig.intervalInMinutes.length) {
            if (aggregationConfig.intervalInMinutes.length > 1) {
                console.error('current only support one intervalInMinutes, only first interval will be used for', name);
            }
            if (aggregationConfig.intervalInMinutes[0] > 0 && aggregationConfig.types.length === 0) {
                aggregationConfig.types = [AggregationType.SUM, AggregationType.COUNT];
            }
        }
    }
}
export class MetricState extends MapStateStorage {
    static INSTANCE = new MetricState();
    getOrRegisterMetric(type, name, option) {
        const metricMap = this.getOrRegister();
        let metric = metricMap.get(name);
        if (metric && metric.config.type !== type) {
            throw Error(`redefine ${name} of metric type ${type} that is previously ${metric.config.type}`);
        }
        if (!metric) {
            if (type === MetricType.COUNTER) {
                metric = Counter._create(name, option);
            }
            else {
                metric = Gauge._create(name, option);
            }
        }
        metricMap.set(name, metric);
        return metric;
    }
}
export class Counter extends Metric {
    static register(name, option) {
        return MetricState.INSTANCE.getOrRegisterMetric(MetricType.COUNTER, name, option);
    }
    /**
     * internal use only, to create a metric use {@link register} instead
     */
    static _create(name, option) {
        return new Counter(name, option);
    }
    constructor(name, option) {
        super(MetricType.COUNTER, name, MetricConfig.fromPartial({
            ...option,
            aggregationConfig: {
                intervalInMinutes: option?.resolutionConfig ? [option?.resolutionConfig?.intervalInMinutes] : []
            }
        }));
    }
    add(ctx, value, labels = {}) {
        this.record(ctx, value, labels, true);
    }
    sub(ctx, value, labels = {}) {
        this.record(ctx, value, labels, false);
    }
    record(ctx, value, labels, add) {
        ctx.update({
            counters: [
                {
                    metadata: ctx.getMetaData(this.name, labels),
                    metricValue: toMetricValue(value),
                    add: add,
                    runtimeInfo: undefined
                }
            ]
        });
    }
}
export class CounterBinding {
    ctx;
    counter;
    constructor(name, ctx) {
        this.counter = Counter._create(name);
        this.ctx = ctx;
    }
    add(value, labels = {}) {
        this.counter.add(this.ctx, value, labels);
    }
    sub(value, labels = {}) {
        this.counter.sub(this.ctx, value, labels);
    }
}
export class Gauge extends Metric {
    static register(name, option) {
        return MetricState.INSTANCE.getOrRegisterMetric(MetricType.GAUGE, name, option);
    }
    /**
     * internal use only, to create a metric use {@link register} instead
     */
    static _create(name, option) {
        return new Gauge(name, option);
    }
    constructor(name, option) {
        super(MetricType.GAUGE, name, MetricConfig.fromPartial({ ...option }));
    }
    record(ctx, value, labels = {}) {
        ctx.update({
            gauges: [
                {
                    metadata: ctx.getMetaData(this.config.name, labels),
                    metricValue: toMetricValue(value),
                    runtimeInfo: undefined
                }
            ]
        });
    }
}
export class GaugeBinding {
    gauge;
    ctx;
    constructor(name, ctx) {
        this.gauge = Gauge._create(name);
        this.ctx = ctx;
    }
    record(value, labels = {}) {
        this.gauge.record(this.ctx, value, labels);
    }
}
export class Meter {
    ctx;
    constructor(ctx) {
        this.ctx = ctx;
    }
    Counter(name) {
        return new CounterBinding(name, this.ctx);
    }
    Gauge(name) {
        return new GaugeBinding(name, this.ctx);
    }
}
//# sourceMappingURL=meter.js.map