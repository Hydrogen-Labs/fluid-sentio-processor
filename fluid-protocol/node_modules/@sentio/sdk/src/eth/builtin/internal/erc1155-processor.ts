/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { BigNumberish, Overrides, BytesLike, Interface } from "ethers";
import {
  addContractByABI,
  getContractByABI,
  addProcessor,
  getProcessor,
  getProvider,
  transformEtherError,
  BindOptions,
  BaseProcessor,
  BaseProcessorTemplate,
  BoundContractView,
  ContractContext,
  ContractView,
  DummyProvider,
  EthChainId,
  TypedCallTrace,
  EthContext,
  EthFetchConfig,
  PreprocessResult,
} from "@sentio/sdk/eth";
import { EthCallParam, EthCallContext, PreparedData } from "@sentio/protos";

import { ERC1155__factory } from "./index.js";
import {
  ERC1155,
  ApprovalForAllEvent,
  ApprovalForAllEventFilter,
  TransferBatchEvent,
  TransferBatchEventFilter,
  TransferSingleEvent,
  TransferSingleEventFilter,
  URIEvent,
  URIEventFilter,
} from "./ERC1155.js";

export interface BalanceOfCallObject {
  account: string;
  id: bigint;
}

export type BalanceOfCallTrace = TypedCallTrace<
  [string, bigint],
  BalanceOfCallObject
>;

export interface BalanceOfBatchCallObject {
  accounts: string[];
  ids: bigint[];
}

export type BalanceOfBatchCallTrace = TypedCallTrace<
  [string[], bigint[]],
  BalanceOfBatchCallObject
>;

export interface IsApprovedForAllCallObject {
  account: string;
  operator: string;
}

export type IsApprovedForAllCallTrace = TypedCallTrace<
  [string, string],
  IsApprovedForAllCallObject
>;

export interface SafeBatchTransferFromCallObject {
  from: string;
  to: string;
  ids: bigint[];
  amounts: bigint[];
  data: string;
}

export type SafeBatchTransferFromCallTrace = TypedCallTrace<
  [string, string, bigint[], bigint[], string],
  SafeBatchTransferFromCallObject
>;

export interface SafeTransferFromCallObject {
  from: string;
  to: string;
  id: bigint;
  amount: bigint;
  data: string;
}

export type SafeTransferFromCallTrace = TypedCallTrace<
  [string, string, bigint, bigint, string],
  SafeTransferFromCallObject
>;

export interface SetApprovalForAllCallObject {
  operator: string;
  approved: boolean;
}

export type SetApprovalForAllCallTrace = TypedCallTrace<
  [string, boolean],
  SetApprovalForAllCallObject
>;

export interface SupportsInterfaceCallObject {
  interfaceId: string;
}

export type SupportsInterfaceCallTrace = TypedCallTrace<
  [string],
  SupportsInterfaceCallObject
>;

export interface UriCallObject {
  id: bigint;
}

export type UriCallTrace = TypedCallTrace<[bigint], UriCallObject>;

const templateContract = ERC1155__factory.connect("0x0", DummyProvider);

const iface = new Interface([
  "function balanceOf(address account, uint256 id) view returns (uint256)",
  "function balanceOfBatch(address[] accounts, uint256[] ids) view returns (uint256[])",
  "function isApprovedForAll(address account, address operator) view returns (bool)",
  "function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns ()",
  "function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns ()",
  "function setApprovalForAll(address operator, bool approved) returns ()",
  "function supportsInterface(bytes4 interfaceId) view returns (bool)",
  "function uri(uint256 id) view returns (string)",
]);

export class ERC1155ContractView extends ContractView<ERC1155> {
  constructor(contract: ERC1155) {
    super(contract);
    this.callStatic.contract = contract;
  }

  async balanceOf(
    account: string,
    id: BigNumberish,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("balanceOf(address,uint256)")(
        account,
        id,
        overrides || {}
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async balanceOfBatch(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<bigint[]> {
    try {
      return await this.contract.getFunction(
        "balanceOfBatch(address[],uint256[])"
      )(accounts, ids, overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async isApprovedForAll(
    account: string,
    operator: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<boolean> {
    try {
      return await this.contract.getFunction(
        "isApprovedForAll(address,address)"
      )(account, operator, overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async supportsInterface(
    interfaceId: BytesLike,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<boolean> {
    try {
      return await this.contract.getFunction("supportsInterface(bytes4)")(
        interfaceId,
        overrides || {}
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async uri(
    id: BigNumberish,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<string> {
    try {
      return await this.contract.getFunction("uri(uint256)")(
        id,
        overrides || {}
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  callStatic = {
    contract: this.contract,

    async safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction(
            "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"
          )
          .staticCall(from, to, ids, amounts, data, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction(
            "safeTransferFrom(address,address,uint256,uint256,bytes)"
          )
          .staticCall(from, to, id, amount, data, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("setApprovalForAll(address,bool)")
          .staticCall(operator, approved, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };

  encodeCall = {
    balanceOf(
      account: string,
      id: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function balanceOf(address,uint256)"]);
        const calldata = iface.encodeFunctionData("balanceOf", [account, id]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function balanceOfBatch(address[],uint256[])",
        ]);
        const calldata = iface.encodeFunctionData("balanceOfBatch", [
          accounts,
          ids,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    isApprovedForAll(
      account: string,
      operator: string,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function isApprovedForAll(address,address)",
        ]);
        const calldata = iface.encodeFunctionData("isApprovedForAll", [
          account,
          operator,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
        ]);
        const calldata = iface.encodeFunctionData("safeBatchTransferFrom", [
          from,
          to,
          ids,
          amounts,
          data,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function safeTransferFrom(address,address,uint256,uint256,bytes)",
        ]);
        const calldata = iface.encodeFunctionData("safeTransferFrom", [
          from,
          to,
          id,
          amount,
          data,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    setApprovalForAll(
      operator: string,
      approved: boolean,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function setApprovalForAll(address,bool)",
        ]);
        const calldata = iface.encodeFunctionData("setApprovalForAll", [
          operator,
          approved,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    supportsInterface(
      interfaceId: BytesLike,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function supportsInterface(bytes4)"]);
        const calldata = iface.encodeFunctionData("supportsInterface", [
          interfaceId,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    uri(id: BigNumberish, ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function uri(uint256)"]);
        const calldata = iface.encodeFunctionData("uri", [id]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };
}

export class ERC1155BoundContractView extends BoundContractView<
  ERC1155,
  ERC1155ContractView
> {
  async balanceOf(
    account: string,
    id: BigNumberish,
    overrides?: Overrides
  ): Promise<bigint> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.balanceOf(
      account,
      id,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async balanceOfBatch(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: Overrides
  ): Promise<bigint[]> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.balanceOfBatch(
      accounts,
      ids,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async isApprovedForAll(
    account: string,
    operator: string,
    overrides?: Overrides
  ): Promise<boolean> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.isApprovedForAll(
      account,
      operator,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async supportsInterface(
    interfaceId: BytesLike,
    overrides?: Overrides
  ): Promise<boolean> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.supportsInterface(
      interfaceId,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async uri(id: BigNumberish, overrides?: Overrides): Promise<string> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.uri(
      id,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  callStatic = {
    view: this.view,
    context: this.context,

    async safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides
    ): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.safeBatchTransferFrom(
        from,
        to,
        ids,
        amounts,
        data,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides
    ): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.safeTransferFrom(
        from,
        to,
        id,
        amount,
        data,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides
    ): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.setApprovalForAll(
        operator,
        approved,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
  };

  encodeCall = {
    view: this.view,
    context: this.context,

    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.balanceOf(account, id, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.balanceOfBatch(accounts, ids, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.isApprovedForAll(account, operator, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.safeBatchTransferFrom(
        from,
        to,
        ids,
        amounts,
        data,
        {
          chainId: this.context.chainId.toString(),
          address: this.context.address,
          blockTag: blockTagWithOverride,
        }
      );
    },
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.safeTransferFrom(from, to, id, amount, data, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.setApprovalForAll(operator, approved, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.supportsInterface(interfaceId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    uri(id: BigNumberish, overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.uri(id, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
  };
}

export type ERC1155Context = ContractContext<ERC1155, ERC1155BoundContractView>;

export class ERC1155Processor extends BaseProcessor<
  ERC1155,
  ERC1155BoundContractView
> {
  onEventApprovalForAll(
    handler: (event: ApprovalForAllEvent, ctx: ERC1155Context) => void,
    filter?: ApprovalForAllEventFilter | ApprovalForAllEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: ApprovalForAllEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["ApprovalForAll(address,address,bool)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventTransferBatch(
    handler: (event: TransferBatchEvent, ctx: ERC1155Context) => void,
    filter?: TransferBatchEventFilter | TransferBatchEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: TransferBatchEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "TransferBatch(address,address,address,uint256[],uint256[])"
      ](null, null, null, null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventTransferSingle(
    handler: (event: TransferSingleEvent, ctx: ERC1155Context) => void,
    filter?: TransferSingleEventFilter | TransferSingleEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: TransferSingleEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "TransferSingle(address,address,address,uint256,uint256)"
      ](null, null, null, null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventURI(
    handler: (event: URIEvent, ctx: ERC1155Context) => void,
    filter?: URIEventFilter | URIEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: URIEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["URI(string,uint256)"](null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onCallBalanceOf(
    handler: (call: BalanceOfCallTrace, ctx: ERC1155Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: BalanceOfCallTrace,
      ctx: ERC1155Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x00fdd58e",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallBalanceOfBatch(
    handler: (call: BalanceOfBatchCallTrace, ctx: ERC1155Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: BalanceOfBatchCallTrace,
      ctx: ERC1155Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x4e1273f4",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallIsApprovedForAll(
    handler: (call: IsApprovedForAllCallTrace, ctx: ERC1155Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: IsApprovedForAllCallTrace,
      ctx: ERC1155Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xe985e9c5",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallSafeBatchTransferFrom(
    handler: (
      call: SafeBatchTransferFromCallTrace,
      ctx: ERC1155Context
    ) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: SafeBatchTransferFromCallTrace,
      ctx: ERC1155Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x2eb2c2d6",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallSafeTransferFrom(
    handler: (call: SafeTransferFromCallTrace, ctx: ERC1155Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: SafeTransferFromCallTrace,
      ctx: ERC1155Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xf242432a",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallSetApprovalForAll(
    handler: (call: SetApprovalForAllCallTrace, ctx: ERC1155Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: SetApprovalForAllCallTrace,
      ctx: ERC1155Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xa22cb465",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallSupportsInterface(
    handler: (call: SupportsInterfaceCallTrace, ctx: ERC1155Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: SupportsInterfaceCallTrace,
      ctx: ERC1155Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x01ffc9a7",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallUri(
    handler: (call: UriCallTrace, ctx: ERC1155Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: UriCallTrace,
      ctx: ERC1155Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x0e89341c",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  public static filters = {
    ApprovalForAll(
      account?: string | null,
      operator?: string | null,
      approved?: null
    ): ApprovalForAllEventFilter {
      return templateContract.filters["ApprovalForAll(address,address,bool)"](
        account,
        operator,
        approved
      );
    },
    TransferBatch(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter {
      return templateContract.filters[
        "TransferBatch(address,address,address,uint256[],uint256[])"
      ](operator, from, to, ids, values);
    },
    TransferSingle(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter {
      return templateContract.filters[
        "TransferSingle(address,address,address,uint256,uint256)"
      ](operator, from, to, id, value);
    },
    URI(value?: null, id?: BigNumberish | null): URIEventFilter {
      return templateContract.filters["URI(string,uint256)"](value, id);
    },
  };

  protected CreateBoundContractView(): ERC1155BoundContractView {
    const view = getERC1155Contract(this.config.network, this.config.address);
    return new ERC1155BoundContractView(this.config.address, view);
  }

  public static bind(options: BindOptions): ERC1155Processor {
    if (!options.name) {
      options.name = "ERC1155";
    }
    let processor = getProcessor(options) as ERC1155Processor;
    if (!processor) {
      processor = new ERC1155Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }
}

export class ERC1155ProcessorTemplate extends BaseProcessorTemplate<
  ERC1155,
  ERC1155BoundContractView
> {
  bindInternal(options: BindOptions) {
    if (!options.name) {
      options.name = "ERC1155";
    }
    let processor = getProcessor(options) as ERC1155Processor;
    if (!processor) {
      processor = new ERC1155Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }

  onEventApprovalForAll(
    handler: (event: ApprovalForAllEvent, ctx: ERC1155Context) => void,
    filter?: ApprovalForAllEventFilter | ApprovalForAllEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: ApprovalForAllEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["ApprovalForAll(address,address,bool)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventTransferBatch(
    handler: (event: TransferBatchEvent, ctx: ERC1155Context) => void,
    filter?: TransferBatchEventFilter | TransferBatchEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: TransferBatchEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "TransferBatch(address,address,address,uint256[],uint256[])"
      ](null, null, null, null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventTransferSingle(
    handler: (event: TransferSingleEvent, ctx: ERC1155Context) => void,
    filter?: TransferSingleEventFilter | TransferSingleEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: TransferSingleEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "TransferSingle(address,address,address,uint256,uint256)"
      ](null, null, null, null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventURI(
    handler: (event: URIEvent, ctx: ERC1155Context) => void,
    filter?: URIEventFilter | URIEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: URIEvent,
      ctx: ERC1155Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["URI(string,uint256)"](null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }
}

export function getERC1155Contract(
  chainId: EthChainId,
  address: string
): ERC1155ContractView {
  let contract = getContractByABI(
    "ERC1155",
    address,
    chainId
  ) as ERC1155ContractView;
  if (!contract) {
    const rawContract = ERC1155__factory.connect(address, getProvider(chainId));
    contract = new ERC1155ContractView(rawContract);
    addContractByABI("ERC1155", address, chainId, contract);
  }
  return contract;
}

export function getERC1155ContractOnContext(
  context: EthContext,
  address: string
): ERC1155BoundContractView {
  const view = getERC1155Contract(context.getChainId(), address);
  const boundView = new ERC1155BoundContractView(address, view);
  boundView.context = context;
  if (boundView.callStatic) {
    boundView.callStatic.context = context;
  }
  return boundView;
}
