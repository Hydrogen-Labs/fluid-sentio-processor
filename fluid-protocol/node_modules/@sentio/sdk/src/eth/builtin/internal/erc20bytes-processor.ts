/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { BigNumberish, Overrides, Interface } from "ethers";
import {
  addContractByABI,
  getContractByABI,
  addProcessor,
  getProcessor,
  getProvider,
  transformEtherError,
  BindOptions,
  BaseProcessor,
  BaseProcessorTemplate,
  BoundContractView,
  ContractContext,
  ContractView,
  DummyProvider,
  EthChainId,
  TypedCallTrace,
  EthContext,
  EthFetchConfig,
  PreprocessResult,
} from "@sentio/sdk/eth";
import { EthCallParam, EthCallContext, PreparedData } from "@sentio/protos";

import { ERC20Bytes__factory } from "./index.js";
import {
  ERC20Bytes,
  ApprovalEvent,
  ApprovalEventFilter,
  TransferEvent,
  TransferEventFilter,
} from "./ERC20Bytes.js";

export interface NameCallObject {}

export type NameCallTrace = TypedCallTrace<[], NameCallObject>;

export interface ApproveCallObject {
  spender: string;
  value: bigint;
}

export type ApproveCallTrace = TypedCallTrace<
  [string, bigint],
  ApproveCallObject
>;

export interface TotalSupplyCallObject {}

export type TotalSupplyCallTrace = TypedCallTrace<[], TotalSupplyCallObject>;

export interface TransferFromCallObject {
  from: string;
  to: string;
  value: bigint;
}

export type TransferFromCallTrace = TypedCallTrace<
  [string, string, bigint],
  TransferFromCallObject
>;

export interface DecimalsCallObject {}

export type DecimalsCallTrace = TypedCallTrace<[], DecimalsCallObject>;

export interface BalanceOfCallObject {
  who: string;
}

export type BalanceOfCallTrace = TypedCallTrace<[string], BalanceOfCallObject>;

export interface SymbolCallObject {}

export type SymbolCallTrace = TypedCallTrace<[], SymbolCallObject>;

export interface TransferCallObject {
  to: string;
  value: bigint;
}

export type TransferCallTrace = TypedCallTrace<
  [string, bigint],
  TransferCallObject
>;

export interface AllowanceCallObject {
  owner: string;
  spender: string;
}

export type AllowanceCallTrace = TypedCallTrace<
  [string, string],
  AllowanceCallObject
>;

const templateContract = ERC20Bytes__factory.connect("0x0", DummyProvider);

const iface = new Interface([
  "function name() view returns (bytes32)",
  "function approve(address spender, uint256 value) returns (bool)",
  "function totalSupply() view returns (uint256)",
  "function transferFrom(address from, address to, uint256 value) returns (bool)",
  "function decimals() view returns (uint8)",
  "function balanceOf(address who) view returns (uint256)",
  "function symbol() view returns (bytes32)",
  "function transfer(address to, uint256 value) returns (bool)",
  "function allowance(address owner, address spender) view returns (uint256)",
]);

export class ERC20BytesContractView extends ContractView<ERC20Bytes> {
  constructor(contract: ERC20Bytes) {
    super(contract);
    this.callStatic.contract = contract;
  }

  async name(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<string> {
    try {
      return await this.contract.getFunction("name()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async totalSupply(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("totalSupply()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async decimals(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("decimals()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async balanceOf(
    who: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("balanceOf(address)")(
        who,
        overrides || {}
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async symbol(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<string> {
    try {
      return await this.contract.getFunction("symbol()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async allowance(
    owner: string,
    spender: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("allowance(address,address)")(
        owner,
        spender,
        overrides || {}
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  callStatic = {
    contract: this.contract,

    async approve(
      spender: string,
      value: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("approve(address,uint256)")
          .staticCall(spender, value, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async transferFrom(
      from: string,
      to: string,
      value: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("transferFrom(address,address,uint256)")
          .staticCall(from, to, value, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async transfer(
      to: string,
      value: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("transfer(address,uint256)")
          .staticCall(to, value, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };

  encodeCall = {
    name(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function name()"]);
        const calldata = iface.encodeFunctionData("name", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    approve(
      spender: string,
      value: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function approve(address,uint256)"]);
        const calldata = iface.encodeFunctionData("approve", [spender, value]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    totalSupply(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function totalSupply()"]);
        const calldata = iface.encodeFunctionData("totalSupply", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    transferFrom(
      from: string,
      to: string,
      value: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function transferFrom(address,address,uint256)",
        ]);
        const calldata = iface.encodeFunctionData("transferFrom", [
          from,
          to,
          value,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    decimals(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function decimals()"]);
        const calldata = iface.encodeFunctionData("decimals", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    balanceOf(who: string, ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function balanceOf(address)"]);
        const calldata = iface.encodeFunctionData("balanceOf", [who]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    symbol(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function symbol()"]);
        const calldata = iface.encodeFunctionData("symbol", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    transfer(
      to: string,
      value: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function transfer(address,uint256)"]);
        const calldata = iface.encodeFunctionData("transfer", [to, value]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    allowance(
      owner: string,
      spender: string,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function allowance(address,address)"]);
        const calldata = iface.encodeFunctionData("allowance", [
          owner,
          spender,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };
}

export class ERC20BytesBoundContractView extends BoundContractView<
  ERC20Bytes,
  ERC20BytesContractView
> {
  async name(overrides?: Overrides): Promise<string> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.name(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async totalSupply(overrides?: Overrides): Promise<bigint> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.totalSupply(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async decimals(overrides?: Overrides): Promise<bigint> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.decimals(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async balanceOf(who: string, overrides?: Overrides): Promise<bigint> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.balanceOf(
      who,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async symbol(overrides?: Overrides): Promise<string> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.symbol(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async allowance(
    owner: string,
    spender: string,
    overrides?: Overrides
  ): Promise<bigint> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.allowance(
      owner,
      spender,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  callStatic = {
    view: this.view,
    context: this.context,

    async approve(
      spender: string,
      value: BigNumberish,
      overrides?: Overrides
    ): Promise<boolean> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.approve(
        spender,
        value,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async transferFrom(
      from: string,
      to: string,
      value: BigNumberish,
      overrides?: Overrides
    ): Promise<boolean> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.transferFrom(
        from,
        to,
        value,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async transfer(
      to: string,
      value: BigNumberish,
      overrides?: Overrides
    ): Promise<boolean> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.transfer(
        to,
        value,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
  };

  encodeCall = {
    view: this.view,
    context: this.context,

    name(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.name({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    approve(
      spender: string,
      value: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.approve(spender, value, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    totalSupply(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.totalSupply({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    transferFrom(
      from: string,
      to: string,
      value: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.transferFrom(from, to, value, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    decimals(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.decimals({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    balanceOf(who: string, overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.balanceOf(who, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    symbol(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.symbol({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    transfer(
      to: string,
      value: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.transfer(to, value, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    allowance(
      owner: string,
      spender: string,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.allowance(owner, spender, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
  };
}

export type ERC20BytesContext = ContractContext<
  ERC20Bytes,
  ERC20BytesBoundContractView
>;

export class ERC20BytesProcessor extends BaseProcessor<
  ERC20Bytes,
  ERC20BytesBoundContractView
> {
  onEventApproval(
    handler: (event: ApprovalEvent, ctx: ERC20BytesContext) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: ApprovalEvent,
      ctx: ERC20BytesContext,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: ERC20BytesContext) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: TransferEvent,
      ctx: ERC20BytesContext,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onCallName(
    handler: (call: NameCallTrace, ctx: ERC20BytesContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: NameCallTrace,
      ctx: ERC20BytesContext
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x06fdde03",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallApprove(
    handler: (call: ApproveCallTrace, ctx: ERC20BytesContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: ApproveCallTrace,
      ctx: ERC20BytesContext
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x095ea7b3",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallTotalSupply(
    handler: (call: TotalSupplyCallTrace, ctx: ERC20BytesContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: TotalSupplyCallTrace,
      ctx: ERC20BytesContext
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x18160ddd",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallTransferFrom(
    handler: (call: TransferFromCallTrace, ctx: ERC20BytesContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: TransferFromCallTrace,
      ctx: ERC20BytesContext
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x23b872dd",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallDecimals(
    handler: (call: DecimalsCallTrace, ctx: ERC20BytesContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: DecimalsCallTrace,
      ctx: ERC20BytesContext
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x313ce567",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallBalanceOf(
    handler: (call: BalanceOfCallTrace, ctx: ERC20BytesContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: BalanceOfCallTrace,
      ctx: ERC20BytesContext
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x70a08231",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallSymbol(
    handler: (call: SymbolCallTrace, ctx: ERC20BytesContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: SymbolCallTrace,
      ctx: ERC20BytesContext
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x95d89b41",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallTransfer(
    handler: (call: TransferCallTrace, ctx: ERC20BytesContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: TransferCallTrace,
      ctx: ERC20BytesContext
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xa9059cbb",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallAllowance(
    handler: (call: AllowanceCallTrace, ctx: ERC20BytesContext) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: AllowanceCallTrace,
      ctx: ERC20BytesContext
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xdd62ed3e",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  public static filters = {
    Approval(
      owner?: string | null,
      spender?: string | null,
      value?: null
    ): ApprovalEventFilter {
      return templateContract.filters["Approval(address,address,uint256)"](
        owner,
        spender,
        value
      );
    },
    Transfer(
      from?: string | null,
      to?: string | null,
      value?: null
    ): TransferEventFilter {
      return templateContract.filters["Transfer(address,address,uint256)"](
        from,
        to,
        value
      );
    },
  };

  protected CreateBoundContractView(): ERC20BytesBoundContractView {
    const view = getERC20BytesContract(
      this.config.network,
      this.config.address
    );
    return new ERC20BytesBoundContractView(this.config.address, view);
  }

  public static bind(options: BindOptions): ERC20BytesProcessor {
    if (!options.name) {
      options.name = "ERC20Bytes";
    }
    let processor = getProcessor(options) as ERC20BytesProcessor;
    if (!processor) {
      processor = new ERC20BytesProcessor(options);
      addProcessor(options, processor);
    }
    return processor;
  }
}

export class ERC20BytesProcessorTemplate extends BaseProcessorTemplate<
  ERC20Bytes,
  ERC20BytesBoundContractView
> {
  bindInternal(options: BindOptions) {
    if (!options.name) {
      options.name = "ERC20Bytes";
    }
    let processor = getProcessor(options) as ERC20BytesProcessor;
    if (!processor) {
      processor = new ERC20BytesProcessor(options);
      addProcessor(options, processor);
    }
    return processor;
  }

  onEventApproval(
    handler: (event: ApprovalEvent, ctx: ERC20BytesContext) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: ApprovalEvent,
      ctx: ERC20BytesContext,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: ERC20BytesContext) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: TransferEvent,
      ctx: ERC20BytesContext,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }
}

export function getERC20BytesContract(
  chainId: EthChainId,
  address: string
): ERC20BytesContractView {
  let contract = getContractByABI(
    "ERC20Bytes",
    address,
    chainId
  ) as ERC20BytesContractView;
  if (!contract) {
    const rawContract = ERC20Bytes__factory.connect(
      address,
      getProvider(chainId)
    );
    contract = new ERC20BytesContractView(rawContract);
    addContractByABI("ERC20Bytes", address, chainId, contract);
  }
  return contract;
}

export function getERC20BytesContractOnContext(
  context: EthContext,
  address: string
): ERC20BytesBoundContractView {
  const view = getERC20BytesContract(context.getChainId(), address);
  const boundView = new ERC20BytesBoundContractView(address, view);
  boundView.context = context;
  if (boundView.callStatic) {
    boundView.callStatic.context = context;
  }
  return boundView;
}
