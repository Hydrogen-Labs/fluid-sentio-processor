/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { BigNumberish, Overrides, BytesLike, Interface } from "ethers";
import {
  addContractByABI,
  getContractByABI,
  addProcessor,
  getProcessor,
  getProvider,
  transformEtherError,
  BindOptions,
  BaseProcessor,
  BaseProcessorTemplate,
  BoundContractView,
  ContractContext,
  ContractView,
  DummyProvider,
  EthChainId,
  TypedCallTrace,
  EthContext,
  EthFetchConfig,
  PreprocessResult,
} from "@sentio/sdk/eth";
import { EthCallParam, EthCallContext, PreparedData } from "@sentio/protos";

import { ERC721__factory } from "./index.js";
import {
  ERC721,
  ApprovalEvent,
  ApprovalEventFilter,
  ApprovalForAllEvent,
  ApprovalForAllEventFilter,
  TransferEvent,
  TransferEventFilter,
} from "./ERC721.js";

export interface ApproveCallObject {
  to: string;
  tokenId: bigint;
}

export type ApproveCallTrace = TypedCallTrace<
  [string, bigint],
  ApproveCallObject
>;

export interface TotalSupplyCallObject {}

export type TotalSupplyCallTrace = TypedCallTrace<[], TotalSupplyCallObject>;

export interface BalanceOfCallObject {
  owner: string;
}

export type BalanceOfCallTrace = TypedCallTrace<[string], BalanceOfCallObject>;

export interface GetApprovedCallObject {
  tokenId: bigint;
}

export type GetApprovedCallTrace = TypedCallTrace<
  [bigint],
  GetApprovedCallObject
>;

export interface IsApprovedForAllCallObject {
  owner: string;
  operator: string;
}

export type IsApprovedForAllCallTrace = TypedCallTrace<
  [string, string],
  IsApprovedForAllCallObject
>;

export interface NameCallObject {}

export type NameCallTrace = TypedCallTrace<[], NameCallObject>;

export interface OwnerOfCallObject {
  tokenId: bigint;
}

export type OwnerOfCallTrace = TypedCallTrace<[bigint], OwnerOfCallObject>;

export interface SafeTransferFrom_address_address_uint256CallObject {
  from: string;
  to: string;
  tokenId: bigint;
}

export type SafeTransferFrom_address_address_uint256CallTrace = TypedCallTrace<
  [string, string, bigint],
  SafeTransferFrom_address_address_uint256CallObject
>;

export interface SafeTransferFrom_address_address_uint256_bytesCallObject {
  from: string;
  to: string;
  tokenId: bigint;
  data: string;
}

export type SafeTransferFrom_address_address_uint256_bytesCallTrace =
  TypedCallTrace<
    [string, string, bigint, string],
    SafeTransferFrom_address_address_uint256_bytesCallObject
  >;

export interface SetApprovalForAllCallObject {
  operator: string;
  _approved: boolean;
}

export type SetApprovalForAllCallTrace = TypedCallTrace<
  [string, boolean],
  SetApprovalForAllCallObject
>;

export interface SupportsInterfaceCallObject {
  interfaceId: string;
}

export type SupportsInterfaceCallTrace = TypedCallTrace<
  [string],
  SupportsInterfaceCallObject
>;

export interface SymbolCallObject {}

export type SymbolCallTrace = TypedCallTrace<[], SymbolCallObject>;

export interface TokenURICallObject {
  tokenId: bigint;
}

export type TokenURICallTrace = TypedCallTrace<[bigint], TokenURICallObject>;

export interface TransferFromCallObject {
  from: string;
  to: string;
  tokenId: bigint;
}

export type TransferFromCallTrace = TypedCallTrace<
  [string, string, bigint],
  TransferFromCallObject
>;

const templateContract = ERC721__factory.connect("0x0", DummyProvider);

const iface = new Interface([
  "function approve(address to, uint256 tokenId) returns ()",
  "function totalSupply() view returns (uint256)",
  "function balanceOf(address owner) view returns (uint256 balance)",
  "function getApproved(uint256 tokenId) view returns (address operator)",
  "function isApprovedForAll(address owner, address operator) view returns (bool)",
  "function name() view returns (string)",
  "function ownerOf(uint256 tokenId) view returns (address owner)",
  "function safeTransferFrom(address from, address to, uint256 tokenId) returns ()",
  "function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns ()",
  "function setApprovalForAll(address operator, bool _approved) returns ()",
  "function supportsInterface(bytes4 interfaceId) view returns (bool)",
  "function symbol() view returns (string)",
  "function tokenURI(uint256 tokenId) view returns (string)",
  "function transferFrom(address from, address to, uint256 tokenId) returns ()",
]);

export class ERC721ContractView extends ContractView<ERC721> {
  constructor(contract: ERC721) {
    super(contract);
    this.callStatic.contract = contract;
  }

  async totalSupply(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("totalSupply()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async balanceOf(
    owner: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("balanceOf(address)")(
        owner,
        overrides || {}
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async getApproved(
    tokenId: BigNumberish,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<string> {
    try {
      return await this.contract.getFunction("getApproved(uint256)")(
        tokenId,
        overrides || {}
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async isApprovedForAll(
    owner: string,
    operator: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<boolean> {
    try {
      return await this.contract.getFunction(
        "isApprovedForAll(address,address)"
      )(owner, operator, overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async name(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<string> {
    try {
      return await this.contract.getFunction("name()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async ownerOf(
    tokenId: BigNumberish,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<string> {
    try {
      return await this.contract.getFunction("ownerOf(uint256)")(
        tokenId,
        overrides || {}
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async supportsInterface(
    interfaceId: BytesLike,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<boolean> {
    try {
      return await this.contract.getFunction("supportsInterface(bytes4)")(
        interfaceId,
        overrides || {}
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async symbol(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<string> {
    try {
      return await this.contract.getFunction("symbol()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async tokenURI(
    tokenId: BigNumberish,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<string> {
    try {
      return await this.contract.getFunction("tokenURI(uint256)")(
        tokenId,
        overrides || {}
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  callStatic = {
    contract: this.contract,

    async approve(
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("approve(address,uint256)")
          .staticCall(to, tokenId, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async safeTransferFrom_address_address_uint256(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("safeTransferFrom(address,address,uint256)")
          .staticCall(from, to, tokenId, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async safeTransferFrom_address_address_uint256_bytes(
      from: string,
      to: string,
      tokenId: BigNumberish,
      data: BytesLike,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("safeTransferFrom(address,address,uint256,bytes)")
          .staticCall(from, to, tokenId, data, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async setApprovalForAll(
      operator: string,
      _approved: boolean,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("setApprovalForAll(address,bool)")
          .staticCall(operator, _approved, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("transferFrom(address,address,uint256)")
          .staticCall(from, to, tokenId, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };

  encodeCall = {
    approve(
      to: string,
      tokenId: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function approve(address,uint256)"]);
        const calldata = iface.encodeFunctionData("approve", [to, tokenId]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    totalSupply(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function totalSupply()"]);
        const calldata = iface.encodeFunctionData("totalSupply", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    balanceOf(owner: string, ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function balanceOf(address)"]);
        const calldata = iface.encodeFunctionData("balanceOf", [owner]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    getApproved(
      tokenId: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function getApproved(uint256)"]);
        const calldata = iface.encodeFunctionData("getApproved", [tokenId]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    isApprovedForAll(
      owner: string,
      operator: string,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function isApprovedForAll(address,address)",
        ]);
        const calldata = iface.encodeFunctionData("isApprovedForAll", [
          owner,
          operator,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    name(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function name()"]);
        const calldata = iface.encodeFunctionData("name", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    ownerOf(
      tokenId: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function ownerOf(uint256)"]);
        const calldata = iface.encodeFunctionData("ownerOf", [tokenId]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    safeTransferFrom_address_address_uint256(
      from: string,
      to: string,
      tokenId: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function safeTransferFrom(address,address,uint256)",
        ]);
        const calldata = iface.encodeFunctionData("safeTransferFrom", [
          from,
          to,
          tokenId,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    safeTransferFrom_address_address_uint256_bytes(
      from: string,
      to: string,
      tokenId: BigNumberish,
      data: BytesLike,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function safeTransferFrom(address,address,uint256,bytes)",
        ]);
        const calldata = iface.encodeFunctionData("safeTransferFrom", [
          from,
          to,
          tokenId,
          data,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    setApprovalForAll(
      operator: string,
      _approved: boolean,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function setApprovalForAll(address,bool)",
        ]);
        const calldata = iface.encodeFunctionData("setApprovalForAll", [
          operator,
          _approved,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    supportsInterface(
      interfaceId: BytesLike,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function supportsInterface(bytes4)"]);
        const calldata = iface.encodeFunctionData("supportsInterface", [
          interfaceId,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    symbol(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function symbol()"]);
        const calldata = iface.encodeFunctionData("symbol", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    tokenURI(
      tokenId: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function tokenURI(uint256)"]);
        const calldata = iface.encodeFunctionData("tokenURI", [tokenId]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function transferFrom(address,address,uint256)",
        ]);
        const calldata = iface.encodeFunctionData("transferFrom", [
          from,
          to,
          tokenId,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };
}

export class ERC721BoundContractView extends BoundContractView<
  ERC721,
  ERC721ContractView
> {
  async totalSupply(overrides?: Overrides): Promise<bigint> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.totalSupply(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async balanceOf(owner: string, overrides?: Overrides): Promise<bigint> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.balanceOf(
      owner,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async getApproved(
    tokenId: BigNumberish,
    overrides?: Overrides
  ): Promise<string> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.getApproved(
      tokenId,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async isApprovedForAll(
    owner: string,
    operator: string,
    overrides?: Overrides
  ): Promise<boolean> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.isApprovedForAll(
      owner,
      operator,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async name(overrides?: Overrides): Promise<string> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.name(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async ownerOf(tokenId: BigNumberish, overrides?: Overrides): Promise<string> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.ownerOf(
      tokenId,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async supportsInterface(
    interfaceId: BytesLike,
    overrides?: Overrides
  ): Promise<boolean> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.supportsInterface(
      interfaceId,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async symbol(overrides?: Overrides): Promise<string> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.symbol(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async tokenURI(
    tokenId: BigNumberish,
    overrides?: Overrides
  ): Promise<string> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.tokenURI(
      tokenId,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  callStatic = {
    view: this.view,
    context: this.context,

    async approve(
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides
    ): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.approve(
        to,
        tokenId,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async safeTransferFrom_address_address_uint256(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides
    ): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.safeTransferFrom_address_address_uint256(
        from,
        to,
        tokenId,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async safeTransferFrom_address_address_uint256_bytes(
      from: string,
      to: string,
      tokenId: BigNumberish,
      data: BytesLike,
      overrides?: Overrides
    ): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.safeTransferFrom_address_address_uint256_bytes(
        from,
        to,
        tokenId,
        data,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async setApprovalForAll(
      operator: string,
      _approved: boolean,
      overrides?: Overrides
    ): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.setApprovalForAll(
        operator,
        _approved,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides
    ): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.transferFrom(
        from,
        to,
        tokenId,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
  };

  encodeCall = {
    view: this.view,
    context: this.context,

    approve(
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.approve(to, tokenId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    totalSupply(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.totalSupply({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    balanceOf(owner: string, overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.balanceOf(owner, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    getApproved(tokenId: BigNumberish, overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.getApproved(tokenId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    isApprovedForAll(
      owner: string,
      operator: string,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.isApprovedForAll(owner, operator, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    name(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.name({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    ownerOf(tokenId: BigNumberish, overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.ownerOf(tokenId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    safeTransferFrom_address_address_uint256(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.safeTransferFrom_address_address_uint256(
        from,
        to,
        tokenId,
        {
          chainId: this.context.chainId.toString(),
          address: this.context.address,
          blockTag: blockTagWithOverride,
        }
      );
    },
    safeTransferFrom_address_address_uint256_bytes(
      from: string,
      to: string,
      tokenId: BigNumberish,
      data: BytesLike,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.safeTransferFrom_address_address_uint256_bytes(
        from,
        to,
        tokenId,
        data,
        {
          chainId: this.context.chainId.toString(),
          address: this.context.address,
          blockTag: blockTagWithOverride,
        }
      );
    },
    setApprovalForAll(
      operator: string,
      _approved: boolean,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.setApprovalForAll(operator, _approved, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.supportsInterface(interfaceId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    symbol(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.symbol({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    tokenURI(tokenId: BigNumberish, overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.tokenURI(tokenId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.transferFrom(from, to, tokenId, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
  };
}

export type ERC721Context = ContractContext<ERC721, ERC721BoundContractView>;

export class ERC721Processor extends BaseProcessor<
  ERC721,
  ERC721BoundContractView
> {
  onEventApproval(
    handler: (event: ApprovalEvent, ctx: ERC721Context) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: ApprovalEvent,
      ctx: ERC721Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventApprovalForAll(
    handler: (event: ApprovalForAllEvent, ctx: ERC721Context) => void,
    filter?: ApprovalForAllEventFilter | ApprovalForAllEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: ApprovalForAllEvent,
      ctx: ERC721Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["ApprovalForAll(address,address,bool)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: ERC721Context) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: TransferEvent,
      ctx: ERC721Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onCallApprove(
    handler: (call: ApproveCallTrace, ctx: ERC721Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: ApproveCallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x095ea7b3",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallTotalSupply(
    handler: (call: TotalSupplyCallTrace, ctx: ERC721Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: TotalSupplyCallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x18160ddd",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallBalanceOf(
    handler: (call: BalanceOfCallTrace, ctx: ERC721Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: BalanceOfCallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x70a08231",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallGetApproved(
    handler: (call: GetApprovedCallTrace, ctx: ERC721Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: GetApprovedCallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x081812fc",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallIsApprovedForAll(
    handler: (call: IsApprovedForAllCallTrace, ctx: ERC721Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: IsApprovedForAllCallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xe985e9c5",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallName(
    handler: (call: NameCallTrace, ctx: ERC721Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: NameCallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x06fdde03",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallOwnerOf(
    handler: (call: OwnerOfCallTrace, ctx: ERC721Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: OwnerOfCallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x6352211e",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallSafeTransferFrom_address_address_uint256(
    handler: (
      call: SafeTransferFrom_address_address_uint256CallTrace,
      ctx: ERC721Context
    ) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: SafeTransferFrom_address_address_uint256CallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x42842e0e",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallSafeTransferFrom_address_address_uint256_bytes(
    handler: (
      call: SafeTransferFrom_address_address_uint256_bytesCallTrace,
      ctx: ERC721Context
    ) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: SafeTransferFrom_address_address_uint256_bytesCallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xb88d4fde",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallSetApprovalForAll(
    handler: (call: SetApprovalForAllCallTrace, ctx: ERC721Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: SetApprovalForAllCallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xa22cb465",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallSupportsInterface(
    handler: (call: SupportsInterfaceCallTrace, ctx: ERC721Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: SupportsInterfaceCallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x01ffc9a7",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallSymbol(
    handler: (call: SymbolCallTrace, ctx: ERC721Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: SymbolCallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x95d89b41",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallTokenURI(
    handler: (call: TokenURICallTrace, ctx: ERC721Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: TokenURICallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xc87b56dd",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallTransferFrom(
    handler: (call: TransferFromCallTrace, ctx: ERC721Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: TransferFromCallTrace,
      ctx: ERC721Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x23b872dd",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  public static filters = {
    Approval(
      owner?: string | null,
      approved?: string | null,
      tokenId?: BigNumberish | null
    ): ApprovalEventFilter {
      return templateContract.filters["Approval(address,address,uint256)"](
        owner,
        approved,
        tokenId
      );
    },
    ApprovalForAll(
      owner?: string | null,
      operator?: string | null,
      approved?: null
    ): ApprovalForAllEventFilter {
      return templateContract.filters["ApprovalForAll(address,address,bool)"](
        owner,
        operator,
        approved
      );
    },
    Transfer(
      from?: string | null,
      to?: string | null,
      tokenId?: BigNumberish | null
    ): TransferEventFilter {
      return templateContract.filters["Transfer(address,address,uint256)"](
        from,
        to,
        tokenId
      );
    },
  };

  protected CreateBoundContractView(): ERC721BoundContractView {
    const view = getERC721Contract(this.config.network, this.config.address);
    return new ERC721BoundContractView(this.config.address, view);
  }

  public static bind(options: BindOptions): ERC721Processor {
    if (!options.name) {
      options.name = "ERC721";
    }
    let processor = getProcessor(options) as ERC721Processor;
    if (!processor) {
      processor = new ERC721Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }
}

export class ERC721ProcessorTemplate extends BaseProcessorTemplate<
  ERC721,
  ERC721BoundContractView
> {
  bindInternal(options: BindOptions) {
    if (!options.name) {
      options.name = "ERC721";
    }
    let processor = getProcessor(options) as ERC721Processor;
    if (!processor) {
      processor = new ERC721Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }

  onEventApproval(
    handler: (event: ApprovalEvent, ctx: ERC721Context) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: ApprovalEvent,
      ctx: ERC721Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventApprovalForAll(
    handler: (event: ApprovalForAllEvent, ctx: ERC721Context) => void,
    filter?: ApprovalForAllEventFilter | ApprovalForAllEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: ApprovalForAllEvent,
      ctx: ERC721Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["ApprovalForAll(address,address,bool)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: ERC721Context) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: TransferEvent,
      ctx: ERC721Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }
}

export function getERC721Contract(
  chainId: EthChainId,
  address: string
): ERC721ContractView {
  let contract = getContractByABI(
    "ERC721",
    address,
    chainId
  ) as ERC721ContractView;
  if (!contract) {
    const rawContract = ERC721__factory.connect(address, getProvider(chainId));
    contract = new ERC721ContractView(rawContract);
    addContractByABI("ERC721", address, chainId, contract);
  }
  return contract;
}

export function getERC721ContractOnContext(
  context: EthContext,
  address: string
): ERC721BoundContractView {
  const view = getERC721Contract(context.getChainId(), address);
  const boundView = new ERC721BoundContractView(address, view);
  boundView.context = context;
  if (boundView.callStatic) {
    boundView.callStatic.context = context;
  }
  return boundView;
}
