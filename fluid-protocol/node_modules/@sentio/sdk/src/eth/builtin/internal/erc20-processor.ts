/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import { BigNumberish, Overrides, Interface } from "ethers";
import {
  addContractByABI,
  getContractByABI,
  addProcessor,
  getProcessor,
  getProvider,
  transformEtherError,
  BindOptions,
  BaseProcessor,
  BaseProcessorTemplate,
  BoundContractView,
  ContractContext,
  ContractView,
  DummyProvider,
  EthChainId,
  TypedCallTrace,
  EthContext,
  EthFetchConfig,
  PreprocessResult,
} from "@sentio/sdk/eth";
import { EthCallParam, EthCallContext, PreparedData } from "@sentio/protos";

import { ERC20__factory } from "./index.js";
import {
  ERC20,
  ApprovalEvent,
  ApprovalEventFilter,
  OwnershipTransferredEvent,
  OwnershipTransferredEventFilter,
  TransferEvent,
  TransferEventFilter,
} from "./ERC20.js";

export interface AllowanceCallObject {
  owner: string;
  spender: string;
}

export type AllowanceCallTrace = TypedCallTrace<
  [string, string],
  AllowanceCallObject
>;

export interface ApproveCallObject {
  spender: string;
  amount: bigint;
}

export type ApproveCallTrace = TypedCallTrace<
  [string, bigint],
  ApproveCallObject
>;

export interface BalanceOfCallObject {
  account: string;
}

export type BalanceOfCallTrace = TypedCallTrace<[string], BalanceOfCallObject>;

export interface BurnCallObject {
  amount: bigint;
}

export type BurnCallTrace = TypedCallTrace<[bigint], BurnCallObject>;

export interface BurnFromCallObject {
  account: string;
  amount: bigint;
}

export type BurnFromCallTrace = TypedCallTrace<
  [string, bigint],
  BurnFromCallObject
>;

export interface DecimalsCallObject {}

export type DecimalsCallTrace = TypedCallTrace<[], DecimalsCallObject>;

export interface DecreaseAllowanceCallObject {
  spender: string;
  subtractedValue: bigint;
}

export type DecreaseAllowanceCallTrace = TypedCallTrace<
  [string, bigint],
  DecreaseAllowanceCallObject
>;

export interface IncreaseAllowanceCallObject {
  spender: string;
  addedValue: bigint;
}

export type IncreaseAllowanceCallTrace = TypedCallTrace<
  [string, bigint],
  IncreaseAllowanceCallObject
>;

export interface LockerCallObject {}

export type LockerCallTrace = TypedCallTrace<[], LockerCallObject>;

export interface NameCallObject {}

export type NameCallTrace = TypedCallTrace<[], NameCallObject>;

export interface OwnerCallObject {}

export type OwnerCallTrace = TypedCallTrace<[], OwnerCallObject>;

export interface RenounceOwnershipCallObject {}

export type RenounceOwnershipCallTrace = TypedCallTrace<
  [],
  RenounceOwnershipCallObject
>;

export interface SetLockerCallObject {
  _locker: string;
}

export type SetLockerCallTrace = TypedCallTrace<[string], SetLockerCallObject>;

export interface SymbolCallObject {}

export type SymbolCallTrace = TypedCallTrace<[], SymbolCallObject>;

export interface TotalSupplyCallObject {}

export type TotalSupplyCallTrace = TypedCallTrace<[], TotalSupplyCallObject>;

export interface TransferCallObject {
  recipient: string;
  amount: bigint;
}

export type TransferCallTrace = TypedCallTrace<
  [string, bigint],
  TransferCallObject
>;

export interface TransferFromCallObject {
  sender: string;
  recipient: string;
  amount: bigint;
}

export type TransferFromCallTrace = TypedCallTrace<
  [string, string, bigint],
  TransferFromCallObject
>;

export interface TransferOwnershipCallObject {
  newOwner: string;
}

export type TransferOwnershipCallTrace = TypedCallTrace<
  [string],
  TransferOwnershipCallObject
>;

const templateContract = ERC20__factory.connect("0x0", DummyProvider);

const iface = new Interface([
  "function allowance(address owner, address spender) view returns (uint256)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "function balanceOf(address account) view returns (uint256)",
  "function burn(uint256 amount) returns ()",
  "function burnFrom(address account, uint256 amount) returns ()",
  "function decimals() view returns (uint8)",
  "function decreaseAllowance(address spender, uint256 subtractedValue) returns (bool)",
  "function increaseAllowance(address spender, uint256 addedValue) returns (bool)",
  "function locker() view returns (address)",
  "function name() view returns (string)",
  "function owner() view returns (address)",
  "function renounceOwnership() returns ()",
  "function setLocker(address _locker) returns ()",
  "function symbol() view returns (string)",
  "function totalSupply() view returns (uint256)",
  "function transfer(address recipient, uint256 amount) returns (bool)",
  "function transferFrom(address sender, address recipient, uint256 amount) returns (bool)",
  "function transferOwnership(address newOwner) returns ()",
]);

export class ERC20ContractView extends ContractView<ERC20> {
  constructor(contract: ERC20) {
    super(contract);
    this.callStatic.contract = contract;
  }

  async allowance(
    owner: string,
    spender: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("allowance(address,address)")(
        owner,
        spender,
        overrides || {}
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async balanceOf(
    account: string,
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("balanceOf(address)")(
        account,
        overrides || {}
      );
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async decimals(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("decimals()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async locker(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<string> {
    try {
      return await this.contract.getFunction("locker()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async name(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<string> {
    try {
      return await this.contract.getFunction("name()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async owner(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<string> {
    try {
      return await this.contract.getFunction("owner()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async symbol(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<string> {
    try {
      return await this.contract.getFunction("symbol()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  async totalSupply(
    overrides?: Overrides,
    preparedData?: PreparedData,
    ethCallContext?: EthCallContext
  ): Promise<bigint> {
    try {
      return await this.contract.getFunction("totalSupply()")(overrides || {});
    } catch (e) {
      const stack = new Error().stack;
      throw transformEtherError(e, undefined, stack);
    }
  }

  callStatic = {
    contract: this.contract,

    async approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("approve(address,uint256)")
          .staticCall(spender, amount, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async burn(
      amount: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("burn(uint256)")
          .staticCall(amount, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async burnFrom(
      account: string,
      amount: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("burnFrom(address,uint256)")
          .staticCall(account, amount, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("decreaseAllowance(address,uint256)")
          .staticCall(spender, subtractedValue, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("increaseAllowance(address,uint256)")
          .staticCall(spender, addedValue, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async renounceOwnership(
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("renounceOwnership()")
          .staticCall(overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async setLocker(
      _locker: string,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("setLocker(address)")
          .staticCall(_locker, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("transfer(address,uint256)")
          .staticCall(recipient, amount, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<boolean> {
      try {
        return await this.contract
          .getFunction("transferFrom(address,address,uint256)")
          .staticCall(sender, recipient, amount, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    async transferOwnership(
      newOwner: string,
      overrides?: Overrides,
      preparedData?: PreparedData,
      ethCallContext?: EthCallContext
    ): Promise<void> {
      try {
        return await this.contract
          .getFunction("transferOwnership(address)")
          .staticCall(newOwner, overrides || {});
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };

  encodeCall = {
    allowance(
      owner: string,
      spender: string,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function allowance(address,address)"]);
        const calldata = iface.encodeFunctionData("allowance", [
          owner,
          spender,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    approve(
      spender: string,
      amount: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function approve(address,uint256)"]);
        const calldata = iface.encodeFunctionData("approve", [spender, amount]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    balanceOf(account: string, ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function balanceOf(address)"]);
        const calldata = iface.encodeFunctionData("balanceOf", [account]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    burn(amount: BigNumberish, ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function burn(uint256)"]);
        const calldata = iface.encodeFunctionData("burn", [amount]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    burnFrom(
      account: string,
      amount: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function burnFrom(address,uint256)"]);
        const calldata = iface.encodeFunctionData("burnFrom", [
          account,
          amount,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    decimals(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function decimals()"]);
        const calldata = iface.encodeFunctionData("decimals", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function decreaseAllowance(address,uint256)",
        ]);
        const calldata = iface.encodeFunctionData("decreaseAllowance", [
          spender,
          subtractedValue,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function increaseAllowance(address,uint256)",
        ]);
        const calldata = iface.encodeFunctionData("increaseAllowance", [
          spender,
          addedValue,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    locker(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function locker()"]);
        const calldata = iface.encodeFunctionData("locker", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    name(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function name()"]);
        const calldata = iface.encodeFunctionData("name", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    owner(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function owner()"]);
        const calldata = iface.encodeFunctionData("owner", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    renounceOwnership(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function renounceOwnership()"]);
        const calldata = iface.encodeFunctionData("renounceOwnership", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    setLocker(_locker: string, ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function setLocker(address)"]);
        const calldata = iface.encodeFunctionData("setLocker", [_locker]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    symbol(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function symbol()"]);
        const calldata = iface.encodeFunctionData("symbol", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    totalSupply(ethCallContext: EthCallContext): EthCallParam {
      try {
        const iface = new Interface(["function totalSupply()"]);
        const calldata = iface.encodeFunctionData("totalSupply", []);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    transfer(
      recipient: string,
      amount: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function transfer(address,uint256)"]);
        const calldata = iface.encodeFunctionData("transfer", [
          recipient,
          amount,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface([
          "function transferFrom(address,address,uint256)",
        ]);
        const calldata = iface.encodeFunctionData("transferFrom", [
          sender,
          recipient,
          amount,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
    transferOwnership(
      newOwner: string,
      ethCallContext: EthCallContext
    ): EthCallParam {
      try {
        const iface = new Interface(["function transferOwnership(address)"]);
        const calldata = iface.encodeFunctionData("transferOwnership", [
          newOwner,
        ]);
        return {
          context: ethCallContext,
          calldata,
        };
      } catch (e) {
        const stack = new Error().stack;
        throw transformEtherError(e, undefined, stack);
      }
    },
  };
}

export class ERC20BoundContractView extends BoundContractView<
  ERC20,
  ERC20ContractView
> {
  async allowance(
    owner: string,
    spender: string,
    overrides?: Overrides
  ): Promise<bigint> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.allowance(
      owner,
      spender,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async balanceOf(account: string, overrides?: Overrides): Promise<bigint> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.balanceOf(
      account,
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async decimals(overrides?: Overrides): Promise<bigint> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.decimals(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async locker(overrides?: Overrides): Promise<string> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.locker(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async name(overrides?: Overrides): Promise<string> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.name(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async owner(overrides?: Overrides): Promise<string> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.owner(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async symbol(overrides?: Overrides): Promise<string> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.symbol(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  async totalSupply(overrides?: Overrides): Promise<bigint> {
    const ethCallContext = {
      chainId: this.context.chainId,
      blockTag: "0x" + this.context.blockNumber.toString(16),
      address: this.context.address,
    };
    return await this.view.totalSupply(
      {
        blockTag: this.context.blockNumber,
        ...overrides,
      },
      this.context.preparedData,
      ethCallContext
    );
  }

  callStatic = {
    view: this.view,
    context: this.context,

    async approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<boolean> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.approve(
        spender,
        amount,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async burn(amount: BigNumberish, overrides?: Overrides): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.burn(
        amount,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async burnFrom(
      account: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.burnFrom(
        account,
        amount,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides
    ): Promise<boolean> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.decreaseAllowance(
        spender,
        subtractedValue,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides
    ): Promise<boolean> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.increaseAllowance(
        spender,
        addedValue,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async renounceOwnership(overrides?: Overrides): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.renounceOwnership(
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async setLocker(_locker: string, overrides?: Overrides): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.setLocker(
        _locker,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<boolean> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.transfer(
        recipient,
        amount,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): Promise<boolean> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.transferFrom(
        sender,
        recipient,
        amount,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
    async transferOwnership(
      newOwner: string,
      overrides?: Overrides
    ): Promise<void> {
      const ethCallContext = {
        chainId: this.context.chainId,
        blockTag: "0x" + this.context.blockNumber.toString(16),
        address: this.context.address,
      };
      return await this.view.callStatic.transferOwnership(
        newOwner,
        {
          blockTag: this.context.blockNumber,
          ...overrides,
        },
        this.context.preparedData,
        ethCallContext
      );
    },
  };

  encodeCall = {
    view: this.view,
    context: this.context,

    allowance(
      owner: string,
      spender: string,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.allowance(owner, spender, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.approve(spender, amount, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    balanceOf(account: string, overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.balanceOf(account, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    burn(amount: BigNumberish, overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.burn(amount, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    burnFrom(
      account: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.burnFrom(account, amount, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    decimals(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.decimals({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.decreaseAllowance(spender, subtractedValue, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.increaseAllowance(spender, addedValue, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    locker(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.locker({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    name(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.name({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    owner(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.owner({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    renounceOwnership(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.renounceOwnership({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    setLocker(_locker: string, overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.setLocker(_locker, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    symbol(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.symbol({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    totalSupply(overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.totalSupply({
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.transfer(recipient, amount, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides
    ): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.transferFrom(sender, recipient, amount, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
    transferOwnership(newOwner: string, overrides?: Overrides): EthCallParam {
      let blockTagWithOverride = "0x" + this.context.blockNumber.toString(16);
      if (overrides?.blockTag) {
        blockTagWithOverride =
          typeof overrides.blockTag == "string"
            ? overrides.blockTag
            : "0x" + overrides.blockTag.toString(16);
      }

      return this.view.encodeCall.transferOwnership(newOwner, {
        chainId: this.context.chainId.toString(),
        address: this.context.address,
        blockTag: blockTagWithOverride,
      });
    },
  };
}

export type ERC20Context = ContractContext<ERC20, ERC20BoundContractView>;

export class ERC20Processor extends BaseProcessor<
  ERC20,
  ERC20BoundContractView
> {
  onEventApproval(
    handler: (event: ApprovalEvent, ctx: ERC20Context) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: ApprovalEvent,
      ctx: ERC20Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventOwnershipTransferred(
    handler: (event: OwnershipTransferredEvent, ctx: ERC20Context) => void,
    filter?:
      | OwnershipTransferredEventFilter
      | OwnershipTransferredEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: OwnershipTransferredEvent,
      ctx: ERC20Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "OwnershipTransferred(address,address)"
      ](null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: ERC20Context) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: TransferEvent,
      ctx: ERC20Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onCallAllowance(
    handler: (call: AllowanceCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: AllowanceCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xdd62ed3e",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallApprove(
    handler: (call: ApproveCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: ApproveCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x095ea7b3",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallBalanceOf(
    handler: (call: BalanceOfCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: BalanceOfCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x70a08231",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallBurn(
    handler: (call: BurnCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: BurnCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x42966c68",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallBurnFrom(
    handler: (call: BurnFromCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: BurnFromCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x79cc6790",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallDecimals(
    handler: (call: DecimalsCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: DecimalsCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x313ce567",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallDecreaseAllowance(
    handler: (call: DecreaseAllowanceCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: DecreaseAllowanceCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xa457c2d7",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallIncreaseAllowance(
    handler: (call: IncreaseAllowanceCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: IncreaseAllowanceCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x39509351",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallLocker(
    handler: (call: LockerCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: LockerCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xd7b96d4e",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallName(
    handler: (call: NameCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: NameCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x06fdde03",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallOwner(
    handler: (call: OwnerCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: OwnerCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x8da5cb5b",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallRenounceOwnership(
    handler: (call: RenounceOwnershipCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: RenounceOwnershipCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x715018a6",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallSetLocker(
    handler: (call: SetLockerCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: SetLockerCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x171060ec",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallSymbol(
    handler: (call: SymbolCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: SymbolCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x95d89b41",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallTotalSupply(
    handler: (call: TotalSupplyCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: TotalSupplyCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x18160ddd",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallTransfer(
    handler: (call: TransferCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: TransferCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xa9059cbb",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallTransferFrom(
    handler: (call: TransferFromCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: TransferFromCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0x23b872dd",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  onCallTransferOwnership(
    handler: (call: TransferOwnershipCallTrace, ctx: ERC20Context) => void,
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      call: TransferOwnershipCallTrace,
      ctx: ERC20Context
    ) => Promise<PreprocessResult>
  ): this {
    return super.onEthTrace(
      "0xf2fde38b",
      handler as any,
      fetchConfig,
      preprocessHandler
    );
  }

  public static filters = {
    Approval(
      owner?: string | null,
      spender?: string | null,
      value?: null
    ): ApprovalEventFilter {
      return templateContract.filters["Approval(address,address,uint256)"](
        owner,
        spender,
        value
      );
    },
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter {
      return templateContract.filters["OwnershipTransferred(address,address)"](
        previousOwner,
        newOwner
      );
    },
    Transfer(
      from?: string | null,
      to?: string | null,
      value?: null
    ): TransferEventFilter {
      return templateContract.filters["Transfer(address,address,uint256)"](
        from,
        to,
        value
      );
    },
  };

  protected CreateBoundContractView(): ERC20BoundContractView {
    const view = getERC20Contract(this.config.network, this.config.address);
    return new ERC20BoundContractView(this.config.address, view);
  }

  public static bind(options: BindOptions): ERC20Processor {
    if (!options.name) {
      options.name = "ERC20";
    }
    let processor = getProcessor(options) as ERC20Processor;
    if (!processor) {
      processor = new ERC20Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }
}

export class ERC20ProcessorTemplate extends BaseProcessorTemplate<
  ERC20,
  ERC20BoundContractView
> {
  bindInternal(options: BindOptions) {
    if (!options.name) {
      options.name = "ERC20";
    }
    let processor = getProcessor(options) as ERC20Processor;
    if (!processor) {
      processor = new ERC20Processor(options);
      addProcessor(options, processor);
    }
    return processor;
  }

  onEventApproval(
    handler: (event: ApprovalEvent, ctx: ERC20Context) => void,
    filter?: ApprovalEventFilter | ApprovalEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: ApprovalEvent,
      ctx: ERC20Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Approval(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventOwnershipTransferred(
    handler: (event: OwnershipTransferredEvent, ctx: ERC20Context) => void,
    filter?:
      | OwnershipTransferredEventFilter
      | OwnershipTransferredEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: OwnershipTransferredEvent,
      ctx: ERC20Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters[
        "OwnershipTransferred(address,address)"
      ](null, null);
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }

  onEventTransfer(
    handler: (event: TransferEvent, ctx: ERC20Context) => void,
    filter?: TransferEventFilter | TransferEventFilter[],
    fetchConfig?: Partial<EthFetchConfig>,
    preprocessHandler?: (
      event: TransferEvent,
      ctx: ERC20Context,
      preprocessStore: { [k: string]: any }
    ) => Promise<PreprocessResult>
  ): this {
    if (!filter) {
      filter = templateContract.filters["Transfer(address,address,uint256)"](
        null,
        null,
        null
      );
    }
    return super.onEthEvent(handler, filter!, fetchConfig, preprocessHandler);
  }
}

export function getERC20Contract(
  chainId: EthChainId,
  address: string
): ERC20ContractView {
  let contract = getContractByABI(
    "ERC20",
    address,
    chainId
  ) as ERC20ContractView;
  if (!contract) {
    const rawContract = ERC20__factory.connect(address, getProvider(chainId));
    contract = new ERC20ContractView(rawContract);
    addContractByABI("ERC20", address, chainId, contract);
  }
  return contract;
}

export function getERC20ContractOnContext(
  context: EthContext,
  address: string
): ERC20BoundContractView {
  const view = getERC20Contract(context.getChainId(), address);
  const boundView = new ERC20BoundContractView(address, view);
  boundView.context = context;
  if (boundView.callStatic) {
    boundView.callStatic.context = context;
  }
  return boundView;
}
