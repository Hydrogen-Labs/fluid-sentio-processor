/**
 * Sentio API
 * Sentio Open API for query data
 *
 * The version of the OpenAPI document: version not set
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import * as runtime from '../runtime.js';
import type { GoogleApiHttpBody, SolidityServiceGetSimulationBundleResponse, SolidityServiceGetSimulationResponse, SolidityServiceGetSimulationsResponse, SolidityServiceSimulateTransactionBundleRequest, SolidityServiceSimulateTransactionBundleResponse, SolidityServiceSimulateTransactionRequest, SolidityServiceSimulateTransactionResponse, TxindexEvmSearchTransactionsResponse } from '../models/index.js';
export interface GetCallTraceRequest {
    networkId: string;
    projectOwner?: string;
    projectSlug?: string;
    txIdTxHash?: string;
    txIdSimulationId?: string;
    txIdBundleId?: string;
    disableOptimizer?: boolean;
    withInternalCalls?: boolean;
    ignoreGasCost?: boolean;
}
export interface GetSimulationRequest {
    simulationId: string;
    projectOwner?: string;
    projectSlug?: string;
}
export interface GetSimulationBundleRequest {
    bundleId: string;
    projectOwner?: string;
    projectSlug?: string;
}
export interface GetSimulationsRequest {
    projectOwner?: string;
    projectSlug?: string;
    labelContains?: string;
    page?: number;
    pageSize?: number;
}
export interface SearchTransactionsRequest {
    chainId?: Array<string>;
    address?: Array<string>;
    includeDirect?: boolean;
    includeTrace?: boolean;
    includeIn?: boolean;
    includeOut?: boolean;
    startBlock?: string;
    endBlock?: string;
    startTimestamp?: string;
    endTimestamp?: string;
    transactionStatus?: Array<number>;
    methodSignature?: string;
    limit?: number;
    pageToken?: string;
}
export interface SimulateTransactionRequest {
    body: SolidityServiceSimulateTransactionRequest;
}
export interface SimulateTransactionBundleRequest {
    body: SolidityServiceSimulateTransactionBundleRequest;
}
/**
 *
 */
export declare class DebugAndSimulationApi extends runtime.BaseAPI {
    /**
     * API to get Sentio call trace. It takes `txId.txHash` and `networkId` arguments, where the first is transaction hash, and the second is the numeric ethereum chain ID.  The results looks very similar to the normal [Ethereum call trace](https://raw.githubusercontent.com/sentioxyz/docs/main/.gitbook/assets/image%20(2)%20(1)%20(1)%20(1).png). But we have an additional `startIndex` and `startIndex` on each trace entry even for the LOG, representing the execution order in the trace.  This allows you to build chart that marks the order of fund flow.  ![screenshot](https://raw.githubusercontent.com/sentioxyz/docs/main/.gitbook/assets/image%20(2)%20(1)%20(1)%20(1).png)
     * Get indexed call trace
     */
    getCallTraceRaw(requestParameters: GetCallTraceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GoogleApiHttpBody>>;
    /**
     * API to get Sentio call trace. It takes `txId.txHash` and `networkId` arguments, where the first is transaction hash, and the second is the numeric ethereum chain ID.  The results looks very similar to the normal [Ethereum call trace](https://raw.githubusercontent.com/sentioxyz/docs/main/.gitbook/assets/image%20(2)%20(1)%20(1)%20(1).png). But we have an additional `startIndex` and `startIndex` on each trace entry even for the LOG, representing the execution order in the trace.  This allows you to build chart that marks the order of fund flow.  ![screenshot](https://raw.githubusercontent.com/sentioxyz/docs/main/.gitbook/assets/image%20(2)%20(1)%20(1)%20(1).png)
     * Get indexed call trace
     */
    getCallTrace(requestParameters: GetCallTraceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GoogleApiHttpBody>;
    /**
     * Get a simulation by id
     */
    getSimulationRaw(requestParameters: GetSimulationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SolidityServiceGetSimulationResponse>>;
    /**
     * Get a simulation by id
     */
    getSimulation(requestParameters: GetSimulationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SolidityServiceGetSimulationResponse>;
    /**
     * Get a bundle simulation by id
     */
    getSimulationBundleRaw(requestParameters: GetSimulationBundleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SolidityServiceGetSimulationBundleResponse>>;
    /**
     * Get a bundle simulation by id
     */
    getSimulationBundle(requestParameters: GetSimulationBundleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SolidityServiceGetSimulationBundleResponse>;
    /**
     * Get existing transaction simulations
     */
    getSimulationsRaw(requestParameters: GetSimulationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SolidityServiceGetSimulationsResponse>>;
    /**
     * Get existing transaction simulations
     */
    getSimulations(requestParameters?: GetSimulationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SolidityServiceGetSimulationsResponse>;
    /**
     * Search for transactions
     */
    searchTransactionsRaw(requestParameters: SearchTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TxindexEvmSearchTransactionsResponse>>;
    /**
     * Search for transactions
     */
    searchTransactions(requestParameters?: SearchTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TxindexEvmSearchTransactionsResponse>;
    /**
     * Create a new transaction simulation. The simulation body should be included in the request body. Your simulations will be saved, and a unique ID for each simulation is included in the response. It will be useful for fetching simulation details.
     * Single simulation
     */
    simulateTransactionRaw(requestParameters: SimulateTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SolidityServiceSimulateTransactionResponse>>;
    /**
     * Create a new transaction simulation. The simulation body should be included in the request body. Your simulations will be saved, and a unique ID for each simulation is included in the response. It will be useful for fetching simulation details.
     * Single simulation
     */
    simulateTransaction(requestParameters: SimulateTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SolidityServiceSimulateTransactionResponse>;
    /**
     * You could also create bundle simulations so that one transaction could be executed one after another. For `blockNumber` `transactionIndex` `networkId` `stateOverrides` and `blockOverrides` fields, only the first simulation takes effect.
     * Bundle simulation
     */
    simulateTransactionBundleRaw(requestParameters: SimulateTransactionBundleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SolidityServiceSimulateTransactionBundleResponse>>;
    /**
     * You could also create bundle simulations so that one transaction could be executed one after another. For `blockNumber` `transactionIndex` `networkId` `stateOverrides` and `blockOverrides` fields, only the first simulation takes effect.
     * Bundle simulation
     */
    simulateTransactionBundle(requestParameters: SimulateTransactionBundleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SolidityServiceSimulateTransactionBundleResponse>;
}
