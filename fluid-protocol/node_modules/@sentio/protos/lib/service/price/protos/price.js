import _m0 from "protobufjs/minimal.js";
import { Empty } from "../../../google/protobuf/empty.js";
import { Timestamp } from "../../../google/protobuf/timestamp.js";
function createBaseCoinID() {
    return { symbol: undefined, address: undefined };
}
export const CoinID = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.symbol !== undefined) {
            writer.uint32(18).string(message.symbol);
        }
        if (message.address !== undefined) {
            CoinID_AddressIdentifier.encode(message.address, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoinID();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.symbol = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.address = CoinID_AddressIdentifier.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : undefined,
            address: isSet(object.address) ? CoinID_AddressIdentifier.fromJSON(object.address) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.symbol !== undefined) {
            obj.symbol = message.symbol;
        }
        if (message.address !== undefined) {
            obj.address = CoinID_AddressIdentifier.toJSON(message.address);
        }
        return obj;
    },
    create(base) {
        return CoinID.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCoinID();
        message.symbol = object.symbol ?? undefined;
        message.address = (object.address !== undefined && object.address !== null)
            ? CoinID_AddressIdentifier.fromPartial(object.address)
            : undefined;
        return message;
    },
};
function createBaseCoinID_AddressIdentifier() {
    return { address: "", chain: "" };
}
export const CoinID_AddressIdentifier = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.chain !== "") {
            writer.uint32(18).string(message.chain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoinID_AddressIdentifier();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.chain = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? globalThis.String(object.address) : "",
            chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.chain !== "") {
            obj.chain = message.chain;
        }
        return obj;
    },
    create(base) {
        return CoinID_AddressIdentifier.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCoinID_AddressIdentifier();
        message.address = object.address ?? "";
        message.chain = object.chain ?? "";
        return message;
    },
};
function createBaseGetPriceRequest() {
    return { timestamp: undefined, coinId: undefined, source: "" };
}
export const GetPriceRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.timestamp !== undefined) {
            Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).ldelim();
        }
        if (message.coinId !== undefined) {
            CoinID.encode(message.coinId, writer.uint32(18).fork()).ldelim();
        }
        if (message.source !== "") {
            writer.uint32(26).string(message.source);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPriceRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.coinId = CoinID.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.source = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
            coinId: isSet(object.coinId) ? CoinID.fromJSON(object.coinId) : undefined,
            source: isSet(object.source) ? globalThis.String(object.source) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.timestamp !== undefined) {
            obj.timestamp = message.timestamp.toISOString();
        }
        if (message.coinId !== undefined) {
            obj.coinId = CoinID.toJSON(message.coinId);
        }
        if (message.source !== "") {
            obj.source = message.source;
        }
        return obj;
    },
    create(base) {
        return GetPriceRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetPriceRequest();
        message.timestamp = object.timestamp ?? undefined;
        message.coinId = (object.coinId !== undefined && object.coinId !== null)
            ? CoinID.fromPartial(object.coinId)
            : undefined;
        message.source = object.source ?? "";
        return message;
    },
};
function createBaseGetPriceResponse() {
    return { price: 0, timestamp: undefined };
}
export const GetPriceResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.price !== 0) {
            writer.uint32(9).double(message.price);
        }
        if (message.timestamp !== undefined) {
            Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPriceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 9) {
                        break;
                    }
                    message.price = reader.double();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            price: isSet(object.price) ? globalThis.Number(object.price) : 0,
            timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.price !== 0) {
            obj.price = message.price;
        }
        if (message.timestamp !== undefined) {
            obj.timestamp = message.timestamp.toISOString();
        }
        return obj;
    },
    create(base) {
        return GetPriceResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetPriceResponse();
        message.price = object.price ?? 0;
        message.timestamp = object.timestamp ?? undefined;
        return message;
    },
};
function createBaseBatchGetPricesRequest() {
    return { timestamps: [], coinIds: [] };
}
export const BatchGetPricesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.timestamps) {
            Timestamp.encode(toTimestamp(v), writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.coinIds) {
            CoinID.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchGetPricesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.timestamps.push(fromTimestamp(Timestamp.decode(reader, reader.uint32())));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.coinIds.push(CoinID.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            timestamps: globalThis.Array.isArray(object?.timestamps)
                ? object.timestamps.map((e) => fromJsonTimestamp(e))
                : [],
            coinIds: globalThis.Array.isArray(object?.coinIds) ? object.coinIds.map((e) => CoinID.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.timestamps?.length) {
            obj.timestamps = message.timestamps.map((e) => e.toISOString());
        }
        if (message.coinIds?.length) {
            obj.coinIds = message.coinIds.map((e) => CoinID.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return BatchGetPricesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchGetPricesRequest();
        message.timestamps = object.timestamps?.map((e) => e) || [];
        message.coinIds = object.coinIds?.map((e) => CoinID.fromPartial(e)) || [];
        return message;
    },
};
function createBaseBatchGetPricesResponse() {
    return { prices: [] };
}
export const BatchGetPricesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.prices) {
            BatchGetPricesResponse_CoinPrice.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchGetPricesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.prices.push(BatchGetPricesResponse_CoinPrice.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            prices: globalThis.Array.isArray(object?.prices)
                ? object.prices.map((e) => BatchGetPricesResponse_CoinPrice.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.prices?.length) {
            obj.prices = message.prices.map((e) => BatchGetPricesResponse_CoinPrice.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return BatchGetPricesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchGetPricesResponse();
        message.prices = object.prices?.map((e) => BatchGetPricesResponse_CoinPrice.fromPartial(e)) || [];
        return message;
    },
};
function createBaseBatchGetPricesResponse_CoinPrice() {
    return { coinId: undefined, price: undefined, error: undefined };
}
export const BatchGetPricesResponse_CoinPrice = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.coinId !== undefined) {
            CoinID.encode(message.coinId, writer.uint32(10).fork()).ldelim();
        }
        if (message.price !== undefined) {
            BatchGetPricesResponse_CoinPrice_Price.encode(message.price, writer.uint32(18).fork()).ldelim();
        }
        if (message.error !== undefined) {
            writer.uint32(26).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchGetPricesResponse_CoinPrice();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.coinId = CoinID.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.price = BatchGetPricesResponse_CoinPrice_Price.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            coinId: isSet(object.coinId) ? CoinID.fromJSON(object.coinId) : undefined,
            price: isSet(object.price) ? BatchGetPricesResponse_CoinPrice_Price.fromJSON(object.price) : undefined,
            error: isSet(object.error) ? globalThis.String(object.error) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.coinId !== undefined) {
            obj.coinId = CoinID.toJSON(message.coinId);
        }
        if (message.price !== undefined) {
            obj.price = BatchGetPricesResponse_CoinPrice_Price.toJSON(message.price);
        }
        if (message.error !== undefined) {
            obj.error = message.error;
        }
        return obj;
    },
    create(base) {
        return BatchGetPricesResponse_CoinPrice.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchGetPricesResponse_CoinPrice();
        message.coinId = (object.coinId !== undefined && object.coinId !== null)
            ? CoinID.fromPartial(object.coinId)
            : undefined;
        message.price = (object.price !== undefined && object.price !== null)
            ? BatchGetPricesResponse_CoinPrice_Price.fromPartial(object.price)
            : undefined;
        message.error = object.error ?? undefined;
        return message;
    },
};
function createBaseBatchGetPricesResponse_CoinPrice_Price() {
    return { results: [] };
}
export const BatchGetPricesResponse_CoinPrice_Price = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.results) {
            GetPriceResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchGetPricesResponse_CoinPrice_Price();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(GetPriceResponse.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            results: globalThis.Array.isArray(object?.results)
                ? object.results.map((e) => GetPriceResponse.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.results?.length) {
            obj.results = message.results.map((e) => GetPriceResponse.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return BatchGetPricesResponse_CoinPrice_Price.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBatchGetPricesResponse_CoinPrice_Price();
        message.results = object.results?.map((e) => GetPriceResponse.fromPartial(e)) || [];
        return message;
    },
};
function createBaseListCoinsRequest() {
    return { limit: 0, offset: 0, searchQuery: "", chain: "" };
}
export const ListCoinsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.limit !== 0) {
            writer.uint32(8).int32(message.limit);
        }
        if (message.offset !== 0) {
            writer.uint32(16).int32(message.offset);
        }
        if (message.searchQuery !== "") {
            writer.uint32(26).string(message.searchQuery);
        }
        if (message.chain !== "") {
            writer.uint32(34).string(message.chain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListCoinsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.offset = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.searchQuery = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.chain = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
            offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
            searchQuery: isSet(object.searchQuery) ? globalThis.String(object.searchQuery) : "",
            chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.limit !== 0) {
            obj.limit = Math.round(message.limit);
        }
        if (message.offset !== 0) {
            obj.offset = Math.round(message.offset);
        }
        if (message.searchQuery !== "") {
            obj.searchQuery = message.searchQuery;
        }
        if (message.chain !== "") {
            obj.chain = message.chain;
        }
        return obj;
    },
    create(base) {
        return ListCoinsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListCoinsRequest();
        message.limit = object.limit ?? 0;
        message.offset = object.offset ?? 0;
        message.searchQuery = object.searchQuery ?? "";
        message.chain = object.chain ?? "";
        return message;
    },
};
function createBaseListCoinsResponse() {
    return { coins: [], coinAddressesInChain: {} };
}
export const ListCoinsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.coins) {
            CoinID.encode(v, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.coinAddressesInChain).forEach(([key, value]) => {
            ListCoinsResponse_CoinAddressesInChainEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListCoinsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.coins.push(CoinID.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = ListCoinsResponse_CoinAddressesInChainEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.coinAddressesInChain[entry2.key] = entry2.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            coins: globalThis.Array.isArray(object?.coins) ? object.coins.map((e) => CoinID.fromJSON(e)) : [],
            coinAddressesInChain: isObject(object.coinAddressesInChain)
                ? Object.entries(object.coinAddressesInChain).reduce((acc, [key, value]) => {
                    acc[key] = CoinID.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.coins?.length) {
            obj.coins = message.coins.map((e) => CoinID.toJSON(e));
        }
        if (message.coinAddressesInChain) {
            const entries = Object.entries(message.coinAddressesInChain);
            if (entries.length > 0) {
                obj.coinAddressesInChain = {};
                entries.forEach(([k, v]) => {
                    obj.coinAddressesInChain[k] = CoinID.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return ListCoinsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListCoinsResponse();
        message.coins = object.coins?.map((e) => CoinID.fromPartial(e)) || [];
        message.coinAddressesInChain = Object.entries(object.coinAddressesInChain ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = CoinID.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseListCoinsResponse_CoinAddressesInChainEntry() {
    return { key: "", value: undefined };
}
export const ListCoinsResponse_CoinAddressesInChainEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            CoinID.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListCoinsResponse_CoinAddressesInChainEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = CoinID.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? CoinID.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = CoinID.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return ListCoinsResponse_CoinAddressesInChainEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListCoinsResponse_CoinAddressesInChainEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? CoinID.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseCheckLatestPriceResponse() {
    return { prices: [], latestPrice: undefined };
}
export const CheckLatestPriceResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.prices) {
            CheckLatestPriceResponse_CoinPrice.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.latestPrice !== undefined) {
            CheckLatestPriceResponse_CoinPrice.encode(message.latestPrice, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckLatestPriceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.prices.push(CheckLatestPriceResponse_CoinPrice.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.latestPrice = CheckLatestPriceResponse_CoinPrice.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            prices: globalThis.Array.isArray(object?.prices)
                ? object.prices.map((e) => CheckLatestPriceResponse_CoinPrice.fromJSON(e))
                : [],
            latestPrice: isSet(object.latestPrice)
                ? CheckLatestPriceResponse_CoinPrice.fromJSON(object.latestPrice)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.prices?.length) {
            obj.prices = message.prices.map((e) => CheckLatestPriceResponse_CoinPrice.toJSON(e));
        }
        if (message.latestPrice !== undefined) {
            obj.latestPrice = CheckLatestPriceResponse_CoinPrice.toJSON(message.latestPrice);
        }
        return obj;
    },
    create(base) {
        return CheckLatestPriceResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCheckLatestPriceResponse();
        message.prices = object.prices?.map((e) => CheckLatestPriceResponse_CoinPrice.fromPartial(e)) || [];
        message.latestPrice = (object.latestPrice !== undefined && object.latestPrice !== null)
            ? CheckLatestPriceResponse_CoinPrice.fromPartial(object.latestPrice)
            : undefined;
        return message;
    },
};
function createBaseCheckLatestPriceResponse_CoinPrice() {
    return { coinId: undefined, price: 0, timestamp: undefined };
}
export const CheckLatestPriceResponse_CoinPrice = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.coinId !== undefined) {
            CoinID.encode(message.coinId, writer.uint32(10).fork()).ldelim();
        }
        if (message.price !== 0) {
            writer.uint32(17).double(message.price);
        }
        if (message.timestamp !== undefined) {
            Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckLatestPriceResponse_CoinPrice();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.coinId = CoinID.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 17) {
                        break;
                    }
                    message.price = reader.double();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            coinId: isSet(object.coinId) ? CoinID.fromJSON(object.coinId) : undefined,
            price: isSet(object.price) ? globalThis.Number(object.price) : 0,
            timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.coinId !== undefined) {
            obj.coinId = CoinID.toJSON(message.coinId);
        }
        if (message.price !== 0) {
            obj.price = message.price;
        }
        if (message.timestamp !== undefined) {
            obj.timestamp = message.timestamp.toISOString();
        }
        return obj;
    },
    create(base) {
        return CheckLatestPriceResponse_CoinPrice.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCheckLatestPriceResponse_CoinPrice();
        message.coinId = (object.coinId !== undefined && object.coinId !== null)
            ? CoinID.fromPartial(object.coinId)
            : undefined;
        message.price = object.price ?? 0;
        message.timestamp = object.timestamp ?? undefined;
        return message;
    },
};
function createBaseBackfillCoinRequest() {
    return {
        name: "",
        symbol: "",
        chain: "",
        address: "",
        coingeckoId: "",
        decimals: 0,
        logoUrl: "",
        projectUrl: "",
        accountAddress: "",
        moduleName: "",
        structName: "",
    };
}
export const BackfillCoinRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.symbol !== "") {
            writer.uint32(18).string(message.symbol);
        }
        if (message.chain !== "") {
            writer.uint32(26).string(message.chain);
        }
        if (message.address !== "") {
            writer.uint32(34).string(message.address);
        }
        if (message.coingeckoId !== "") {
            writer.uint32(42).string(message.coingeckoId);
        }
        if (message.decimals !== 0) {
            writer.uint32(48).uint32(message.decimals);
        }
        if (message.logoUrl !== "") {
            writer.uint32(58).string(message.logoUrl);
        }
        if (message.projectUrl !== "") {
            writer.uint32(66).string(message.projectUrl);
        }
        if (message.accountAddress !== "") {
            writer.uint32(74).string(message.accountAddress);
        }
        if (message.moduleName !== "") {
            writer.uint32(82).string(message.moduleName);
        }
        if (message.structName !== "") {
            writer.uint32(90).string(message.structName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBackfillCoinRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.symbol = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.chain = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.coingeckoId = reader.string();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.decimals = reader.uint32();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.logoUrl = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.projectUrl = reader.string();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.accountAddress = reader.string();
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.moduleName = reader.string();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.structName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
            chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
            address: isSet(object.address) ? globalThis.String(object.address) : "",
            coingeckoId: isSet(object.coingeckoId) ? globalThis.String(object.coingeckoId) : "",
            decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
            logoUrl: isSet(object.logoUrl) ? globalThis.String(object.logoUrl) : "",
            projectUrl: isSet(object.projectUrl) ? globalThis.String(object.projectUrl) : "",
            accountAddress: isSet(object.accountAddress) ? globalThis.String(object.accountAddress) : "",
            moduleName: isSet(object.moduleName) ? globalThis.String(object.moduleName) : "",
            structName: isSet(object.structName) ? globalThis.String(object.structName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.symbol !== "") {
            obj.symbol = message.symbol;
        }
        if (message.chain !== "") {
            obj.chain = message.chain;
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.coingeckoId !== "") {
            obj.coingeckoId = message.coingeckoId;
        }
        if (message.decimals !== 0) {
            obj.decimals = Math.round(message.decimals);
        }
        if (message.logoUrl !== "") {
            obj.logoUrl = message.logoUrl;
        }
        if (message.projectUrl !== "") {
            obj.projectUrl = message.projectUrl;
        }
        if (message.accountAddress !== "") {
            obj.accountAddress = message.accountAddress;
        }
        if (message.moduleName !== "") {
            obj.moduleName = message.moduleName;
        }
        if (message.structName !== "") {
            obj.structName = message.structName;
        }
        return obj;
    },
    create(base) {
        return BackfillCoinRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBackfillCoinRequest();
        message.name = object.name ?? "";
        message.symbol = object.symbol ?? "";
        message.chain = object.chain ?? "";
        message.address = object.address ?? "";
        message.coingeckoId = object.coingeckoId ?? "";
        message.decimals = object.decimals ?? 0;
        message.logoUrl = object.logoUrl ?? "";
        message.projectUrl = object.projectUrl ?? "";
        message.accountAddress = object.accountAddress ?? "";
        message.moduleName = object.moduleName ?? "";
        message.structName = object.structName ?? "";
        return message;
    },
};
function createBaseBackfillCoinResponse() {
    return { symbol: "", message: "" };
}
export const BackfillCoinResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.symbol !== "") {
            writer.uint32(10).string(message.symbol);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBackfillCoinResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.symbol = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
            message: isSet(object.message) ? globalThis.String(object.message) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.symbol !== "") {
            obj.symbol = message.symbol;
        }
        if (message.message !== "") {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return BackfillCoinResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBackfillCoinResponse();
        message.symbol = object.symbol ?? "";
        message.message = object.message ?? "";
        return message;
    },
};
export const PriceServiceDefinition = {
    name: "PriceService",
    fullName: "price_service.PriceService",
    methods: {
        getPrice: {
            name: "GetPrice",
            requestType: GetPriceRequest,
            requestStream: false,
            responseType: GetPriceResponse,
            responseStream: false,
            options: {
                _unknownFields: {
                    578365826: [new Uint8Array([16, 18, 14, 47, 97, 112, 105, 47, 118, 49, 47, 112, 114, 105, 99, 101, 115])],
                },
            },
        },
        batchGetPrices: {
            name: "BatchGetPrices",
            requestType: BatchGetPricesRequest,
            requestStream: false,
            responseType: BatchGetPricesResponse,
            responseStream: false,
            options: {
                _unknownFields: {
                    578365826: [
                        new Uint8Array([
                            22,
                            18,
                            20,
                            47,
                            97,
                            112,
                            105,
                            47,
                            118,
                            49,
                            47,
                            112,
                            114,
                            105,
                            99,
                            101,
                            115,
                            47,
                            98,
                            97,
                            116,
                            99,
                            104,
                        ]),
                    ],
                },
            },
        },
        listCoins: {
            name: "ListCoins",
            requestType: ListCoinsRequest,
            requestStream: false,
            responseType: ListCoinsResponse,
            responseStream: false,
            options: {
                _unknownFields: {
                    578365826: [
                        new Uint8Array([
                            22,
                            18,
                            20,
                            47,
                            97,
                            112,
                            105,
                            47,
                            118,
                            49,
                            47,
                            112,
                            114,
                            105,
                            99,
                            101,
                            115,
                            47,
                            99,
                            111,
                            105,
                            110,
                            115,
                        ]),
                    ],
                },
            },
        },
        checkLatestPrice: {
            name: "CheckLatestPrice",
            requestType: Empty,
            requestStream: false,
            responseType: CheckLatestPriceResponse,
            responseStream: false,
            options: {
                _unknownFields: {
                    578365826: [
                        new Uint8Array([
                            29,
                            18,
                            27,
                            47,
                            97,
                            112,
                            105,
                            47,
                            118,
                            49,
                            47,
                            112,
                            114,
                            105,
                            99,
                            101,
                            115,
                            47,
                            99,
                            104,
                            101,
                            99,
                            107,
                            95,
                            108,
                            97,
                            116,
                            101,
                            115,
                            116,
                        ]),
                    ],
                },
            },
        },
        backfillCoin: {
            name: "BackfillCoin",
            requestType: BackfillCoinRequest,
            requestStream: false,
            responseType: BackfillCoinResponse,
            responseStream: false,
            options: {
                _unknownFields: {
                    578365826: [
                        new Uint8Array([
                            28,
                            34,
                            23,
                            47,
                            97,
                            112,
                            105,
                            47,
                            118,
                            49,
                            47,
                            112,
                            114,
                            105,
                            99,
                            101,
                            115,
                            47,
                            98,
                            97,
                            99,
                            107,
                            102,
                            105,
                            108,
                            108,
                            58,
                            1,
                            42,
                        ]),
                    ],
                },
            },
        },
    },
};
function toTimestamp(date) {
    const seconds = BigInt(Math.trunc(date.getTime() / 1_000));
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (globalThis.Number(t.seconds.toString()) || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=price.js.map