"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prometheusClientMiddleware = prometheusClientMiddleware;
const abort_controller_x_1 = require("abort-controller-x");
const nice_grpc_common_1 = require("nice-grpc-common");
const prom_client_1 = require("prom-client");
const common_1 = require("./common");
const registry_1 = require("./registry");
const defaultClientStartedMetric = new prom_client_1.Counter({
    registers: [registry_1.registry],
    name: 'grpc_client_started_total',
    help: 'Total number of RPCs started on the client.',
    labelNames: common_1.labelNames,
});
const defaultClientHandledMetric = new prom_client_1.Counter({
    registers: [registry_1.registry],
    name: 'grpc_client_handled_total',
    help: 'Total number of RPCs completed on the client, regardless of success or failure.',
    labelNames: common_1.labelNamesWithCode,
});
const defaultClientStreamMsgReceivedMetric = new prom_client_1.Counter({
    registers: [registry_1.registry],
    name: 'grpc_client_msg_received_total',
    help: 'Total number of RPC stream messages received by the client.',
    labelNames: common_1.labelNames,
});
const defaultClientStreamMsgSentMetric = new prom_client_1.Counter({
    registers: [registry_1.registry],
    name: 'grpc_client_msg_sent_total',
    help: 'Total number of gRPC stream messages sent by the client.',
    labelNames: common_1.labelNames,
});
const defaultClientHandlingSecondsMetric = new prom_client_1.Histogram({
    registers: [registry_1.registry],
    name: 'grpc_client_handling_seconds',
    help: 'Histogram of response latency (seconds) of the gRPC until it is finished by the application.',
    labelNames: common_1.labelNamesWithCode,
    buckets: common_1.latencySecondsBuckets,
});
function prometheusClientMiddleware(options) {
    const clientStartedMetric = options?.clientStartedMetric || defaultClientStartedMetric;
    const clientHandledMetric = options?.clientHandledMetric || defaultClientHandledMetric;
    const clientStreamMsgReceivedMetric = options?.clientStreamMsgReceivedMetric ||
        defaultClientStreamMsgReceivedMetric;
    const clientStreamMsgSentMetric = options?.clientStreamMsgSentMetric || defaultClientStreamMsgSentMetric;
    const clientHandlingSecondsMetric = options?.clientHandlingSecondsMetric || defaultClientHandlingSecondsMetric;
    return async function* prometheusClientMiddlewareGenerator(call, options) {
        const labels = (0, common_1.getLabels)(call.method);
        clientStartedMetric.inc(labels);
        const stopTimer = clientHandlingSecondsMetric.startTimer(labels);
        let settled = false;
        let status = nice_grpc_common_1.Status.OK;
        try {
            let request;
            if (!call.requestStream) {
                request = call.request;
            }
            else {
                request = (0, common_1.incrementStreamMessagesCounter)(call.request, clientStreamMsgSentMetric.labels(labels));
            }
            if (!call.responseStream) {
                const response = yield* call.next(request, options);
                settled = true;
                return response;
            }
            else {
                yield* (0, common_1.incrementStreamMessagesCounter)(call.next(request, options), clientStreamMsgReceivedMetric.labels(labels));
                settled = true;
                return;
            }
        }
        catch (err) {
            settled = true;
            if (err instanceof nice_grpc_common_1.ClientError) {
                status = err.code;
            }
            else if ((0, abort_controller_x_1.isAbortError)(err)) {
                status = nice_grpc_common_1.Status.CANCELLED;
            }
            else {
                status = nice_grpc_common_1.Status.UNKNOWN;
            }
            throw err;
        }
        finally {
            if (!settled) {
                status = nice_grpc_common_1.Status.CANCELLED;
            }
            stopTimer({ [common_1.codeLabel]: nice_grpc_common_1.Status[status] });
            clientHandledMetric.inc({
                ...labels,
                [common_1.codeLabel]: nice_grpc_common_1.Status[status],
            });
        }
    };
}
//# sourceMappingURL=client.js.map