var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/cli/utils/logger.ts
import chalk from "chalk";
var loggingConfig = {
  isDebugEnabled: false,
  isLoggingEnabled: true
};
function configureLogging(params) {
  loggingConfig.isLoggingEnabled = params.isLoggingEnabled;
  loggingConfig.isDebugEnabled = params.isDebugEnabled && loggingConfig.isLoggingEnabled;
}
function log(...data) {
  if (loggingConfig.isLoggingEnabled) {
    console.log(data.join(" "));
  }
}
function debug(...data) {
  if (loggingConfig.isDebugEnabled) {
    log(data);
  }
}
function error(...data) {
  console.log(chalk.red(data.join(" ")));
}
function warn(...data) {
  log(chalk.yellow(data.join(" ")));
}

// src/cli.ts
import { configureCliOptions as configureTypegenCliOptions } from "@fuel-ts/abi-typegen/cli";
import { versions } from "@fuel-ts/versions";
import { runVersions } from "@fuel-ts/versions/cli";
import { Command, Option } from "commander";

// src/cli/commands/build/generateTypes.ts
import { ProgramTypeEnum } from "@fuel-ts/abi-typegen";
import { runTypegen } from "@fuel-ts/abi-typegen/runTypegen";
import { getBinaryVersions } from "@fuel-ts/versions/cli";
import { writeFileSync as writeFileSync2, mkdirSync } from "fs";
import { globSync } from "glob";
import { join as join2 } from "path";

// src/cli/config/forcUtils.ts
import { FuelError } from "@fuel-ts/errors";
import { readFileSync, existsSync, writeFileSync } from "fs";
import camelCase from "lodash.camelcase";
import { join } from "path";
import toml from "toml";
var SwayType = /* @__PURE__ */ ((SwayType2) => {
  SwayType2["contract"] = "contract";
  SwayType2["script"] = "script";
  SwayType2["predicate"] = "predicate";
  SwayType2["library"] = "library";
  return SwayType2;
})(SwayType || {});
var swayFiles = /* @__PURE__ */ new Map();
var getClosestForcTomlDir = (dir) => {
  let forcPath = join(dir, "Forc.toml");
  if (existsSync(forcPath)) {
    return forcPath;
  }
  const parent = join(dir, "..");
  forcPath = getClosestForcTomlDir(parent);
  if (parent === "/" && !existsSync(forcPath)) {
    const msg = `TOML file not found:
  ${dir}`;
    throw new FuelError(FuelError.CODES.CONFIG_FILE_NOT_FOUND, msg);
  }
  return forcPath;
};
function readForcToml(contractPath) {
  if (!existsSync(contractPath)) {
    throw new FuelError(
      FuelError.CODES.CONFIG_FILE_NOT_FOUND,
      `TOML file not found:
  ${contractPath}`
    );
  }
  const forcPath = getClosestForcTomlDir(contractPath);
  if (!existsSync(forcPath)) {
    throw new FuelError(
      FuelError.CODES.CONFIG_FILE_NOT_FOUND,
      `TOML file not found:
  ${forcPath}`
    );
  }
  const forcFile = readFileSync(forcPath, "utf8");
  return toml.parse(forcFile);
}
function setForcTomlProxyAddress(contractPath, address) {
  const forcPath = getClosestForcTomlDir(contractPath);
  const tomlPristine = readFileSync(forcPath).toString();
  const tomlJson = readForcToml(forcPath);
  const isProxyEnabled = tomlJson.proxy?.enabled;
  const hasProxyAddress = tomlJson.proxy?.address;
  if (isProxyEnabled && hasProxyAddress) {
    return address;
  }
  const replaceReg = /(\[proxy\][\s\S]+^enabled.+$)/gm;
  const replaceStr = `$1
address = "${address}"`;
  const modifiedToml = tomlPristine.replace(replaceReg, replaceStr);
  writeFileSync(forcPath, modifiedToml);
  return address;
}
function readSwayType(path) {
  const forcToml = readForcToml(path);
  const entryFile = forcToml.project.entry || "main.sw";
  const swayEntryPath = join(path, "src", entryFile);
  if (!swayFiles.has(swayEntryPath)) {
    const swayFile = readFileSync(swayEntryPath, "utf8");
    const swayTypeLines = Object.values(SwayType).map((type) => `${type};`);
    const swayType = swayFile.split("\n").find((line) => swayTypeLines.some((swayTypeLine) => line === swayTypeLine))?.split(";")[0];
    swayFiles.set(swayEntryPath, swayType);
  }
  return swayFiles.get(swayEntryPath);
}
function getContractName(contractPath) {
  const { project } = readForcToml(contractPath);
  return project.name;
}
function getScriptName(scriptPath) {
  const { project } = readForcToml(scriptPath);
  return project.name;
}
function getPredicateName(predicatePath) {
  const { project } = readForcToml(predicatePath);
  return project.name;
}
function getContractCamelCase(contractPath) {
  const projectName = getContractName(contractPath);
  return camelCase(projectName);
}
function getBinaryPath(contractPath, { buildMode }) {
  const projectName = getContractName(contractPath);
  return join(contractPath, `/out/${buildMode}/${projectName}.bin`);
}
function getABIPath(contractPath, { buildMode }) {
  const projectName = getContractName(contractPath);
  return join(contractPath, `/out/${buildMode}/${projectName}-abi.json`);
}
function getABIPaths(paths, config) {
  return Promise.all(paths.map((path) => getABIPath(path, config)));
}
var getStorageSlotsPath = (contractPath, { buildMode }) => {
  const projectName = getContractName(contractPath);
  return join(contractPath, `/out/${buildMode}/${projectName}-storage_slots.json`);
};

// src/cli/templates/index.ts
import Handlebars from "handlebars";

// src/cli/templates/index.hbs
var templates_default = "{{#each paths}}\nexport * from './{{this}}';\n{{/each}}\n";

// src/cli/templates/index.ts
function renderIndexTemplate(paths) {
  const renderTemplate = Handlebars.compile(templates_default, {
    strict: true,
    noEscape: true
  });
  return renderTemplate({
    paths
  });
}

// src/cli/commands/build/generateTypes.ts
async function generateTypesForProgramType(config, paths, programType) {
  debug("Generating types..");
  let filepaths = await getABIPaths(paths, config);
  const pluralizedDirName = `${String(programType).toLocaleLowerCase()}s`;
  const versions3 = getBinaryVersions(config);
  const isScript = programType === ProgramTypeEnum.SCRIPT;
  const isPredicate = programType === ProgramTypeEnum.PREDICATE;
  if (isScript || isPredicate) {
    const loaderFiles = paths.flatMap((dirpath) => {
      const glob = `*-abi.json`;
      const cwd = `${dirpath}/out`;
      return globSync(glob, { cwd }).map((filename) => `${dirpath}/out/${filename}`);
    });
    filepaths = filepaths.concat(loaderFiles);
  }
  runTypegen({
    programType,
    cwd: config.basePath,
    filepaths,
    output: join2(config.output, pluralizedDirName),
    silent: !loggingConfig.isDebugEnabled,
    versions: versions3
  });
  return pluralizedDirName;
}
async function generateTypes(config) {
  log("Generating types..");
  const { contracts, scripts, predicates, output } = config;
  mkdirSync(output, { recursive: true });
  const members = [
    { type: ProgramTypeEnum.CONTRACT, programs: contracts },
    { type: ProgramTypeEnum.SCRIPT, programs: scripts },
    { type: ProgramTypeEnum.PREDICATE, programs: predicates }
  ];
  const pluralizedDirNames = await Promise.all(
    members.filter(({ programs }) => !!programs.length).map(({ programs, type }) => generateTypesForProgramType(config, programs, type))
  );
  const indexFile = await renderIndexTemplate(pluralizedDirNames);
  writeFileSync2(join2(config.output, "index.ts"), indexFile);
}

// src/cli/commands/deploy/deployContracts.ts
import { ContractFactory as ContractFactory2 } from "@fuel-ts/contract";
import { Contract as Contract3 } from "@fuel-ts/program";
import { existsSync as existsSync2, readFileSync as readFileSync2 } from "fs";

// src/cli/commands/deploy/createWallet.ts
import { Wallet, Provider } from "@fuel-ts/account";
import { FuelError as FuelError2 } from "@fuel-ts/errors";
async function createWallet(providerUrl, privateKey) {
  let pvtKey;
  if (privateKey) {
    pvtKey = privateKey;
  } else if (process.env.PRIVATE_KEY) {
    pvtKey = process.env.PRIVATE_KEY;
  } else {
    throw new FuelError2(
      FuelError2.CODES.MISSING_REQUIRED_PARAMETER,
      "You must provide a privateKey via config.privateKey or env PRIVATE_KEY"
    );
  }
  try {
    const provider = await Provider.create(providerUrl);
    return Wallet.fromPrivateKey(pvtKey, provider);
  } catch (e) {
    const error2 = e;
    if (/EADDRNOTAVAIL|ECONNREFUSED/.test(error2.cause?.code ?? "")) {
      throw new FuelError2(
        FuelError2.CODES.CONNECTION_REFUSED,
        `Couldn't connect to the node at "${providerUrl}". Check that you've got a node running at the config's providerUrl or set autoStartFuelCore to true.`
      );
    } else {
      throw error2;
    }
  }
}

// src/cli/commands/deploy/getDeployConfig.ts
async function getDeployConfig(deployConfig, options) {
  let config;
  if (typeof deployConfig === "function") {
    config = await deployConfig(options);
  } else {
    config = deployConfig;
  }
  return config;
}

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Commands: () => Commands,
  Script: () => Script,
  createConfig: () => createConfig
});
import { Script } from "@fuel-ts/script";

// src/cli/utils/createConfig.ts
function createConfig(config) {
  return config;
}

// src/cli/types.ts
var Commands = /* @__PURE__ */ ((Commands2) => {
  Commands2["build"] = "build";
  Commands2["deploy"] = "deploy";
  Commands2["dev"] = "dev";
  Commands2["init"] = "init";
  Commands2["versions"] = "versions";
  Commands2["node"] = "node";
  return Commands2;
})(Commands || {});

// src/index.ts
__reExport(src_exports, abi_coder_star);
__reExport(src_exports, address_star);
__reExport(src_exports, configs_star);
__reExport(src_exports, contract_star);
__reExport(src_exports, crypto_star);
__reExport(src_exports, errors_star);
__reExport(src_exports, hasher_star);
__reExport(src_exports, interfaces_star);
__reExport(src_exports, math_star);
__reExport(src_exports, configs_star2);
__reExport(src_exports, program_star);
__reExport(src_exports, transactions_star);
__reExport(src_exports, utils_star);
__reExport(src_exports, account_star);
__reExport(src_exports, configs_star3);
__reExport(src_exports, configs_star4);
import * as abi_coder_star from "@fuel-ts/abi-coder";
import * as address_star from "@fuel-ts/address";
import * as configs_star from "@fuel-ts/address/configs";
import * as contract_star from "@fuel-ts/contract";
import * as crypto_star from "@fuel-ts/crypto";
import * as errors_star from "@fuel-ts/errors";
import * as hasher_star from "@fuel-ts/hasher";
import * as interfaces_star from "@fuel-ts/interfaces";
import * as math_star from "@fuel-ts/math";
import * as configs_star2 from "@fuel-ts/math/configs";
import * as program_star from "@fuel-ts/program";
import * as transactions_star from "@fuel-ts/transactions";
import * as utils_star from "@fuel-ts/utils";
import * as account_star from "@fuel-ts/account";
import * as configs_star3 from "@fuel-ts/transactions/configs";
import * as configs_star4 from "@fuel-ts/account/configs";

// src/cli/commands/deploy/proxy/types/Src14OwnedProxy.ts
var abi = {
  "programType": "contract",
  "specVersion": "1",
  "encodingVersion": "1",
  "concreteTypes": [
    {
      "type": "()",
      "concreteTypeId": "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
    },
    {
      "type": "enum standards::src5::AccessError",
      "concreteTypeId": "3f702ea3351c9c1ece2b84048006c8034a24cbc2bad2e740d0412b4172951d3d",
      "metadataTypeId": 1
    },
    {
      "type": "enum standards::src5::State",
      "concreteTypeId": "192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c",
      "metadataTypeId": 2
    },
    {
      "type": "enum std::option::Option<struct std::contract_id::ContractId>",
      "concreteTypeId": "0d79387ad3bacdc3b7aad9da3a96f4ce60d9a1b6002df254069ad95a3931d5c8",
      "metadataTypeId": 4,
      "typeArguments": [
        "29c10735d33b5159f0c71ee1dbd17b36a3e69e41f00fab0d42e1bd9f428d8a54"
      ]
    },
    {
      "type": "enum sway_libs::ownership::errors::InitializationError",
      "concreteTypeId": "1dfe7feadc1d9667a4351761230f948744068a090fe91b1bc6763a90ed5d3893",
      "metadataTypeId": 5
    },
    {
      "type": "enum sway_libs::upgradability::errors::SetProxyOwnerError",
      "concreteTypeId": "3c6e90ae504df6aad8b34a93ba77dc62623e00b777eecacfa034a8ac6e890c74",
      "metadataTypeId": 6
    },
    {
      "type": "str",
      "concreteTypeId": "8c25cb3686462e9a86d2883c5688a22fe738b0bbc85f458d2d2b5f3f667c6d5a"
    },
    {
      "type": "struct std::contract_id::ContractId",
      "concreteTypeId": "29c10735d33b5159f0c71ee1dbd17b36a3e69e41f00fab0d42e1bd9f428d8a54",
      "metadataTypeId": 9
    },
    {
      "type": "struct sway_libs::upgradability::events::ProxyOwnerSet",
      "concreteTypeId": "96dd838b44f99d8ccae2a7948137ab6256c48ca4abc6168abc880de07fba7247",
      "metadataTypeId": 10
    },
    {
      "type": "struct sway_libs::upgradability::events::ProxyTargetSet",
      "concreteTypeId": "1ddc0adda1270a016c08ffd614f29f599b4725407c8954c8b960bdf651a9a6c8",
      "metadataTypeId": 11
    }
  ],
  "metadataTypes": [
    {
      "type": "b256",
      "metadataTypeId": 0
    },
    {
      "type": "enum standards::src5::AccessError",
      "metadataTypeId": 1,
      "components": [
        {
          "name": "NotOwner",
          "typeId": "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
        }
      ]
    },
    {
      "type": "enum standards::src5::State",
      "metadataTypeId": 2,
      "components": [
        {
          "name": "Uninitialized",
          "typeId": "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
        },
        {
          "name": "Initialized",
          "typeId": 3
        },
        {
          "name": "Revoked",
          "typeId": "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
        }
      ]
    },
    {
      "type": "enum std::identity::Identity",
      "metadataTypeId": 3,
      "components": [
        {
          "name": "Address",
          "typeId": 8
        },
        {
          "name": "ContractId",
          "typeId": 9
        }
      ]
    },
    {
      "type": "enum std::option::Option",
      "metadataTypeId": 4,
      "components": [
        {
          "name": "None",
          "typeId": "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
        },
        {
          "name": "Some",
          "typeId": 7
        }
      ],
      "typeParameters": [
        7
      ]
    },
    {
      "type": "enum sway_libs::ownership::errors::InitializationError",
      "metadataTypeId": 5,
      "components": [
        {
          "name": "CannotReinitialized",
          "typeId": "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
        }
      ]
    },
    {
      "type": "enum sway_libs::upgradability::errors::SetProxyOwnerError",
      "metadataTypeId": 6,
      "components": [
        {
          "name": "CannotUninitialize",
          "typeId": "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
        }
      ]
    },
    {
      "type": "generic T",
      "metadataTypeId": 7
    },
    {
      "type": "struct std::address::Address",
      "metadataTypeId": 8,
      "components": [
        {
          "name": "bits",
          "typeId": 0
        }
      ]
    },
    {
      "type": "struct std::contract_id::ContractId",
      "metadataTypeId": 9,
      "components": [
        {
          "name": "bits",
          "typeId": 0
        }
      ]
    },
    {
      "type": "struct sway_libs::upgradability::events::ProxyOwnerSet",
      "metadataTypeId": 10,
      "components": [
        {
          "name": "new_proxy_owner",
          "typeId": 2
        }
      ]
    },
    {
      "type": "struct sway_libs::upgradability::events::ProxyTargetSet",
      "metadataTypeId": 11,
      "components": [
        {
          "name": "new_target",
          "typeId": 9
        }
      ]
    }
  ],
  "functions": [
    {
      "inputs": [],
      "name": "proxy_target",
      "output": "0d79387ad3bacdc3b7aad9da3a96f4ce60d9a1b6002df254069ad95a3931d5c8",
      "attributes": [
        {
          "name": "doc-comment",
          "arguments": [
            " Returns the target contract of the proxy contract."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Returns"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * [Option<ContractId>] - The new proxy contract to which all fallback calls will be passed or `None`."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Number of Storage Accesses"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * Reads: `1`"
          ]
        },
        {
          "name": "storage",
          "arguments": [
            "read"
          ]
        }
      ]
    },
    {
      "inputs": [
        {
          "name": "new_target",
          "concreteTypeId": "29c10735d33b5159f0c71ee1dbd17b36a3e69e41f00fab0d42e1bd9f428d8a54"
        }
      ],
      "name": "set_proxy_target",
      "output": "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d",
      "attributes": [
        {
          "name": "doc-comment",
          "arguments": [
            " Change the target contract of the proxy contract."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Additional Information"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " This method can only be called by the `proxy_owner`."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Arguments"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * `new_target`: [ContractId] - The new proxy contract to which all fallback calls will be passed."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Reverts"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * When not called by `proxy_owner`."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Number of Storage Accesses"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * Reads: `1`"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * Write: `1`"
          ]
        },
        {
          "name": "storage",
          "arguments": [
            "read",
            "write"
          ]
        }
      ]
    },
    {
      "inputs": [],
      "name": "proxy_owner",
      "output": "192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c",
      "attributes": [
        {
          "name": "doc-comment",
          "arguments": [
            " Returns the owner of the proxy contract."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Returns"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * [State] - Represents the state of ownership for this contract."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Number of Storage Accesses"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * Reads: `1`"
          ]
        },
        {
          "name": "storage",
          "arguments": [
            "read"
          ]
        }
      ]
    },
    {
      "inputs": [],
      "name": "initialize_proxy",
      "output": "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d",
      "attributes": [
        {
          "name": "doc-comment",
          "arguments": [
            " Initializes the proxy contract."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Additional Information"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " This method sets the storage values using the values of the configurable constants `INITIAL_TARGET` and `INITIAL_OWNER`."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " This then allows methods that write to storage to be called."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " This method can only be called once."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Reverts"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * When `storage::SRC14.proxy_owner` is not [State::Uninitialized]."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Number of Storage Accesses"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * Writes: `2`"
          ]
        },
        {
          "name": "storage",
          "arguments": [
            "write"
          ]
        }
      ]
    },
    {
      "inputs": [
        {
          "name": "new_proxy_owner",
          "concreteTypeId": "192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c"
        }
      ],
      "name": "set_proxy_owner",
      "output": "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d",
      "attributes": [
        {
          "name": "doc-comment",
          "arguments": [
            " Changes proxy ownership to the passed State."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Additional Information"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " This method can be used to transfer ownership between Identities or to revoke ownership."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Arguments"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * `new_proxy_owner`: [State] - The new state of the proxy ownership."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Reverts"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * When the sender is not the current proxy owner."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * When the new state of the proxy ownership is [State::Uninitialized]."
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " # Number of Storage Accesses"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            ""
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * Reads: `1`"
          ]
        },
        {
          "name": "doc-comment",
          "arguments": [
            " * Writes: `1`"
          ]
        },
        {
          "name": "storage",
          "arguments": [
            "write"
          ]
        }
      ]
    }
  ],
  "loggedTypes": [
    {
      "logId": "4571204900286667806",
      "concreteTypeId": "3f702ea3351c9c1ece2b84048006c8034a24cbc2bad2e740d0412b4172951d3d"
    },
    {
      "logId": "2151606668983994881",
      "concreteTypeId": "1ddc0adda1270a016c08ffd614f29f599b4725407c8954c8b960bdf651a9a6c8"
    },
    {
      "logId": "2161305517876418151",
      "concreteTypeId": "1dfe7feadc1d9667a4351761230f948744068a090fe91b1bc6763a90ed5d3893"
    },
    {
      "logId": "4354576968059844266",
      "concreteTypeId": "3c6e90ae504df6aad8b34a93ba77dc62623e00b777eecacfa034a8ac6e890c74"
    },
    {
      "logId": "10870989709723147660",
      "concreteTypeId": "96dd838b44f99d8ccae2a7948137ab6256c48ca4abc6168abc880de07fba7247"
    },
    {
      "logId": "10098701174489624218",
      "concreteTypeId": "8c25cb3686462e9a86d2883c5688a22fe738b0bbc85f458d2d2b5f3f667c6d5a"
    }
  ],
  "messagesTypes": [],
  "configurables": [
    {
      "name": "INITIAL_TARGET",
      "concreteTypeId": "0d79387ad3bacdc3b7aad9da3a96f4ce60d9a1b6002df254069ad95a3931d5c8",
      "offset": 13368
    },
    {
      "name": "INITIAL_OWNER",
      "concreteTypeId": "192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c",
      "offset": 13320
    }
  ]
};
var storageSlots = [
  {
    "key": "7bb458adc1d118713319a5baa00a2d049dd64d2916477d2688d76970c898cd55",
    "value": "0000000000000000000000000000000000000000000000000000000000000000"
  },
  {
    "key": "7bb458adc1d118713319a5baa00a2d049dd64d2916477d2688d76970c898cd56",
    "value": "0000000000000000000000000000000000000000000000000000000000000000"
  },
  {
    "key": "bb79927b15d9259ea316f2ecb2297d6cc8851888a98278c0a2e03e1a091ea754",
    "value": "0000000000000000000000000000000000000000000000000000000000000000"
  },
  {
    "key": "bb79927b15d9259ea316f2ecb2297d6cc8851888a98278c0a2e03e1a091ea755",
    "value": "0000000000000000000000000000000000000000000000000000000000000000"
  }
];
var Src14OwnedProxy = class extends src_exports.Contract {
  constructor(id, accountOrProvider) {
    super(id, abi, accountOrProvider);
  }
};
__publicField(Src14OwnedProxy, "abi", abi);
__publicField(Src14OwnedProxy, "storageSlots", storageSlots);

// src/cli/commands/deploy/proxy/types/Src14OwnedProxyFactory.ts
var bytecode = (0, src_exports.decompressBytecode)("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");
var _Src14OwnedProxyFactory = class extends src_exports.ContractFactory {
  constructor(accountOrProvider) {
    super(bytecode, Src14OwnedProxy.abi, accountOrProvider);
  }
  deploy(deployOptions) {
    return super.deploy({
      storageSlots: Src14OwnedProxy.storageSlots,
      ...deployOptions
    });
  }
  static async deploy(wallet, options = {}) {
    const factory = new _Src14OwnedProxyFactory(wallet);
    return factory.deploy(options);
  }
};
var Src14OwnedProxyFactory = _Src14OwnedProxyFactory;
__publicField(Src14OwnedProxyFactory, "bytecode", bytecode);

// src/cli/commands/deploy/deployContracts.ts
async function deployContract(wallet, binaryPath, abiPath, storageSlotsPath, deployConfig, contractPath, tomlContents) {
  debug(`Deploying contract for ABI: ${abiPath}`);
  if (existsSync2(storageSlotsPath)) {
    const storageSlots3 = JSON.parse(readFileSync2(storageSlotsPath, "utf-8"));
    deployConfig.storageSlots = storageSlots3;
  }
  const targetBytecode = readFileSync2(binaryPath);
  const targetAbi = JSON.parse(readFileSync2(abiPath, "utf-8"));
  const targetStorageSlots = deployConfig.storageSlots ?? [];
  const proxyBytecode = Src14OwnedProxyFactory.bytecode;
  const proxyAbi = Src14OwnedProxy.abi;
  const proxyStorageSlots = Src14OwnedProxy.storageSlots ?? [];
  const isProxyEnabled = tomlContents?.proxy?.enabled;
  const proxyAddress = tomlContents?.proxy?.address;
  if (!isProxyEnabled) {
    const contractFactory = new ContractFactory2(targetBytecode, targetAbi, wallet);
    const { waitForResult } = await contractFactory.deploy(deployConfig);
    const { contract } = await waitForResult();
    return contract.id.toB256();
  }
  if (proxyAddress) {
    const targetContractFactory2 = new ContractFactory2(targetBytecode, targetAbi, wallet);
    const { waitForResult: waitForTarget2 } = await targetContractFactory2.deploy(deployConfig);
    const { contract: targetContract2 } = await waitForTarget2();
    const proxyContract2 = new Contract3(proxyAddress, proxyAbi, wallet);
    const { waitForResult: waitForProxyUpdate } = await proxyContract2.functions.set_proxy_target({ bits: targetContract2.id.toB256() }).call();
    await waitForProxyUpdate();
    return proxyAddress;
  }
  const targetContractFactory = new ContractFactory2(targetBytecode, targetAbi, wallet);
  const { waitForResult: waitForTarget } = await targetContractFactory.deploy(deployConfig);
  const { contract: targetContract } = await waitForTarget();
  const { storageSlots: storageSlots2, stateRoot, ...commonDeployConfig } = deployConfig;
  const mergedStorageSlots = targetStorageSlots.concat(proxyStorageSlots);
  const proxyDeployConfig = {
    ...commonDeployConfig,
    storageSlots: mergedStorageSlots,
    configurableConstants: {
      INITIAL_TARGET: { bits: targetContract.id.toB256() },
      INITIAL_OWNER: { Initialized: { Address: { bits: wallet.address.toB256() } } }
    }
  };
  const proxyFactory = new ContractFactory2(proxyBytecode, proxyAbi, wallet);
  const { waitForResult: waitForProxy } = await proxyFactory.deploy(proxyDeployConfig);
  const { contract: proxyContract } = await waitForProxy();
  const { waitForResult: waitForProxyInit } = await proxyContract.functions.initialize_proxy().call();
  await waitForProxyInit();
  const proxyContractId = proxyContract.id.toB256();
  setForcTomlProxyAddress(contractPath, proxyContractId);
  return proxyContractId;
}
async function deployContracts(config) {
  const contracts = [];
  const wallet = await createWallet(config.providerUrl, config.privateKey);
  log(`Deploying contracts to: ${wallet.provider.url}`);
  const contractsLen = config.contracts.length;
  for (let i = 0; i < contractsLen; i++) {
    const contractPath = config.contracts[i];
    const forcTomlPath = getClosestForcTomlDir(contractPath);
    const binaryPath = getBinaryPath(contractPath, config);
    const abiPath = getABIPath(contractPath, config);
    const storageSlotsPath = getStorageSlotsPath(contractPath, config);
    const projectName = getContractName(contractPath);
    const contractName = getContractCamelCase(contractPath);
    const tomlContents = readForcToml(forcTomlPath);
    const deployConfig = await getDeployConfig(config.deployConfig, {
      contracts: Array.from(contracts),
      contractName,
      contractPath
    });
    const contractId = await deployContract(
      wallet,
      binaryPath,
      abiPath,
      storageSlotsPath,
      deployConfig,
      contractPath,
      tomlContents
    );
    debug(`Contract deployed: ${projectName} - ${contractId}`);
    contracts.push({
      name: contractName,
      contractId
    });
  }
  return contracts;
}

// src/cli/commands/deploy/deployPredicates.ts
import { getPredicateRoot } from "@fuel-ts/account";
import { ContractFactory as ContractFactory3 } from "@fuel-ts/contract";
import { arrayify } from "@fuel-ts/utils";
import { debug as debug2, log as log2 } from "console";
import { readFileSync as readFileSync3 } from "fs";

// src/cli/commands/deploy/adjustOffsets.ts
var adjustOffsets = (jsonAbi, configurableOffsetDiff) => {
  const { configurables: readOnlyConfigurables } = jsonAbi;
  const configurables = [];
  readOnlyConfigurables.forEach((config) => {
    configurables.push({ ...config, offset: config.offset - configurableOffsetDiff });
  });
  return { ...jsonAbi, configurables };
};

// src/cli/commands/deploy/deployPredicates.ts
async function deployPredicate(wallet, binaryPath, abiPath) {
  debug2(`Deploying predicate for ABI: ${abiPath}`);
  const bytecode2 = readFileSync3(binaryPath);
  const abi2 = JSON.parse(readFileSync3(abiPath, "utf-8"));
  const factory = new ContractFactory3(bytecode2, abi2, wallet);
  const { waitForResult } = await factory.deployAsBlobTxForScript();
  const { loaderBytecode, configurableOffsetDiff } = await waitForResult();
  return {
    loaderBytecode,
    configurableOffsetDiff
  };
}
async function deployPredicates(config) {
  const predicates = [];
  const wallet = await createWallet(config.providerUrl, config.privateKey);
  log2(`Deploying predicates to: ${wallet.provider.url}`);
  const predicatesLen = config.predicates.length;
  for (let i = 0; i < predicatesLen; i++) {
    const predicatePath = config.predicates[i];
    const binaryPath = getBinaryPath(predicatePath, config);
    const abiPath = getABIPath(predicatePath, config);
    const projectName = getPredicateName(predicatePath);
    const { loaderBytecode, configurableOffsetDiff } = await deployPredicate(
      wallet,
      binaryPath,
      abiPath
    );
    const predicateRoot = getPredicateRoot(loaderBytecode);
    let abi2 = JSON.parse(readFileSync3(abiPath, "utf-8"));
    if (configurableOffsetDiff) {
      abi2 = adjustOffsets(abi2, configurableOffsetDiff);
    }
    debug2(`Predicate deployed: ${projectName} - ${predicateRoot}`);
    predicates.push({
      path: predicatePath,
      predicateRoot,
      loaderBytecode: arrayify(loaderBytecode),
      abi: abi2
    });
  }
  return predicates;
}

// src/cli/commands/deploy/deployScripts.ts
import { ContractFactory as ContractFactory4 } from "@fuel-ts/contract";
import { arrayify as arrayify2 } from "@fuel-ts/utils";
import { debug as debug3, log as log3 } from "console";
import { readFileSync as readFileSync4 } from "fs";
async function deployScript(wallet, binaryPath, abiPath) {
  debug3(`Deploying script for ABI: ${abiPath}`);
  const bytecode2 = readFileSync4(binaryPath);
  const abi2 = JSON.parse(readFileSync4(abiPath, "utf-8"));
  const factory = new ContractFactory4(bytecode2, abi2, wallet);
  const { waitForResult, blobId } = await factory.deployAsBlobTxForScript();
  const { configurableOffsetDiff, loaderBytecode } = await waitForResult();
  return {
    blobId,
    loaderBytecode,
    configurableOffsetDiff
  };
}
async function deployScripts(config) {
  const scripts = [];
  const wallet = await createWallet(config.providerUrl, config.privateKey);
  log3(`Deploying scripts to: ${wallet.provider.url}`);
  const scriptsLen = config.scripts.length;
  for (let i = 0; i < scriptsLen; i++) {
    const scriptPath = config.scripts[i];
    const binaryPath = getBinaryPath(scriptPath, config);
    const abiPath = getABIPath(scriptPath, config);
    const projectName = getScriptName(scriptPath);
    const { blobId, loaderBytecode, configurableOffsetDiff } = await deployScript(
      wallet,
      binaryPath,
      abiPath
    );
    let abi2 = JSON.parse(readFileSync4(abiPath, "utf-8"));
    if (configurableOffsetDiff) {
      abi2 = adjustOffsets(abi2, configurableOffsetDiff);
    }
    debug3(`Script deployed: ${projectName} - ${blobId}`);
    scripts.push({
      path: scriptPath,
      loaderBytecode: arrayify2(loaderBytecode),
      abi: abi2
    });
  }
  return scripts;
}

// src/cli/commands/deploy/saveContractIds.ts
import { writeFile, mkdir } from "fs/promises";
import { resolve } from "path";
async function saveContractIds(contracts, output) {
  const contractsMap = contracts.reduce(
    (cConfig, { name, contractId }) => ({
      ...cConfig,
      [name]: contractId
    }),
    {}
  );
  const filePath = resolve(output, "contract-ids.json");
  await mkdir(output, { recursive: true });
  await writeFile(filePath, JSON.stringify(contractsMap, null, 2));
  log(`Contract IDs saved at: ${filePath}`);
}

// src/cli/commands/deploy/savePredicateFiles.ts
import { writeFileSync as writeFileSync3 } from "fs";
function savePredicateFiles(predicates, _config) {
  for (const { path, predicateRoot, loaderBytecode, abi: abi2 } of predicates) {
    const predicateName = getPredicateName(path);
    const predicateRootPath = `${path}/out/${predicateName}-loader-bin-root`;
    writeFileSync3(predicateRootPath, predicateRoot);
    const loaderBytecodePath = `${path}/out/${predicateName}-loader.bin`;
    writeFileSync3(loaderBytecodePath, loaderBytecode);
    const abiPath = `${path}/out/${predicateName}-loader-abi.json`;
    writeFileSync3(abiPath, JSON.stringify(abi2, null, 2));
  }
}

// src/cli/commands/deploy/saveScriptFiles.ts
import { writeFileSync as writeFileSync4 } from "fs";
function saveScriptFiles(scripts, _config) {
  for (const { path, loaderBytecode, abi: abi2 } of scripts) {
    const scriptName = getScriptName(path);
    const loaderBytecodePath = `${path}/out/${scriptName}-loader.bin`;
    writeFileSync4(loaderBytecodePath, loaderBytecode);
    const abiPath = `${path}/out/${scriptName}-loader-abi.json`;
    writeFileSync4(abiPath, JSON.stringify(abi2, null, 2));
  }
}

// src/cli/commands/deploy/index.ts
async function deploy(config) {
  const contractIds = await deployContracts(config);
  await saveContractIds(contractIds, config.output);
  config.onDeploy?.(config, contractIds);
  const scripts = await deployScripts(config);
  saveScriptFiles(scripts, config);
  const predicates = await deployPredicates(config);
  savePredicateFiles(predicates, config);
  await generateTypes(config);
  return contractIds;
}

// src/cli/commands/dev/autoStartFuelCore.ts
import { defaultConsensusKey } from "@fuel-ts/utils";
import { getPortPromise } from "portfinder";

// src/test-utils.ts
var test_utils_exports = {};
__reExport(test_utils_exports, test_utils_star);
__reExport(test_utils_exports, test_utils_star2);
__reExport(test_utils_exports, test_utils_star3);
__reExport(test_utils_exports, test_utils_star4);
import * as test_utils_star from "@fuel-ts/contract/test-utils";
import * as test_utils_star2 from "@fuel-ts/account/test-utils";
import * as test_utils_star3 from "@fuel-ts/errors/test-utils";
import * as test_utils_star4 from "@fuel-ts/utils/test-utils";

// src/cli/commands/dev/autoStartFuelCore.ts
var autoStartFuelCore = async (config) => {
  let fuelCore;
  if (config.autoStartFuelCore) {
    log(`Starting node using: '${config.fuelCorePath}'`);
    const bindIp = "0.0.0.0";
    const accessIp = "127.0.0.1";
    const port = config.fuelCorePort ?? await getPortPromise({ port: 4e3 });
    const providerUrl = `http://${accessIp}:${port}/v1/graphql`;
    const { cleanup, snapshotDir } = await (0, test_utils_exports.launchNode)({
      args: [
        ["--snapshot", config.snapshotDir],
        ["--db-type", "in-memory"]
      ].flat(),
      ip: bindIp,
      port: port.toString(),
      loggingEnabled: loggingConfig.isLoggingEnabled,
      basePath: config.basePath,
      fuelCorePath: config.fuelCorePath
    });
    fuelCore = {
      bindIp,
      accessIp,
      port,
      providerUrl,
      snapshotDir,
      killChildProcess: cleanup
    };
    config.providerUrl = fuelCore.providerUrl;
    config.privateKey = defaultConsensusKey;
  }
  return fuelCore;
};

// src/cli/commands/build/buildSwayProgram.ts
import { spawn } from "child_process";

// src/cli/commands/build/forcHandlers.ts
var onForcExit = (onResultFn, onErrorFn) => (code) => {
  if (code) {
    onErrorFn(code);
  } else {
    onResultFn();
  }
};
var onForcError = (onError) => (err) => {
  error(err);
  onError(err);
};

// src/cli/commands/build/buildSwayProgram.ts
var buildSwayProgram = async (config, path) => {
  debug("Building Sway program", path);
  return new Promise((resolve4, reject) => {
    const args = ["build", "-p", path].concat(config.forcBuildFlags);
    const forc = spawn(config.forcPath, args, { stdio: "pipe" });
    if (loggingConfig.isLoggingEnabled) {
      forc.stderr?.on("data", (chunk) => console.log(chunk.toString()));
    }
    if (loggingConfig.isDebugEnabled) {
      forc.stdout?.on("data", (chunk) => {
        console.log(chunk.toString());
      });
    }
    const onExit = onForcExit(resolve4, reject);
    const onError = onForcError(reject);
    forc.on("exit", onExit);
    forc.on("error", onError);
  });
};

// src/cli/commands/build/buildSwayPrograms.ts
async function buildSwayPrograms(config) {
  log(`Building Sway programs using: '${config.forcPath}'`);
  const paths = config.workspace ? [config.workspace] : [config.contracts, config.predicates, config.scripts].flat();
  await Promise.all(paths.map((path) => buildSwayProgram(config, path)));
}

// src/cli/commands/build/index.ts
async function build(config, program) {
  log("Building..");
  await buildSwayPrograms(config);
  await generateTypes(config);
  config.onBuild?.(config);
  const options = program?.opts();
  if (options?.deploy) {
    const fuelCore = await autoStartFuelCore(config);
    await deploy(config);
    fuelCore?.killChildProcess();
  }
}

// src/cli/commands/dev/index.ts
import { watch } from "chokidar";
import { globSync as globSync2 } from "glob";

// src/cli/config/loadConfig.ts
import { FuelError as FuelError3 } from "@fuel-ts/errors";
import { defaultConsensusKey as defaultConsensusKey2 } from "@fuel-ts/utils";
import { bundleRequire } from "bundle-require";
import JoyCon from "joycon";
import { resolve as resolve2, parse } from "path";

// src/cli-utils.ts
var cli_utils_exports = {};
__reExport(cli_utils_exports, cli_utils_star);
import * as cli_utils_star from "@fuel-ts/utils/cli-utils";

// src/cli/config/validateConfig.ts
import * as yup from "yup";
var schema = yup.object({
  workspace: yup.string(),
  contracts: yup.array(yup.string()),
  scripts: yup.array(yup.string()),
  predicates: yup.array(yup.string()),
  output: yup.string().required("config.output should be a valid string")
}).required();
async function validateConfig(config) {
  return schema.validate(config);
}

// src/cli/config/loadConfig.ts
async function loadUserConfig(cwd) {
  const configJoycon = new JoyCon();
  const configPath = await configJoycon.resolve({
    files: ["ts", "js", "cjs", "mjs"].map((e) => `fuels.config.${e}`),
    cwd,
    stopDir: parse(cwd).root
  });
  if (!configPath) {
    throw new FuelError3(FuelError3.CODES.CONFIG_FILE_NOT_FOUND, "Config file not found!");
  }
  const esbuildOptions = {
    target: "ES2021",
    platform: "node",
    format: "esm"
  };
  const result = await bundleRequire({
    filepath: configPath,
    esbuildOptions,
    cwd
  });
  const userConfig = result.mod.default;
  return { configPath, userConfig };
}
async function loadConfig(cwd) {
  const { configPath, userConfig } = await loadUserConfig(cwd);
  await validateConfig(userConfig);
  const { forcBuildFlags = [] } = userConfig;
  const releaseFlag = forcBuildFlags.find((f) => f === "--release");
  const buildMode = releaseFlag ? "release" : "debug";
  const { forcPath, fuelCorePath } = (0, cli_utils_exports.tryFindBinaries)({
    forcPath: userConfig.forcPath,
    fuelCorePath: userConfig.fuelCorePath
  });
  const config = {
    contracts: [],
    scripts: [],
    predicates: [],
    deployConfig: {},
    autoStartFuelCore: true,
    fuelCorePort: 4e3,
    providerUrl: process.env.FUEL_NETWORK_URL ?? "http://127.0.0.1:4000/v1/graphql",
    privateKey: defaultConsensusKey2,
    ...userConfig,
    basePath: cwd,
    forcPath,
    fuelCorePath,
    configPath,
    forcBuildFlags,
    buildMode
  };
  config.output = resolve2(cwd, config.output);
  config.autoStartFuelCore = userConfig.autoStartFuelCore ?? true;
  if (!userConfig.workspace) {
    const { contracts, predicates, scripts } = userConfig;
    config.contracts = (contracts || []).map((c) => resolve2(cwd, c));
    config.scripts = (scripts || []).map((s) => resolve2(cwd, s));
    config.predicates = (predicates || []).map((p) => resolve2(cwd, p));
  } else {
    const workspace = resolve2(cwd, userConfig.workspace);
    const forcToml = readForcToml(workspace);
    if (!forcToml.workspace) {
      const workspaceMsg = `Forc workspace not detected in:
  ${workspace}/Forc.toml`;
      const swayProgramType = readSwayType(workspace);
      const exampleMsg = `Try using '${swayProgramType}s' instead of 'workspace' in:
  ${configPath}`;
      throw new FuelError3(
        FuelError3.CODES.WORKSPACE_NOT_DETECTED,
        [workspaceMsg, exampleMsg].join("\n\n")
      );
    }
    const swayMembers = forcToml.workspace.members.map((member) => resolve2(workspace, member));
    swayMembers.map((path) => ({ path, type: readSwayType(path) })).filter(({ type }) => type !== "library" /* library */).forEach(({ path, type }) => config[`${type}s`].push(path));
    config.workspace = workspace;
  }
  return config;
}

// src/cli/commands/withConfig.ts
import { capitalizeString } from "@fuel-ts/utils";
var withConfigErrorHandler = async (err, config) => {
  error(err.message);
  if (config) {
    await config.onFailure?.(config, err);
  }
};
function withConfig(program, command, fn) {
  return async () => {
    const options = program.opts();
    let config;
    try {
      config = await loadConfig(options.path);
    } catch (err) {
      await withConfigErrorHandler(err);
      return;
    }
    try {
      await fn(config, program);
      log(`\u{1F389}  ${capitalizeString(command)} completed successfully!`);
    } catch (err) {
      await withConfigErrorHandler(err, config);
    }
  };
}

// src/cli/commands/dev/index.ts
var closeAllFileHandlers = (handlers) => {
  handlers.forEach((h) => h.close());
};
var buildAndDeploy = async (config) => {
  await build(config);
  const deployedContracts = await deploy(config);
  config.onDev?.(config);
  return deployedContracts;
};
var getConfigFilepathsToWatch = (config) => {
  const configFilePathsToWatch = [config.configPath];
  if (config.snapshotDir) {
    configFilePathsToWatch.push(config.snapshotDir);
  }
  return configFilePathsToWatch;
};
var workspaceFileChanged = (state) => async (_event, path) => {
  log(`
File changed: ${path}`);
  await buildAndDeploy(state.config);
};
var configFileChanged = (state) => async (_event, path) => {
  log(`
File changed: ${path}`);
  closeAllFileHandlers(state.watchHandlers);
  state.fuelCore?.killChildProcess();
  try {
    await dev(await loadConfig(state.config.basePath));
  } catch (err) {
    await withConfigErrorHandler(err, state.config);
  }
};
var dev = async (config) => {
  const fuelCore = await autoStartFuelCore(config);
  const configFilePaths = getConfigFilepathsToWatch(config);
  const { contracts, scripts, predicates, basePath: cwd } = config;
  const workspaceFilePaths = [contracts, predicates, scripts].flat().flatMap((dir) => [
    dir,
    globSync2(`${dir}/**/*.toml`, { cwd }),
    globSync2(`${dir}/**/*.sw`, { cwd })
  ]).flat();
  try {
    await buildAndDeploy(config);
    const watchHandlers = [];
    const options = { persistent: true, ignoreInitial: true, ignored: "**/out/**" };
    const state = { config, watchHandlers, fuelCore };
    watchHandlers.push(watch(configFilePaths, options).on("all", configFileChanged(state)));
    watchHandlers.push(watch(workspaceFilePaths, options).on("all", workspaceFileChanged(state)));
  } catch (err) {
    error(err);
    throw err;
  }
};

// src/cli/commands/init/index.ts
import { FuelError as FuelError4 } from "@fuel-ts/errors";
import { existsSync as existsSync3, writeFileSync as writeFileSync5 } from "fs";
import { globSync as globSync3 } from "glob";
import { join as join3, relative, resolve as resolve3 } from "path";

// src/cli/templates/fuels.config.ts
import Handlebars2 from "handlebars";

// src/cli/templates/fuels.config.hbs
var fuels_config_default = "import { createConfig } from 'fuels';\n\nexport default createConfig({\n  {{#if (isDefined workspace)}}\n  workspace: '{{workspace}}',\n  {{else}}\n    {{#if (isDefined contracts)}}\n  contracts: [\n      {{#each contracts}}\n        '{{this}}',\n      {{/each}}\n  ],\n    {{/if}}\n    {{#if (isDefined predicates)}}\n  predicates: [\n      {{#each predicates}}\n        '{{this}}',\n      {{/each}}\n  ],\n    {{/if}}\n    {{#if (isDefined scripts)}}\n  scripts: [\n      {{#each scripts}}\n        '{{this}}',\n      {{/each}}\n  ],\n    {{/if}}\n  {{/if}}\n  output: '{{output}}',\n  {{#if (isDefined forcPath)}}\n  forcPath: '{{forcPath}}',\n  {{/if}}\n  {{#if (isDefined fuelCorePath)}}\n  fuelCorePath: '{{fuelCorePath}}',\n  {{/if}}\n  {{#if (isDefined autoStartFuelCore)}}\n  autoStartFuelCore: {{autoStartFuelCore}},\n  {{/if}}\n});\n\n/**\n * Check the docs:\n * https://docs.fuel.network/docs/fuels-ts/fuels-cli/config-file/\n */\n";

// src/cli/templates/fuels.config.ts
Handlebars2.registerHelper("isDefined", (v) => v !== void 0);
function renderFuelsConfigTemplate(props) {
  const renderTemplate = Handlebars2.compile(fuels_config_default, {
    strict: true,
    noEscape: true
  });
  return renderTemplate(props);
}

// src/cli/commands/init/index.ts
function init(program) {
  const options = program.opts();
  const { path, autoStartFuelCore: autoStartFuelCore2, forcPath, fuelCorePath } = options;
  let workspace;
  let absoluteWorkspace;
  if (options.workspace) {
    absoluteWorkspace = resolve3(path, options.workspace);
    workspace = `./${relative(path, absoluteWorkspace)}`;
  }
  const absoluteOutput = resolve3(path, options.output);
  const output = `./${relative(path, absoluteOutput)}`;
  const [contracts, scripts, predicates] = ["contracts", "scripts", "predicates"].map(
    (optionName) => {
      const pathOrGlob = options[optionName];
      if (!pathOrGlob) {
        return void 0;
      }
      const expanded = globSync3(pathOrGlob, { cwd: path });
      const relatives = expanded.map((e) => relative(path, e));
      return relatives;
    }
  );
  const noneIsInformed = ![workspace, contracts, scripts, predicates].find((v) => v !== void 0);
  if (noneIsInformed) {
    console.log(`error: required option '-w, --workspace <path>' not specified\r`);
    process.exit(1);
  } else {
    const fuelsConfigPath = join3(path, "fuels.config.ts");
    if (existsSync3(fuelsConfigPath)) {
      throw new FuelError4(
        FuelError4.CODES.CONFIG_FILE_ALREADY_EXISTS,
        `Config file exists, aborting.
  ${fuelsConfigPath}`
      );
    }
    const renderedConfig = renderFuelsConfigTemplate({
      workspace,
      contracts,
      scripts,
      predicates,
      output,
      forcPath,
      fuelCorePath,
      autoStartFuelCore: autoStartFuelCore2
    });
    writeFileSync5(fuelsConfigPath, renderedConfig);
    log(`Config file created at:

 ${fuelsConfigPath}
`);
  }
}

// src/cli/commands/node/index.ts
import { watch as watch2 } from "chokidar";
var getConfigFilepathsToWatch2 = (config) => {
  const configFilePathsToWatch = [config.configPath];
  if (config.snapshotDir) {
    configFilePathsToWatch.push(config.snapshotDir);
  }
  return configFilePathsToWatch;
};
var closeAllFileHandlers2 = (handlers) => {
  handlers.forEach((h) => h.close());
};
var configFileChanged2 = (state) => async (_event, path) => {
  log(`
File changed: ${path}`);
  closeAllFileHandlers2(state.watchHandlers);
  state.fuelCore?.killChildProcess();
  try {
    await node(await loadConfig(state.config.basePath));
    state.config.onNode?.(state.config);
  } catch (err) {
    await withConfigErrorHandler(err, state.config);
  }
};
var node = async (config) => {
  const fuelCore = await autoStartFuelCore(config);
  const configFilePaths = getConfigFilepathsToWatch2(config);
  try {
    const watchHandlers = [];
    const options = { persistent: true, ignoreInitial: true, ignored: "**/out/**" };
    const state = { config, watchHandlers, fuelCore };
    watchHandlers.push(watch2(configFilePaths, options).on("all", configFileChanged2(state)));
  } catch (err) {
    error(err);
    throw err;
  }
};

// src/cli/commands/withBinaryPaths.ts
function withBinaryPaths(program, _command, fn) {
  return async () => {
    const options = program.opts();
    const paths = {};
    try {
      const { userConfig } = await loadUserConfig(options.path);
      paths.forcPath = userConfig.forcPath;
      paths.fuelCorePath = userConfig.fuelCorePath;
    } catch (err) {
      debug(err.message);
    }
    try {
      await fn(paths);
    } catch (err) {
      error(err);
    }
  };
}

// src/cli/commands/withProgram.ts
function withProgram(program, _command, fn) {
  return async () => {
    try {
      await fn(program);
    } catch (err) {
      error(err);
    }
  };
}

// src/cli.ts
var onPreAction = (command) => {
  const opts = command.opts();
  configureLogging({
    isDebugEnabled: opts.debug,
    isLoggingEnabled: !opts.silent
  });
};
var configureCli = () => {
  const program = new Command();
  program.name("fuels");
  program.option("-D, --debug", "Enables verbose logging", false);
  program.option("-S, --silent", "Omit output messages", false);
  program.version(versions.FUELS, "-v, --version", "Output the version number");
  program.helpOption("-h, --help", "Display help");
  program.helpCommand("help [command]", "Display help for command");
  program.enablePositionalOptions(true);
  program.hook("preAction", onPreAction);
  const pathOption = new Option("--path <path>", "Path to project root").default(process.cwd());
  let command;
  const desc = `Relative path/globals to `;
  const arg = `<path|global>`;
  (command = program.command("init" /* init */)).description("Create a sample `fuel.config.ts` file").addOption(pathOption).option("-w, --workspace <path>", "Relative dir path to Forc workspace").addOption(new Option(`-c, --contracts ${arg}`, `${desc} Contracts`).conflicts("workspace")).addOption(new Option(`-s, --scripts ${arg}`, `${desc} Scripts`).conflicts("workspace")).addOption(new Option(`-p, --predicates ${arg}`, `${desc} Predicates`).conflicts("workspace")).requiredOption("-o, --output <path>", "Relative dir path for Typescript generation output").option("--forc-path <path>", "Path to the `forc` binary").option("--fuel-core-path <path>", "Path to the `fuel-core` binary").option("--auto-start-fuel-core", "Auto-starts a `fuel-core` node during `dev` command").action(withProgram(command, "init" /* init */, init));
  (command = program.command("dev" /* dev */)).description("Start a Fuel node and run build + deploy on every file change").addOption(pathOption).action(withConfig(command, "dev" /* dev */, dev));
  (command = program.command("node" /* node */)).description("Start a Fuel node").addOption(pathOption).action(withConfig(command, "node" /* node */, node));
  (command = program.command("build" /* build */)).description("Build Sway programs and generate Typescript for them").addOption(pathOption).option(
    "-d, --deploy",
    "Deploy contracts after build (auto-starts a `fuel-core` node if needed)"
  ).action(withConfig(command, "build" /* build */, build));
  (command = program.command("deploy" /* deploy */)).description("Deploy contracts to the Fuel network").addOption(pathOption).action(withConfig(command, "deploy" /* deploy */, deploy));
  configureTypegenCliOptions(
    program.command("typegen").description(`Generate Typescript from Sway ABI JSON files`)
  );
  (command = program.command("versions")).description("Check for version incompatibilities").addOption(pathOption).action(withBinaryPaths(command, "versions" /* versions */, runVersions));
  return program;
};

// src/cli/utils/checkForAndDisplayUpdates.ts
import { versions as versions2, gt, eq } from "@fuel-ts/versions";
var getLatestFuelsVersion = async () => {
  const response = await fetch("https://registry.npmjs.org/fuels/latest");
  const data = await response.json();
  return data.version;
};
var checkForAndDisplayUpdates = async () => {
  try {
    const { FUELS: userFuelsVersion } = versions2;
    const latestFuelsVersion = await Promise.race([
      new Promise((resolve4) => {
        setTimeout(resolve4, 3e3);
      }),
      getLatestFuelsVersion()
    ]);
    if (!latestFuelsVersion) {
      log(`
 Unable to fetch latest fuels version. Skipping...
`);
      return;
    }
    const isFuelsVersionOutdated = gt(latestFuelsVersion, userFuelsVersion);
    const isFuelsVersionUpToDate = eq(latestFuelsVersion, userFuelsVersion);
    if (isFuelsVersionOutdated) {
      warn(
        `
\u26A0\uFE0F There is a newer version of fuels available: ${latestFuelsVersion}. Your version is: ${userFuelsVersion}
`
      );
      return;
    }
    if (isFuelsVersionUpToDate) {
      log(`
\u2705 Your fuels version is up to date: ${userFuelsVersion}
`);
    }
  } catch {
    log(`
 Unable to fetch latest fuels version. Skipping...
`);
  }
};

// src/run.ts
var run = async (argv) => {
  const program = configureCli();
  return Promise.all([await checkForAndDisplayUpdates().catch(error), program.parseAsync(argv)]);
};

// src/bin.ts
try {
  run(process.argv).catch((x) => {
    console.log(x);
  });
} catch (err) {
  error(err?.message || err);
  process.exit(1);
}
//# sourceMappingURL=bin.mjs.map